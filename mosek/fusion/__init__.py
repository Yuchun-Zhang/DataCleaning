## Module: fusion
import array
#------ PRELUDE BEGIN
import threading
import mosek
import mosek.fusion
import mosek.array
import Utils
from Utils import OutputFileStream,Debug


class BaseModel:
  _lock = threading.Lock()
  _global_env = None
  _global_env_counter = 0

  def __init__(self,name,licfile):
    self._lock.acquire()
    try:
      if BaseModel._global_env is None:
        try:
          env = mosek.Env()
          #env.init()
          BaseModel._global_env = env
        except mosek.Exception,e:
          raise UnexpectedError(e)
      BaseModel._global_env_counter += 1
    finally:
      self._lock.release()

    self.__modelname = name
    task = mosek.Task(self._global_env, 0, 0);
    task.putintparam(mosek.iparam.log_expand,0);
    self.__task = task
    if name is not None:
      task.puttaskname(name)
      

    self._synched = SolutionStatus.Optimal;

    self.__vars = []
    self.__cons = []

    self.__varNameMap = {}
    self.__conNameMap = {}

    self._sol_itr = None
    self._sol_bas = None
    self._sol_itg = None

    self.__objname = None
    self.__objexpr = None

    # handler for log output.
    self.__logwriter = None    
    def loghandler(text):
      if self.__logwriter is not None:
        self.__logwriter.write(text)
        self.__logwriter.flush()

    task.set_Stream(mosek.streamtype.log,loghandler)

  def __del__(self):
    if self.__task is not None:
      self._lock.acquire()
      try:
        task = self.__task
        self.__task = None
        BaseModel._global_env_counter += 1
        task.__del__()
      finally:
        self._lock.release()
  def __enter__(self):
    return self
  def __exit__(self,exc_type,exc_val,exc_tb):
    self.__del__()

  def _task_1put_1param_SF(self,name,value):
    self.__task.putnadouparam(name,value)
  def _task_1put_1param_SS(self,name,value):
    self.__task.putnastrparam(name,value)
  def _task_1put_1param_SI(self,name,value):
    self.__task.putnaintaram(name,value)

  def _task_1setLogHandler_OStreamWriter_2(self,handler):
    """
    Set the object to handle log output from the solver.

    The handler object must have a write method accepting a string.
    """
    self.__logwriter = handler
  def _hasVariable_S (self,name):
    return name is not None and self.__varNameMap.has_key(name)
  def _hasConstraint_S (self,name):
    return name is not None and self.__conNameMap.has_key(name)  
  def _addVariable_SOmosek_fusion_Variable_2(self,name,x):
    self.__vars.append(x)
    if name is not None:
      self.__varNameMap[name] = x
  def _addConstraint_SOmosek_fusion_Constraint_2(self,name,c):
    self.__cons.append(c)
    if name is not None:
      self.__conNameMap[name] = c 
  def _getConstraint_S(self,name):
    return self.__conNameMap.get(name,None)
  def _varConstraint_S(self,name):
    return self.__varNameMap.get(name,None)




  def _task_1put_1param_SS(self,name,value):
    self.__task.putnastrparam(name,value)
  def _task_1put_1param_SD(self,name,value):
    self.__task.putnaintparam(name,value)
  def _task_1put_1param_SI(self,name,value):
    self.__task.putnadouparam(name,value)

  def _numVariables_ (self):
    return len(self.__vars)
  def _numConstraints_ (self):
    return len(self.__cons)
  
  def _alloc_1rangedvar_SFF(self,name,lb,ub):
    n = self.__task.getnumvar()
    self.__task.appendvars(1)
    if name is not None:
        self.__task.putvarname(n,name)
    self.__task.putbound(mosek.accmode.var, n, mosek.boundkey.ra, lb, ub)
    return n
  
  def _alloc_1linearvar_SOmosek_fusion_RelationKey_2F(self,name,relkey,bnd):
    task = self.__task
    n = task.getnumvar();
    task.appendvars(1)
    if name is not None:
        task.putvarname(n,name)

    if   relkey is RelationKey.IsFree:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.fr, 0.0, 0.0)
    elif relkey is RelationKey.LessThan:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.up, 0.0, bnd)
    elif relkey is RelationKey.GreaterThan:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.lo, bnd, 0.0)
    else:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.fx, bnd, bnd)
    return n

  def _task_1con_1name_IS(self,idx,name):
    self.__task.putconname(idx,name)
  def _task_1var_1name_IS(self,idx, name):
    self.__task.putvarname(idx,name)
  
  def _task_1cone_1name_IS(self,idx,name):
    self.__task.putconename(idx,name)

  def _task_1numcon_(self):
    return self.__task.getnumcon()
  def _task_1numvar_(self):
    return self.__task.getnumvar()
  def _task_1numcone_(self):
    return self.__task.getnumcone()
  
  def __task_putboundslice(self,acc,first,last,bl,bu,bk):  
    num = last-first
    if bl == None: bl = mosek.array.zeros(num,float)
    if bu is None: bu = mosek.array.zeros(num,float)
    
    bka = [bk] * num
    self.__task.putboundslice(acc,first,last,bka,bl,bu)
  

  def __task_putboundlist(self,acc,idxs,bl,bu,bk):
    num = len(idxs)
    if bl is None: bl = mosek.array.zeros(num,float)
    if bu is None: bu = mosek.array.zeros(num,float)

    bka = [bk] * num
    self.__task.putboundlist(acc,idxs,bka,bl,bu)
  
  def _task_1con_1putboundslice_1fx_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1con_1putboundslice_1lo_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1con_1putboundslice_1up_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.up);
  
  def _task_1con_1putboundslice_1ra_II_3F_3F(self,first, last, lb, ub):
    self.__task_putboundslice(mosek.accmode.con, first, last, lb, ub, mosek.boundkey.ra);
  
  def _task_1con_1putboundslice_1fr_II(self,first, last):
    self.__task_putboundslice(mosek.accmode.con, first, last, None, None, mosek.boundkey.fr);
  
  def _task_1var_1putboundslice_1fx_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1var_1putboundslice_1lo_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1var_1putboundslice_1up_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.up);
  
  def _task_1var_1putboundslice_1ra_II_3F_3F(self,first, last, lb, ub):
    self.__task_putboundslice(mosek.accmode.var, first, last, lb, ub, mosek.boundkey.ra);

  def _task_1var_1putboundslice_1fr_II(self,first, last):
    self.__task_putboundslice(mosek.accmode.var, first, last, None, None, mosek.boundkey.fr);
                                                                  
  def _task_1con_1putboundlist_1fx__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1con_1putboundlist_1lo__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1con_1putboundlist_1up__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.up);
  
  def _task_1con_1putboundlist_1ra__3I_3F_3F(self,idxs, lb, ub):
    self.__task_putboundlist(mosek.accmode.con, idxs, lb, ub, mosek.boundkey.ra);

  def _task_1var_1putintlist__3I(self,idxs):
    self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
  
  
  def _task_1task_1optimize_ (self):
    try:
      self.__task.optimize()
      self.__task.solutionsummary(streamtype.log)
    except mosek.Error, e:
      raise OptimizeError("Error occurred while optimizeing")
    except mosek.Warning,e:
      pass
  
  def __task_appendvars(self,num):
    idx = self.__task.getnumvar()
    self.__task.appendvars(num)
    return idx

  def __task_appendcons(self,num):
    idx = self.__task.getnumcon()
    self.__task.appendcons(num)
    return idx

  def __task_appendcones(self,ct,conesize,first,num):
    idx = self.__task.getnumcone()
    cts = [ct]       * num
    cps = [0.0]      * num
    csz = [conesize] * num
    self.__task.appendconesseq(cts,cps,csz,first)
    return idx
  
  def _task_1append_1var_I(self,num):
    return self.__task_appendvars(num)

  def _task_1append_1con_I(self,num):
    return self.__task_appendcons(num)

  def _task_1append_1quadcone_III(self,conesize,first,num):
    return self.__task_appendcones(mosek.conetype.quad, conesize, first,num);

  def _task_1append_1rquadcone_III(self,conesize,first,num):
    return self.__task_appendcones(mosek.conetype.rquad, conesize, first,num)
  
  def _task_1putarowslice_II_3L_3I_3F(self,first, last, ptrb, subj, cof):
    num   = last-first
    sub   = range(first,last)
    self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);

  def _task_1putaijlist__3I_3I_3FL(self,subi,subj,cof,num):
    self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
  def _task_1putobjectivename_S(self,name):
    self.__task.putobjname("" if name is None else name)
    
  def _task_1putobjective_B_3I_3FF(self,maximize,subj,cof,cfix):
    c = mosek.array.zeros(self.__task.getnumvar(),mosek.array.float64)
    idxs = range(len(c))
    for i in xrange(len(subj)):
      c[subj[i]] += cof[i]
    self.__task.putclist(idxs,c)
    self.__task.putcfix(cfix)
    self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
  


  def _task_1putbaraij_III(self,i,j,k):
    self.__task.putbaraij(i,j,[k], [1.0])
  def _task_1putbarcj_II(self,j,k):
    self.__task.putbarcj(j,[k],[1.0])
  
  def _task_1putbaraij_II_3I(self,i,j,k):
    self.__task.putbaraij(i,j,k, [1.0]*len(k))
  def _task_1putbarcj_I_3I(self,j,k):
    self.__task.putbarcj(j,k,[1.0]*len(k))

  def _task_1append_1barmatrix_I_3I_3I_3F(self,dim,subi, subj, cof):
    return self.__task.appendsparsesymmat(dim,subi,subj,cof)

  def _task_1barvardim_I(self,index):
    return self.__task.getdimbarvarj(index)

  def _task_1numbarvar_(self):
    return self.__task.getnumbarvar()

  def _task_1barvar_1name_IS(self, idx, name):
    self.__task.putbarvarname(idx,name)

  def _task_1append_1barvar_II(self,size, num):
    res = self.__task.getnumbarvar()
    self.__task.appendbarvars([size] * num)
    return res

  def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
    numvar  = self.__task.getnumvar()
    numcon  = self.__task.getnumcon()
    numcone = self.__task.getnumcone()
    numbarvar = self.__task.getnumbarvar()

    if inumcone < numcone:
      self.__task.removecones(range(inumcone,numcone))

    if inumvar < numvar:
      idxs = range(inumvar,numvar)
      self.__task.removevars(idxs)
    
    if (inumcon < numcon):
      idxs = range(inumcon,numcon)
      self.__task.removecons(idxs)

    if (inumbarvar < numbarvar):
      self.__task.removebarvars(range(inumbarvar,numbarvar))
    
  @staticmethod
  def __convertSolutionStatus(soltype,sol,status):
    pd = { 
        mosek.solsta.optimal :                    SolutionStatus.Optimal,
        mosek.solsta.integer_optimal :            SolutionStatus.Optimal,
        mosek.solsta.near_integer_optimal :       SolutionStatus.NearOptimal,
        mosek.solsta.prim_and_dual_feas :         SolutionStatus.Feasible,
        mosek.solsta.near_prim_and_dual_feas :    SolutionStatus.NearFeasible,
        mosek.solsta.prim_feas :                  SolutionStatus.Feasible,
        mosek.solsta.near_prim_feas :             SolutionStatus.NearFeasible,
        mosek.solsta.dual_feas :                  SolutionStatus.Unknown,
        mosek.solsta.near_dual_feas :             SolutionStatus.Unknown,
        mosek.solsta.prim_infeas_cer :            SolutionStatus.Unknown,
        mosek.solsta.near_prim_infeas_cer :       SolutionStatus.Unknown,
        mosek.solsta.near_dual_infeas_cer :       SolutionStatus.Certificate,
        mosek.solsta.dual_infeas_cer :            SolutionStatus.NearCertificate }

    dd = {
        mosek.solsta.optimal :                    SolutionStatus.Optimal, 
        mosek.solsta.integer_optimal :            SolutionStatus.Unknown, 
        mosek.solsta.near_integer_optimal :       SolutionStatus.Unknown, 
        mosek.solsta.prim_and_dual_feas :         SolutionStatus.Feasible, 
        mosek.solsta.near_prim_and_dual_feas :    SolutionStatus.NearFeasible, 
        mosek.solsta.prim_feas :                  SolutionStatus.Unknown, 
        mosek.solsta.near_prim_feas :             SolutionStatus.Unknown, 
        mosek.solsta.dual_feas :                  SolutionStatus.Feasible, 
        mosek.solsta.near_dual_feas :             SolutionStatus.NearFeasible, 
        mosek.solsta.prim_infeas_cer :            SolutionStatus.Certificate, 
        mosek.solsta.near_prim_infeas_cer :       SolutionStatus.NearCertificate, 
        mosek.solsta.near_dual_infeas_cer :       SolutionStatus.Unknown, 
        mosek.solsta.dual_infeas_cer :            SolutionStatus.Unknown }

    try: sol.pstatus = pd[status]
    except KeyError: sol.pstatus = SolutionStatus.Unknown
    
    try: sol.dstatus = dd[status]
    except KeyError: sol.dstatus = SolutionStatus.Unknown

  @staticmethod
  def _matchargs_task_1write_S(self,*args):
      return True
  def _task_1write_S(self,filename):
      self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
      self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
      self.__task.writedata(filename)
  
  def _task_1write(self,filename):
    return self._writeProblem_S(filename)
  
      
  @staticmethod
  def _matchargs_task_1solve_(self,*args):
    return True
  def _task_1solve_(self):
    task = self.__task
    ok = False
    try:
      trmcode = mosek.rescode.ok
      try:
        trmcode = task.optimize()
      except mosek.Error,e:
        raise OptimizeError(e)
      except mosek.Warning,e:
        pass
      
      numcon  = task.getnumcon()
      numvar  = task.getnumvar()
      numcone = task.getnumcone()
      numbarvar = task.getnumbarvar()
      
      sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
      sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
      sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)

      self._sol_itr = None
      self._sol_bas = None
      self._sol_itg = None 


      if sol_itr_def:
        self._sol_itr = SolutionStruct(numvar,numcon,numcone,numbarvar)
        sol_itr = self._sol_itr
        prosta,solsta = task.getsolution(
          mosek.soltype.itr,
          #sol_itr.skc,sol_itr.skx,sol_itr.skn,
          None,None,None,
          sol_itr.xc,sol_itr.xx,sol_itr.y,
          sol_itr.slc,sol_itr.suc,
          sol_itr.slx,sol_itr.sux,
          sol_itr.snx)
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_itr.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_itr.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.itr, j, self._sol_itr.barx[j])
          task.getbarsj(mosek.soltype.itr, j, self._sol_itr.bars[j])

        sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
        sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
        self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta);
        #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)

      if sol_bas_def:
        self._sol_bas = SolutionStruct(numvar,numcon,numcone,numbarvar);
        sol_bas = self._sol_bas
        prosta,solsta = task.getsolution(
          mosek.soltype.bas,
          #sol_bas.skc,sol_bas.skx,sol_bas.skn,
          None,None,None,
          sol_bas.xc,sol_bas.xx,sol_bas.y,
          sol_bas.slc,sol_bas.suc,
          sol_bas.slx,sol_bas.sux,
          sol_bas.snx)
        
        # NOTE: this probably never happens:
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_bas.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_bas.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.bas, j, self._sol_bas.barx[j])
          task.getbarsj(mosek.soltype.bas, j, self._sol_bas.bars[j])

        sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
        sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
        self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta);

        #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)

      if sol_itg_def:
        self._sol_itg = SolutionStruct(numvar,numcon,numcone,numbarvar);
        sol_itg = self._sol_itg
        prosta,solsta = task.getsolution(
          mosek.soltype.itg,
          #sol_itg.skc,sol_itg.skx,sol_itg.skn,
          None,None,None,
          sol_itg.xc,sol_itg.xx,sol_itg.y,
          sol_itg.slc,sol_itg.suc,
          sol_itg.slx,sol_itg.sux,
          sol_itg.snx)

        # NOTE: this probably wont happen for a long time:
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_itg.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_itg.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.itg, j, self._sol_itg.barx[j])
          task.getbarsj(mosek.soltype.itg, j, self._sol_itg.bars[j])

        sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
        self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta);
      ok = True
    
    finally:
      if not ok: # means exception
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None


#------ PRELUDE END

def _argtypestr(a):
  if     isinstance(a,bool): return 'bool'
  elif   isinstance(a,int): return 'int'
  elif   isinstance(a,long): return 'long'
  elif   isinstance(a,float): return 'float'
  elif   isinstance(a,basestring): return 'string'
  elif   isinstance(a,list): 
    if len(a) > 0:
      return '[%s]' % _argtypestr(a[0])
    else: 
      return '[]'
  else:  return a.__class__.__name__
def _cliptrace(f):
  def _(*args):
    try:
      return f(*args)
    except Exception,e:
      import sys
      if hasattr(e,'_internal_trace'):
        e._internal_trace.append(sys.exc_info()[2])
      else:
        e._internal_trace = [ sys.exc_info()[2] ]
      raise e
  _.__name__ = f.__name__
  return _
_cliptrace = lambda f:f
##origin: src/fusion/SolutionType.mbi(14:11-19:5)
SolutionType = mosek.Enum("SolutionType",[
    "Default",
    "Basic",
    "Interior",
    "Integer" ])


##origin: src/fusion/SolutionStatus.mbi(47:11-53:5)
AccSolutionStatus = mosek.Enum("AccSolutionStatus",[
    "Anything",
    "Optimal",
    "NearOptimal",
    "Feasible",
    "Certificate" ])


##origin: src/fusion/StatusKey.mbi(16:11-22:5)
StatusKey = mosek.Enum("StatusKey",[
    "Unknown",
    "Basic",
    "SuperBasic",
    "OnBound",
    "Infinity" ])


##origin: src/fusion/ObjectiveSense.mbi(14:11-18:5)
ObjectiveSense = mosek.Enum("ObjectiveSense",[
    "Undefined",
    "Minimize",
    "Maximize" ])


##origin: src/fusion/domain.mbi(8:11-17:5)
RelationKey = mosek.Enum("RelationKey",[
    "EqualsTo",
    "LessThan",
    "GreaterThan",
    "IsFree",
    "InQCone",
    "InRotatedQCone",
    "InPSDCone",
    "InRange" ])


##origin: src/fusion/SolutionStatus.mbi(23:11-36:5)
SolutionStatus = mosek.Enum("SolutionStatus",[
    "Undefined",
    "Unknown",
    "Optimal",
    "NearOptimal",
    "Feasible",
    "NearFeasible",
    "Certificate",
    "NearCertificate" ])


## origin: src/fusion/Variable.mbi(18:12-1166:5)
class Variable:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,m,shape_):
    self._model = m
    self.shape = shape_
    self._shape_p = self.shape
  def __init__(self,*args):
    #self.shape = None

    #self._protected_shape_p = None

    #self._protected_model = None

    self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_reduceDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(41:16-51:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("reduceDims()")
  def __reduceDims_(self):
    if   (self.shape.nd > 1):
      ndim = ( self.shape._realnd_() )

      d = ([ 0 for _autovar_0 in xrange(ndim) ])

      d[0] = 1
      # { @ src/fusion/Variable.mbi(46:11-111)
      j = 0

      # src/fusion/Variable.mbi(46:24-109)
      i = 0

      while (i < ndim):
        if   (( self.shape._dim_I(i) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
        i += 1
      # } @ src/fusion/Variable.mbi(46:11-111)
      self.shape = mosek.fusion.NDSet(d)
      self._shape_p = self.shape
    return self
  @staticmethod
  def _matchargs_asExpr_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(65:15-71:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("asExpr()")
  def _asExpr_(self):
    ptrb = ( Utils.Tools._range_LL (0l,(1l + ( self._size_() ))) )

    subj = ( Utils.Tools._range_LL (0l,( self._size_() )) )

    cof = ( Utils.Tools._ones_I (int(( self._size_() ))) )

    return mosek.fusion.Expr(ptrb,self,subj,cof,None,self.shape,None,1)
  @staticmethod
  def _matchargs_flatten_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(76:18-78:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("flatten()")
  def _flatten_(self):
    return ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (self,mosek.fusion.IntSet(int(self.shape._size))) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(94:15-96:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(113:15-115:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(122:15-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int)")
  def _index_I(self,idx):
    return ( self._slice_II(idx,(idx + 1)) )
  @staticmethod
  def _matchargs_index_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(131:15-133:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int,int)")
  def _index_II(self,i0,i1):
    return ( self._slice__3I_3I(([ i0,i1]),([ (i0 + 1),(i1 + 1)])) )
  @staticmethod
  def _matchargs_index__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(144:15-149:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index([int32])")
  def _index__3I(self,idx):
    idxplusone = ( Utils.Tools._arraycopy__3I (idx) )

    # src/fusion/Variable.mbi(147:9-59)
    i = 0

    while (i < int(len(idx))):
      idxplusone[i] += 1
      i += 1
    return ( ( self._slice__3I_3I(idx,idxplusone) ).__reduceDims_() )
  @staticmethod
  def _matchargs_symmetric_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(152:15-166:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("symmetric(mosek.fusion.Variable)")
  def _symmetric_Omosek_fusion_Variable_2(v):
    _autovar_1 = v
    if   isinstance(_autovar_1,mosek.fusion.PSDVariable):
      w = _autovar_1
      return w
    elif isinstance(_autovar_1,mosek.fusion.SymmetricVariable):
      w = _autovar_1
      return w
    else:
      w = _autovar_1
      return mosek.fusion.SymmetricVariable(w)
  @staticmethod
  def _matchargs_dstack__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(170:18-195:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dstack([mosek.fusion.Variable],int)")
  def _dstack__3Omosek_fusion_Variable_2I(v,dim):
    n = int(len(v))

    nd = (dim + 1)

    # src/fusion/Variable.mbi(174:27-176:14)
    for i in xrange(0,n):
      if   (v[i].shape.nd > nd):
        nd = v[i].shape.nd
    rdims = ([ 0 for _autovar_2 in xrange(nd) ])

    # src/fusion/Variable.mbi(176:9-177:39)
    for i in xrange(0,nd):
      rdims[i] = ( v[0].shape._dim_I(i) )
    rv = ([ None for _autovar_3 in xrange(n) ])

    rv[0] = ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (v[0],mosek.fusion.NDSet(rdims)) )
    # src/fusion/Variable.mbi(182:9-192:9)
    for i in xrange(1,n):
      # { @ src/fusion/Variable.mbi(183:9-192:9)
      # src/fusion/Variable.mbi(184:11-191:18)
      for j in xrange(0,nd):
        if   (j != dim):
          if   (( v[i].shape._dim_I(j) ) != rdims[j]):
            raise mosek.fusion.DimensionError("Variable dimensions do not match")
      rdims[dim] = ( v[i].shape._dim_I(dim) )
      rv[i] = ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (v[i],mosek.fusion.NDSet(rdims)) )
      # } @ src/fusion/Variable.mbi(183:9-192:9)
    return mosek.fusion.CompoundVariable(rv,dim)
  @staticmethod
  def _matchargs_hstack__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(211:15-214:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("hstack([mosek.fusion.Variable])")
  def _hstack__3Omosek_fusion_Variable_2(v):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (v,1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(233:15-237:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(255:15-260:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1,v2):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1,v2]),1) )
  @staticmethod
  def _matchargs_vstack__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(276:15-279:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("vstack([mosek.fusion.Variable])")
  def _vstack__3Omosek_fusion_Variable_2(v):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (v,0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(298:15-302:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(320:15-325:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1,v2):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1,v2]),0) )
  @staticmethod
  def _matchargs_stack__3_3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(453:15-491:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([[mosek.fusion.Variable]])")
  def _stack__3_3Omosek_fusion_Variable_2(vlist):
    tmp = ([ None for _autovar_4 in xrange(int(len(vlist))) ])

    # src/fusion/Variable.mbi(457:9-485:11)
    for i in xrange(0,int(len(vlist))):
      if   (int(len(vlist[i])) == 1):
        v = vlist[i][0]

        if   (v.shape.nd == 1):
          tmp[i] = ( Variable._reshape_Omosek_fusion_Variable_2II (v,( v.shape._dim_I(0) ),1) )
        else:
          tmp[i] = v
      else:
        rowlen = 0

        # src/fusion/Variable.mbi(469:13-472:18)
        j = 0

        while (j < int(len(vlist[i]))):
          if   (vlist[i][j].shape._size > 0):
            rowlen += 1
          j += 1
        vrow = ([ None for _autovar_5 in xrange(rowlen) ])

        k = 0

        # src/fusion/Variable.mbi(472:24-483:13)
        j = 0

        while (j < int(len(vlist[i]))):
          v = vlist[i][j]

          if   (v.shape._size > 0):
            if   (v.shape.nd == 1):
              vrow[k] = ( Variable._reshape_Omosek_fusion_Variable_2II (v,( v.shape._dim_I(0) ),1) )
            else:
              vrow[k] = v
            k += 1
          j += 1
        tmp[i] = mosek.fusion.CompoundVariable(vrow,1)
    if   (int(len(tmp)) == 1):
      return tmp[0]
    else:
      return mosek.fusion.CompoundVariable(tmp,0)
  @staticmethod
  def _matchargs_repeat_Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(505:15-515:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("repeat(mosek.fusion.Variable,int)")
  def _repeat_Omosek_fusion_Variable_2I(v,num):
    if   (num <= 0):
      return mosek.fusion.SliceVariable(v,mosek.fusion.IntSet(0),0l,([ 0l for _autovar_6 in xrange(1) ]))
    else:
      tmp = ([ None for _autovar_7 in xrange(num) ])

      # src/fusion/Variable.mbi(512:11-51)
      i = 0

      while (i < num):
        tmp[i] = v
        i += 1
      return ( Variable._dstack__3Omosek_fusion_Variable_2I (tmp,0) )
  @staticmethod
  def _matchargs_index_1permute_1__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(521:18-531:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_permute_([int32])")
  def _index_1permute_1__3I(self,perm):
    strides = ([ 0l for _autovar_8 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_9 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(525:9-529:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(526:9-529:9)
      strides[i] = ( self.shape._stride_I(perm[i]) )
      dims[i] = ( self.shape._dim_I(perm[i]) )
      # } @ src/fusion/Variable.mbi(526:9-529:9)
    return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet(dims),0l,strides)
  @staticmethod
  def _matchargs_index_1flip_1__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(534:18-551:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_flip_([int32])")
  def _index_1flip_1__3I(self,idxs):
    strides = ([ 0l for _autovar_10 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_11 in xrange(self.shape.nd) ])

    start = 0l

    # src/fusion/Variable.mbi(539:9-543:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(540:9-543:9)
      strides[i] = ( self.shape._stride_I(i) )
      dims[i] = ( self.shape._dim_I(i) )
      # } @ src/fusion/Variable.mbi(540:9-543:9)
    # src/fusion/Variable.mbi(544:9-548:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/Variable.mbi(545:9-548:9)
      start = (start + (strides[idxs[i]] * (dims[i] - 1)))
      strides[dims[i]] = (- strides[dims[i]])
      # } @ src/fusion/Variable.mbi(545:9-548:9)
    return mosek.fusion.SliceVariable(self,self.shape,0l,strides)
  @staticmethod
  def _matchargs_diag_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(564:15-580:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag(int)")
  def _diag_I(self,index):
    if   ((self.shape.nd != 2) or (( self.shape._dim_I(0) ) != ( self.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
    d = ( self.shape._dim_I(0) )

    if   ((index >= d) or (index <= (- d))):
      raise mosek.fusion.IndexError("Diagonal index out of bounds")
    if   (index == 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(d),0l,([ (( self.shape._stride_I(0) ) + 1)]))
    elif (index > 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d - index)),long(index),([ (( self.shape._stride_I(0) ) + 1)]))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d + index)),(long((- index)) * ( self.shape._stride_I(0) )),([ (( self.shape._stride_I(0) ) + 1)]))
  @staticmethod
  def _matchargs_diag_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(584:15-583:55)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag()")
  def _diag_(self):
    return ( self._diag_I(0) )
  @staticmethod
  def _matchargs_antidiag_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(596:15-612:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag(int)")
  def _antidiag_I(self,index):
    if   ((self.shape.nd != 2) or (( self.shape._dim_I(0) ) != ( self.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
    d = ( self.shape._dim_I(0) )

    if   ((index >= d) or (index <= (- d))):
      raise mosek.fusion.IndexError("Diagonal index out of bounds")
    if   (index == 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(d),long((d - 1)),([ (( self.shape._stride_I(0) ) - 1l)]))
    elif (index > 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d - index)),long(((d - index) - 1)),([ (( self.shape._stride_I(0) ) - 1l)]))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d + index)),(((long((- index)) * ( self.shape._stride_I(0) )) + d) - 1l),([ (( self.shape._stride_I(0) ) - 1l)]))
  @staticmethod
  def _matchargs_antidiag_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(616:15-615:63)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag()")
  def _antidiag_(self):
    return ( self._antidiag_I(0) )
  @staticmethod
  def _matchargs_index_1flat_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Variable.mbi(619:15-623:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_flat(long)")
  def _index_1flat_L(self,i):
    if   ((i < 0) or (i >= self.shape._size)):
      raise mosek.fusion.IndexError("Index is out of bounds")
    return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(1),i,([ 1l]))
  @staticmethod
  def _matchargs_pick_1flat__3L(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/Variable.mbi(627:15-636:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick_flat([int64])")
  def _pick_1flat__3L(self,indexes):
    # src/fusion/Variable.mbi(628:9-633:14)
    for i in xrange(0,int(len(indexes))):
      if   ((indexes[i] < 0) or (indexes[i] >= self.shape._size)):
        raise mosek.fusion.IndexError("Index is out of bounds")
    vlist = ([ None for _autovar_12 in xrange(int(len(indexes))) ])

    # src/fusion/Variable.mbi(633:9-72)
    for i in xrange(0,int(len(indexes))):
      vlist[i] = ( self._index_1flat_L(indexes[i]) )
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
  @staticmethod
  def _matchargs_pick__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(640:15-649:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick([int32])")
  def _pick__3I(self,indexes):
    # src/fusion/Variable.mbi(641:9-646:14)
    for i in xrange(0,int(len(indexes))):
      if   ((indexes[i] < 0) or (indexes[i] >= self.shape._size)):
        raise mosek.fusion.IndexError("Index is out of bounds")
    vlist = ([ None for _autovar_13 in xrange(int(len(indexes))) ])

    # src/fusion/Variable.mbi(646:9-67)
    for i in xrange(0,int(len(indexes))):
      vlist[i] = ( self._index_I(indexes[i]) )
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
  @staticmethod
  def _matchargs_pick__3_3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(653:15-658:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick([[int32]])")
  def _pick__3_3I(self,indexes):
    vlist = ([ None for _autovar_14 in xrange(int(len(indexes))) ])

    # src/fusion/Variable.mbi(655:9-67)
    for i in xrange(0,int(len(indexes))):
      vlist[i] = ( self._index__3I(indexes[i]) )
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(667:15-674:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    if   (self.shape.nd == 1):
      return ( self._reshape_1_Omosek_fusion_Set_2(mosek.fusion.NDSet(([ 1,( self.shape._dim_I(0) )]))) )
    elif (self.shape.nd == 2):
      return ( self._index_1permute_1__3I(([ 1,0])) )
    else:
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
  @staticmethod
  def _matchargs_reshape_1_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Variable.mbi(682:18-686:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape_(mosek.fusion.Set)")
  def _reshape_1_Omosek_fusion_Set_2(self,s):
    strides = ([ 0l for _autovar_15 in xrange(s.nd) ])

    # src/fusion/Variable.mbi(684:9-55)
    for i in xrange(0,s.nd):
      strides[i] = ( s._stride_I(i) )
    return mosek.fusion.SliceVariable(self,s,0l,strides)
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Variable.mbi(722:15-727:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,mosek.fusion.Set)")
  def _reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(v,s):
    if   (s._size != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return ( v._reshape_1_Omosek_fusion_Set_2(s) )
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2II(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Variable.mbi(741:15-746:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,int,int)")
  def _reshape_Omosek_fusion_Variable_2II(v,d1,d2):
    if   ((d1 * d2) != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return mosek.fusion.SliceVariable(v,mosek.fusion.NDSet(d1,d2),0l,([ long(d2),1l]))
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(759:15-764:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,int)")
  def _reshape_Omosek_fusion_Variable_2I(v,d1):
    if   (d1 != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return mosek.fusion.SliceVariable(v,mosek.fusion.IntSet(d1),0l,([ 1l]))
  @staticmethod
  def _matchargs_compress_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(778:15-790:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("compress()")
  def _compress_(self):
    nd = ( self.shape._realnd_() )

    if   (nd == self.shape.nd):
      return self
    elif (nd == 1):
      return ( Variable._reshape_Omosek_fusion_Variable_2I (self,int(self.shape._size)) )
    else:
      d = ([ 0 for _autovar_16 in xrange(nd) ])

      # { @ src/fusion/Variable.mbi(787:11-111)
      j = 0

      # src/fusion/Variable.mbi(787:24-788:114)
      i = 0

      while (i < self.shape.nd):
        if   (( self.shape._dim_I(0) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
        i += 1
      # } @ src/fusion/Variable.mbi(787:11-111)
      return ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (self,mosek.fusion.NDSet(d)) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(810:18-816:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(819:18-823:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(834:18-841:7)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(844:18-848:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(855:18-864:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(int,[double])")
  def _level_1values_I_3F(self,offset,target):
    strides = ([ 0l for _autovar_17 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_18 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(861:9-65)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Variable.mbi(862:9-62)
    for i in xrange(0,self.shape.nd):
      dims[i] = ( self.shape._dim_I(i) )
    ( self._level_1values_L_3I_3LI_3F(0l,dims,strides,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(872:18-885:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(int,[double])")
  def _dual_1values_I_3F(self,offset,target):
    nsize = ([ 0 for _autovar_19 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_20 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(878:9-882:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(879:9-882:9)
      nsize[i] = ( self.shape._dim_I(i) )
      strides[i] = ( self.shape._stride_I(i) )
      # } @ src/fusion/Variable.mbi(879:9-882:9)
    ( self._dual_1values_L_3I_3LI_3F(0l,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_level_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(905:15-921:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int,int)")
  def _level_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx < 0)) or (firstidx > lastidx)) or (lastidx > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_21 in xrange(num) ])

    dims = ([ (lastidx - firstidx)])

    strides = ([ 1l])

    ( self._level_1values_L_3I_3LI_3F(long(firstidx),dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(940:15-971:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level([int32],[int32])")
  def _level__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Variable.mbi(950:9-957:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] > ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] - firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_22 in xrange(num) ])

    dims = ([ 0 for _autovar_23 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_24 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(962:9-63)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Variable.mbi(963:9-72)
    for i in xrange(0,self.shape.nd):
      dims[i] = (lastidx[i] - firstidx[i])
    start = 0l

    # src/fusion/Variable.mbi(966:9-967:58)
    for i in xrange(0,self.shape.nd):
      start = (start + (long(firstidx[i]) * strides[i]))
    ( self._level_1values_L_3I_3LI_3F(start,dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(988:15-997:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int)")
  def _level_I(self,index):
    if   (((self.shape.nd != 1) or (index < 0)) or (index >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid index.")
    idxs = ([ long(index)])

    res = ([ 0.0 for _autovar_25 in xrange(1) ])

    ( self._level_1values__3LI_3F(idxs,0,res) )
    return res[0]
  @staticmethod
  def _matchargs_dual_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(1016:15-1031:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual(int,int)")
  def _dual_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx > lastidx)) or (firstidx < 0)) or (lastidx >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_26 in xrange(num) ])

    ( self._dual_1values_L_3I_3LI_3F(long(firstidx),([ num]),([ 1l]),0,res) )
    return res
  @staticmethod
  def _matchargs_dual__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(1050:15-1080:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int32],[int32])")
  def _dual__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Variable.mbi(1059:9-1066:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] >= ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] * firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_27 in xrange(num) ])

    nsize = ([ 0 for _autovar_28 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_29 in xrange(self.shape.nd) ])

    firstelm = 0l

    # src/fusion/Variable.mbi(1071:9-1076:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(1072:9-1076:9)
      nsize[i] = (lastidx[i] - firstidx[i])
      strides[i] = ( self.shape._stride_I(i) )
      firstelm = (firstelm + (strides[i] * firstidx[i]))
      # } @ src/fusion/Variable.mbi(1072:9-1076:9)
    ( self._dual_1values_L_3I_3LI_3F(firstelm,nsize,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1091:15-1095:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("level()")
  def _level_(self):
    res = ([ 0.0 for _autovar_30 in xrange(self.shape._size) ])

    ( self._level_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1106:15-1117:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dual()")
  def _dual_(self):
    try:
      res = ([ 0.0 for _autovar_31 in xrange(self.shape._size) ])

      ( self._dual_1values_I_3F(0,res) )
      return res
    except mosek.fusion.Utils.FusionException, e:
      raise mosek.fusion.UnexpectedError(( e._toString_() ))
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1121:15-1123:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self.shape._size
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(1142:18-1147:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1154:15-1164:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( sb._a_S("Variable(dimensions=") )._a_I(( self.shape._dim_I(0) )) )
    # src/fusion/Variable.mbi(1158:9-1161:9)
    i = 1

    while (i < self.shape.nd):
      ( ( sb._a_S(",") )._a_I(( self.shape._dim_I(i) )) )
      i += 1
    ( ( ( sb._a_S("; totalsize=") )._a_L(self.shape._size) )._a_S(")") )
    return ( sb._toString_() )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   Variable._matchargs_slice_II(args):
      return Variable._slice_II(self,*args)
    elif Variable._matchargs_slice__3I_3I(args):
      return Variable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/SymmetricVariable.mbi(17:12-202:5)
class SymmetricVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable)")
  def __constructor_Omosek_fusion_Variable_2(self,v):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,v._model,v.shape)
    if   ((v.shape.nd == 2) and (( v.shape._dim_I(0) ) == ( v.shape._dim_I(1) ))):
      self.__x = v
    else:
      raise mosek.fusion.DimensionError("Expected a square matrix")
  def __init__(self,*args):
    #self.__x = None

    self.__constructor_Omosek_fusion_Variable_2(*args)
  @staticmethod
  def _matchargs_check_1symmetrix_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(21:16-35:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("check_symmetrix(mosek.fusion.Variable)")
  def __check_1symmetrix_Omosek_fusion_Variable_2(self,v):
    _autovar_32 = v
    if   isinstance(_autovar_32,mosek.fusion.PSDVariable):
      w = _autovar_32
      return True
    elif isinstance(_autovar_32,mosek.fusion.SymmetricVariable):
      w = _autovar_32
      return True
    else:
      w = _autovar_32
      return False
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(66:18-79:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    i = int((index / long(( self.shape._dim_I(1) ))))

    j = int((index - long((( self.shape._dim_I(1) ) * i))))

    if   (j <= i):
      ( self.__x._inst_LL_3I_3I_3I(index,offset,nindex,nsubi,nsubj) )
    else:
      ( self.__x._inst_LL_3I_3I_3I((long((j * ( self.shape._dim_I(1) ))) + i),offset,nindex,nsubi,nsubj) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(82:15-84:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    raise mosek.fusion.IndexError("Two dimensional index expected")
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(87:15-106:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    if   ((int(len(first)) != 2) or (int(len(last)) != 2)):
      raise mosek.fusion.IndexError("Two dimensional index expected")
    d = ( self.shape._dim_I(0) )

    if   (((first[0] == first[1]) and (last[0] == last[1])) and (first[0] == (d - last[0]))):
      return mosek.fusion.SymmetricVariable(( self.__x._slice__3I_3I(first,last) ))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet((last[0] - first[0]),(last[1] - first[0])),long(((first[0] * ( self.shape._dim_I(1) )) + first[1])),([ long(( self.shape._dim_I(1) )),1l]))
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(113:18-134:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    size = (nsize[0] * nsize[1])

    pidxs = ([ 0l for _autovar_33 in xrange(size) ])

    k = 0

    # src/fusion/SymmetricVariable.mbi(123:9-132:9)
    for i in xrange(0,nsize[0]):
      # { @ src/fusion/SymmetricVariable.mbi(124:9-132:9)
      # src/fusion/SymmetricVariable.mbi(125:11-131:11)
      for j in xrange(0,nsize[1]):
        # { @ src/fusion/SymmetricVariable.mbi(126:11-131:11)
        if   (i >= j):
          pidxs[k] = ((start + (strides[0] * i)) + (strides[1] * j))
        else:
          pidxs[k] = ((start + (strides[1] * i)) + (strides[0] * j))
        # } @ src/fusion/SymmetricVariable.mbi(126:11-131:11)
      # } @ src/fusion/SymmetricVariable.mbi(124:9-132:9)
    ( self.__x._level_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(137:18-153:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pidxs = ([ 0l for _autovar_34 in xrange(int(len(idxs))) ])

    # src/fusion/SymmetricVariable.mbi(142:9-151:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SymmetricVariable.mbi(143:9-151:9)
      ii = int((idxs[i] / ( self.shape._dim_I(1) )))

      ij = int((idxs[i] - (( self.shape._dim_I(1) ) * ii)))

      if   (ii >= ij):
        pidxs[i] = idxs[i]
      else:
        pidxs[i] = long(((ij * ( self.shape._dim_I(1) )) + ii))
      # } @ src/fusion/SymmetricVariable.mbi(143:9-151:9)
    ( self.__x._level_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(159:18-180:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    size = (nsize[0] * nsize[1])

    pidxs = ([ 0l for _autovar_35 in xrange(size) ])

    k = 0

    # src/fusion/SymmetricVariable.mbi(169:9-178:9)
    for i in xrange(0,nsize[0]):
      # { @ src/fusion/SymmetricVariable.mbi(170:9-178:9)
      # src/fusion/SymmetricVariable.mbi(171:11-177:11)
      for j in xrange(0,nsize[1]):
        # { @ src/fusion/SymmetricVariable.mbi(172:11-177:11)
        if   (i >= j):
          pidxs[k] = ((start + (strides[0] * i)) + (strides[1] * j))
        else:
          pidxs[k] = ((start + (strides[1] * i)) + (strides[0] * j))
        # } @ src/fusion/SymmetricVariable.mbi(172:11-177:11)
      # } @ src/fusion/SymmetricVariable.mbi(170:9-178:9)
    ( self.__x._dual_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(184:18-200:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pidxs = ([ 0l for _autovar_36 in xrange(int(len(idxs))) ])

    # src/fusion/SymmetricVariable.mbi(189:9-198:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SymmetricVariable.mbi(190:9-198:9)
      ii = int((idxs[i] / ( self.shape._dim_I(1) )))

      ij = int((idxs[i] - (( self.shape._dim_I(1) ) * ii)))

      if   (ii >= ij):
        pidxs[i] = idxs[i]
      else:
        pidxs[i] = long(((ij * ( self.shape._dim_I(1) )) + ii))
      # } @ src/fusion/SymmetricVariable.mbi(190:9-198:9)
    ( self.__x._dual_1values__3LI_3F(pidxs,offset,target) )
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   SymmetricVariable._matchargs_slice_II(args):
      return SymmetricVariable._slice_II(self,*args)
    elif SymmetricVariable._matchargs_slice__3I_3I(args):
      return SymmetricVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/SliceVariable.mbi(18:12-331:5)
class SliceVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable,mosek.fusion.Set,long,[int64])")
  def __constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,origin_._model,shape_)
    self.__origin = origin_
    self.__first = first_
    self.__strides = strides_
  def __init__(self,*args):
    #self.__origin = None

    #self.__first = None

    #self.__strides = None

    self.__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(62:18-78:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_37 in xrange(int(len(idxs))) ])

    # src/fusion/SliceVariable.mbi(68:9-75:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceVariable.mbi(69:9-75:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceVariable.mbi(72:11-73:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self.__strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceVariable.mbi(69:9-75:9)
    ( self.__origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(81:18-169:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_38 in xrange(self.shape.nd) ])

      # src/fusion/SliceVariable.mbi(93:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self.__origin._level_1values_L_3I_3LI_3F(self.__first,tmp_nsize,self.__strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceVariable.mbi(107:11-108:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self.__first

        # { @ src/fusion/SliceVariable.mbi(116:13-124:13)
        tmp = start

        # src/fusion/SliceVariable.mbi(118:15-123:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceVariable.mbi(119:15-123:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceVariable.mbi(119:15-123:15)
        # } @ src/fusion/SliceVariable.mbi(116:13-124:13)
        ( self.__origin._level_1values_L_3I_3LI_3F(slice_start,nsize,self.__strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceVariable.mbi(130:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_39 in xrange(totalsize) ])

        # { @ src/fusion/SliceVariable.mbi(133:13-164:13)
        ii = ([ 0 for _autovar_40 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_41 in xrange(int(len(nsize))) ])

        # src/fusion/SliceVariable.mbi(135:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceVariable.mbi(136:15-163:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceVariable.mbi(137:15-163:15)
          # { @ src/fusion/SliceVariable.mbi(140:17-150:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceVariable.mbi(143:19-148:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceVariable.mbi(144:19-148:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self.__strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceVariable.mbi(144:19-148:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceVariable.mbi(140:17-150:17)
          # { @ src/fusion/SliceVariable.mbi(154:17-162:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceVariable.mbi(156:20-160:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceVariable.mbi(161:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceVariable.mbi(154:17-162:17)
          # } @ src/fusion/SliceVariable.mbi(137:15-163:15)
        # } @ src/fusion/SliceVariable.mbi(133:13-164:13)
        ( self.__origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(175:18-191:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_42 in xrange(int(len(idxs))) ])

    # src/fusion/SliceVariable.mbi(181:9-188:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceVariable.mbi(182:9-188:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceVariable.mbi(185:11-186:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self.__strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceVariable.mbi(182:9-188:9)
    ( self.__origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(194:18-282:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_43 in xrange(self.shape.nd) ])

      # src/fusion/SliceVariable.mbi(206:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self.__origin._dual_1values_L_3I_3LI_3F(self.__first,tmp_nsize,self.__strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceVariable.mbi(220:11-221:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self.__first

        # { @ src/fusion/SliceVariable.mbi(229:13-237:13)
        tmp = start

        # src/fusion/SliceVariable.mbi(231:15-236:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceVariable.mbi(232:15-236:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceVariable.mbi(232:15-236:15)
        # } @ src/fusion/SliceVariable.mbi(229:13-237:13)
        ( self.__origin._dual_1values_L_3I_3LI_3F(slice_start,nsize,self.__strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceVariable.mbi(243:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_44 in xrange(totalsize) ])

        # { @ src/fusion/SliceVariable.mbi(246:13-277:13)
        ii = ([ 0 for _autovar_45 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_46 in xrange(int(len(nsize))) ])

        # src/fusion/SliceVariable.mbi(248:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceVariable.mbi(249:15-276:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceVariable.mbi(250:15-276:15)
          # { @ src/fusion/SliceVariable.mbi(253:17-263:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceVariable.mbi(256:19-261:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceVariable.mbi(257:19-261:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self.__strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceVariable.mbi(257:19-261:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceVariable.mbi(253:17-263:17)
          # { @ src/fusion/SliceVariable.mbi(267:17-275:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceVariable.mbi(269:20-273:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceVariable.mbi(274:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceVariable.mbi(267:17-275:17)
          # } @ src/fusion/SliceVariable.mbi(250:15-276:15)
        # } @ src/fusion/SliceVariable.mbi(246:13-277:13)
        ( self.__origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(290:15-292:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    return mosek.fusion.SliceVariable(self.__origin,( self.shape._slice_II(firstidx,lastidx) ),(self.__first + long(firstidx)),self.__strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(295:15-302:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,firstidx,lastidx):
    shp = ( self.shape._slice__3I_3I(firstidx,lastidx) )

    newfirst = self.__first

    # src/fusion/SliceVariable.mbi(299:9-300:55)
    i = 0

    while (i < int(len(firstidx))):
      newfirst = (newfirst + (self.__strides[i] * firstidx[i]))
      i += 1
    return mosek.fusion.SliceVariable(self.__origin,shp,newfirst,self.__strides)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(307:18-328:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    idx = self.__first

    rest = index

    # src/fusion/SliceVariable.mbi(319:9-325:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/SliceVariable.mbi(320:9-325:9)
      k = (rest / ( self.shape._stride_I(i) ))

      rest = (rest - (k * ( self.shape._stride_I(i) )))
      idx = (idx + (self.__strides[i] * k))
      # } @ src/fusion/SliceVariable.mbi(320:9-325:9)
    ( self.__origin._inst_LL_3I_3I_3I(idx,offset,nindex,nsubi,nsubj) )
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   SliceVariable._matchargs_slice_II(args):
      return SliceVariable._slice_II(self,*args)
    elif SliceVariable._matchargs_slice__3I_3I(args):
      return SliceVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/BoundInterfaceVariable.mbi(23:12-73:5)
class BoundInterfaceVariable(SliceVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangedVariable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[4],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RangedVariable,mosek.fusion.Set,long,[int64],bool)")
  def __constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(self,origin_,shape_,first_,strides_,islower_):
    mosek.fusion.SliceVariable._SliceVariable__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_)
    self.__originvar = origin_
    self.__islower = islower_
  def __init__(self,*args):
    #self.__islower = None

    #self.__originvar = None

    self.__constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(42:18-50:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    if   self.__islower:
      ( self.__originvar._dual_1l__3LI_3F(idxs,offset,target) )
    else:
      ( self.__originvar._dual_1u__3LI_3F(idxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(52:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    if   self.__islower:
      ( self.__originvar._dual_1l_L_3I_3LI_3F(start,nsize,strides,offset,target) )
    else:
      ( self.__originvar._dual_1u_L_3I_3LI_3F(start,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(67:18-72:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[int64])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.BoundInterfaceVariable(self.__originvar,shape_,first_,strides_,self.__islower)
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   SliceVariable._matchargs_slice_II(args):
      return SliceVariable._slice_II(self,*args)
    elif SliceVariable._matchargs_slice__3I_3I(args):
      return SliceVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int32])"),(2,"\tindex(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/CompoundVariable.mbi(20:12-482:5)
class CompoundVariable(Variable):
  @staticmethod
  def _matchargs_constructor__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([mosek.fusion.Variable],int)")
  def __constructor__3Omosek_fusion_Variable_2I(self,v,dim):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( CompoundVariable.__model_1from_1var__3Omosek_fusion_Variable_2 (v) ),( CompoundVariable.__compute_1shape__3Omosek_fusion_Variable_2I (v,dim) ))
    numnz = 0

    dimsize = 0

    # src/fusion/CompoundVariable.mbi(89:9-101:9)
    i = 0

    while (i < int(len(v))):
      if   (v[i].shape._size == 1):
        numnz += 1
        dimsize += 1
      elif (v[i].shape._size > 1):
        numnz += 1
        dimsize = (dimsize + ( v[i].shape._dim_I(dim) ))
      i += 1
    self.__vars = ([ None for _autovar_47 in xrange(numnz) ])
    self.__varsb = ([ 0 for _autovar_48 in xrange((numnz + 1)) ])
    self.__varsb[0] = 0
    self.__stackdim = dim
    # { @ src/fusion/CompoundVariable.mbi(108:9-119:9)
    j = 0

    # src/fusion/CompoundVariable.mbi(110:11-120:12)
    i = 0

    while (i < int(len(v))):
      if   (v[i].shape._size > 0):
        self.__vars[j] = v[i]
        j += 1
        if   (v[i].shape._size == 1):
          self.__varsb[(i + 1)] = (self.__varsb[i] + 1)
        else:
          self.__varsb[(i + 1)] = (self.__varsb[i] + ( v[i].shape._dim_I(dim) ))
      i += 1
    # } @ src/fusion/CompoundVariable.mbi(108:9-119:9)
  def __init__(self,*args):
    #self.__vars = None

    #self.__varsb = None

    #self.__stackdim = None

    self.__constructor__3Omosek_fusion_Variable_2I(*args)
  @staticmethod
  def _matchargs_model_1from_1var__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(29:16-31:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from_var([mosek.fusion.Variable])")
  def __model_1from_1var__3Omosek_fusion_Variable_2(v):
    return v[0]._model
  @staticmethod
  def _matchargs_compute_1shape__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(53:16-80:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compute_shape([mosek.fusion.Variable],int)")
  def __compute_1shape__3Omosek_fusion_Variable_2I(v,dim):
    s = v[0].shape

    sdsize = 0

    # src/fusion/CompoundVariable.mbi(57:9-70:9)
    for i in xrange(0,int(len(v))):
      # { @ src/fusion/CompoundVariable.mbi(58:9-70:9)
      thisv = v[i]

      if   (thisv.shape._size > 0):
        if   (thisv.shape.nd != s.nd):
          raise mosek.fusion.DimensionError("Mismatching variable shape")
        # src/fusion/CompoundVariable.mbi(65:13-69:21)
        for j in xrange(0,s.nd):
          if   ((j != dim) and (( s._dim_I(j) ) != ( thisv.shape._dim_I(j) ))):
            raise mosek.fusion.DimensionError("Mismatching variable shape")
        sdsize = (sdsize + ( thisv.shape._dim_I(dim) ))
      # } @ src/fusion/CompoundVariable.mbi(58:9-70:9)
    if   (s.nd == 1):
      return mosek.fusion.IntSet(sdsize)
    else:
      d = ([ 0 for _autovar_49 in xrange(s.nd) ])

      # src/fusion/CompoundVariable.mbi(76:11-57)
      i = 0

      while (i < s.nd):
        d[i] = ( s._dim_I(i) )
        i += 1
      d[dim] = sdsize
      return mosek.fusion.NDSet(d)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(124:15-170:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.shape.nd != 1):
      raise mosek.fusion.SliceError("Slice has wrong number of dimensions")
    elif (first > last):
      raise mosek.fusion.SliceError("Invalid slice range")
    elif ((first < 0) or (last > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Slice index is out of bounds")
    if   (first == last):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(0),0l,([ 0l for _autovar_50 in xrange(1) ]))




    # { @ src/fusion/CompoundVariable.mbi(141:9-149:9)
    i = 0

    # src/fusion/CompoundVariable.mbi(143:11-42)
    while (first >= self.__varsb[(i + 1)]):
      i += 1
    idxb = i
    offsetb = (first - self.__varsb[i])
    # src/fusion/CompoundVariable.mbi(146:11-40)
    while (last > self.__varsb[(i + 1)]):
      i += 1
    idxe = i
    offsete = (last - self.__varsb[i])
    # } @ src/fusion/CompoundVariable.mbi(141:9-149:9)
    if   (idxb == idxe):
      return ( self.__vars[idxb]._slice_II(offsetb,offsete) )
    else:
      r = ([ None for _autovar_51 in xrange(((idxb - idxe) + 1)) ])

      if   (offsetb > 0):
        r[0] = ( self.__vars[idxb]._slice_II(offsetb,( self.__vars[idxb].shape._dim_I(0) )) )
      else:
        r[0] = self.__vars[idxb]
      if   (offsete < ( self.__vars[idxe].shape._dim_I(0) )):
        r[(int(len(r)) - 1)] = ( self.__vars[idxe]._slice_II(0,offsete) )
      else:
        r[(int(len(r)) - 1)] = self.__vars[idxe]
      # src/fusion/CompoundVariable.mbi(165:11-166:32)
      i = 1

      while (i < (int(len(r)) - 1)):
        r[i] = self.__vars[(idxb + i)]
        i += 1
      return mosek.fusion.CompoundVariable(r,0)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(173:15-265:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    elif (int(len(first)) != self.shape.nd):
      raise mosek.fusion.SliceError("Slice has wrong number of dimensions")
    else:
      # src/fusion/CompoundVariable.mbi(182:11-186:12)
      for i in xrange(0,int(len(first))):
        if   (((first[i] < 0) or (first[i] > last[i])) or (last[i] > ( self.shape._dim_I(i) ))):
          raise mosek.fusion.SliceError("Slice index is out of bounds")
    isnull = False

    # { @ src/fusion/CompoundVariable.mbi(189:9-193:9)
    # src/fusion/CompoundVariable.mbi(190:11-194:12)
    i = 0

    while (i < int(len(first))):
      if   (first[i] >= last[i]):
        isnull = True
      i += 1
    # } @ src/fusion/CompoundVariable.mbi(189:9-193:9)
    if   isnull:
      nd = int(len(first))

      resdims = ([ 0 for _autovar_52 in xrange(nd) ])

      # src/fusion/CompoundVariable.mbi(198:11-202:29)
      i = 0

      while (i < nd):
        if   (first[i] < last[i]):
          resdims[i] = (last[i] - first[i])
        else:
          resdims[i] = 0
        i += 1
      return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet(resdims),0l,([ 0l for _autovar_53 in xrange(nd) ]))
    elif (int(len(first)) == 1):
      return ( self._slice_II(first[0],last[0]) )
    else:
      nd = self.shape.nd

      subslicefirst = ([ 0 for _autovar_54 in xrange(nd) ])

      subslicelast = ([ 0 for _autovar_55 in xrange(nd) ])





      # { @ src/fusion/CompoundVariable.mbi(215:11-223:11)
      i = 0

      # src/fusion/CompoundVariable.mbi(217:13-54)
      while (first[self.__stackdim] >= self.__varsb[(i + 1)]):
        i += 1
      idxb = i
      offsetb = (first[self.__stackdim] - int(self.__varsb[i]))
      # src/fusion/CompoundVariable.mbi(220:13-59)
      while (last[self.__stackdim] > int(self.__varsb[(i + 1)])):
        i += 1
      idxe = i
      offsete = (last[self.__stackdim] - int(self.__varsb[i]))
      # } @ src/fusion/CompoundVariable.mbi(215:11-223:11)
      # src/fusion/CompoundVariable.mbi(225:11-229:11)
      i = 0

      while (i < nd):
        subslicefirst[i] = first[i]
        subslicelast[i] = last[i]
        i += 1
      if   (idxb == idxe):
        subslicefirst[self.__stackdim] = offsetb
        subslicelast[self.__stackdim] = offsete
        return ( self.__vars[idxb]._slice__3I_3I(subslicefirst,subslicelast) )
      else:
        r = ([ None for _autovar_56 in xrange(((idxe - idxb) + 1)) ])

        subslicefirst[self.__stackdim] = offsetb
        subslicelast[self.__stackdim] = ( self.__vars[idxb].shape._dim_I(self.__stackdim) )
        r[0] = ( self.__vars[idxb]._slice__3I_3I(subslicefirst,subslicelast) )
        subslicefirst[self.__stackdim] = 0
        subslicelast[self.__stackdim] = offsete
        r[(int(len(r)) - 1)] = ( self.__vars[idxe]._slice__3I_3I(subslicefirst,subslicelast) )
        # src/fusion/CompoundVariable.mbi(254:13-260:13)
        i = 1

        while (i < (int(len(r)) - 1)):
          subslicefirst[self.__stackdim] = 0
          subslicelast[self.__stackdim] = ( self.__vars[(i + idxb)].shape._dim_I(self.__stackdim) )
          r[i] = ( self.__vars[(i + idxb)]._slice__3I_3I(subslicefirst,subslicelast) )
          i += 1
        return mosek.fusion.CompoundVariable(r,self.__stackdim)
  @staticmethod
  def _matchargs_asExpr_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(268:15-275:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("asExpr()")
  def _asExpr_(self):
    ptrb = ( Utils.Tools._range_LL (0l,(self.shape._size + 1)) )

    sub = ( Utils.Tools._range_LL (0l,self.shape._size) )

    cof = ( Utils.Tools._ones_I (int(self.shape._size)) )

    return mosek.fusion.Expr(ptrb,self,sub,cof,None,self.shape,None,1)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(280:18-306:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_57 in xrange(1) ])

    index = ([ 0 for _autovar_58 in xrange(self.shape.nd) ])

    # src/fusion/CompoundVariable.mbi(287:9-305:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundVariable.mbi(288:9-305:9)
      # { @ src/fusion/CompoundVariable.mbi(289:11-296:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundVariable.mbi(291:13-295:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(292:13-295:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundVariable.mbi(292:13-295:13)
      # } @ src/fusion/CompoundVariable.mbi(289:11-296:11)
      # { @ src/fusion/CompoundVariable.mbi(298:11-304:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(300:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(298:11-304:11)
      # } @ src/fusion/CompoundVariable.mbi(288:9-305:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(309:18-368:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundVariable.mbi(317:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_59 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundVariable.mbi(326:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_60 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_61 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_62 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundVariable.mbi(329:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_63 in xrange(1) ])

    # src/fusion/CompoundVariable.mbi(333:9-367:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundVariable.mbi(334:9-367:9)
      # { @ src/fusion/CompoundVariable.mbi(336:11-343:11)
      tmpval = st[0]

      # src/fusion/CompoundVariable.mbi(338:13-342:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(339:13-342:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundVariable.mbi(339:13-342:13)
      # } @ src/fusion/CompoundVariable.mbi(336:11-343:11)
      # { @ src/fusion/CompoundVariable.mbi(346:11-352:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(348:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(346:11-352:11)
      # { @ src/fusion/CompoundVariable.mbi(355:11-366:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundVariable.mbi(359:13-362:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundVariable.mbi(364:13-365:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundVariable.mbi(355:11-366:11)
      # } @ src/fusion/CompoundVariable.mbi(334:9-367:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(374:18-400:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_64 in xrange(1) ])

    index = ([ 0 for _autovar_65 in xrange(self.shape.nd) ])

    # src/fusion/CompoundVariable.mbi(381:9-399:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundVariable.mbi(382:9-399:9)
      # { @ src/fusion/CompoundVariable.mbi(383:11-390:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundVariable.mbi(385:13-389:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(386:13-389:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundVariable.mbi(386:13-389:13)
      # } @ src/fusion/CompoundVariable.mbi(383:11-390:11)
      # { @ src/fusion/CompoundVariable.mbi(392:11-398:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(394:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(392:11-398:11)
      # } @ src/fusion/CompoundVariable.mbi(382:9-399:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(403:18-462:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundVariable.mbi(411:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_66 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundVariable.mbi(420:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_67 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_68 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_69 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundVariable.mbi(423:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_70 in xrange(1) ])

    # src/fusion/CompoundVariable.mbi(427:9-461:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundVariable.mbi(428:9-461:9)
      # { @ src/fusion/CompoundVariable.mbi(430:11-437:11)
      tmpval = st[0]

      # src/fusion/CompoundVariable.mbi(432:13-436:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(433:13-436:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundVariable.mbi(433:13-436:13)
      # } @ src/fusion/CompoundVariable.mbi(430:11-437:11)
      # { @ src/fusion/CompoundVariable.mbi(440:11-446:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(442:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(440:11-446:11)
      # { @ src/fusion/CompoundVariable.mbi(449:11-460:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundVariable.mbi(453:13-456:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundVariable.mbi(458:13-459:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundVariable.mbi(449:11-460:11)
      # } @ src/fusion/CompoundVariable.mbi(428:9-461:9)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(466:18-480:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds.")
    key = ( self.shape._idxtokey_L(index) )

    i = 0

    # src/fusion/CompoundVariable.mbi(476:20-59)
    while (key[self.__stackdim] >= self.__varsb[(i + 1)]):
      i += 1
    key[self.__stackdim] = (key[self.__stackdim] - self.__varsb[i])
    ( self.__vars[i]._inst_LL_3I_3I_3I(( self.__vars[i].shape._linearidx__3I(key) ),offset,nindex,nsubi,nsubj) )
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tindex(int,int)"),(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   CompoundVariable._matchargs_slice_II(args):
      return CompoundVariable._slice_II(self,*args)
    elif CompoundVariable._matchargs_slice__3I_3I(args):
      return CompoundVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   CompoundVariable._matchargs_asExpr_(args):
      return CompoundVariable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/ModelVariable.mbi(12:12-90:5)
class ModelVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if not isinstance(args[3],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_)
    self._name = name_
    self._varid = varid_
  def __init__(self,*args):
    #self._protected_name = None

    #self._protected_varid = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(*args)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/ModelVariable.mbi(40:15-49:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.shape.nd != 1):
      raise mosek.fusion.DimensionError("Wrong size of slice")
    strides = ([ 1l])

    return mosek.fusion.SliceVariable(self,( self.shape._slice_II(first,last) ),long(first),strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ModelVariable.mbi(52:15-70:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    shp = ( self.shape._slice__3I_3I(first,last) )

    strides = ([ 0l for _autovar_71 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/ModelVariable.mbi(59:9-60:51)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i = (i - 1)
    firstidx = 0l

    # src/fusion/ModelVariable.mbi(63:9-64:56)
    i = 0

    while (i < int(len(strides))):
      firstidx = (firstidx + (strides[i] * first[i]))
      i += 1
    return mosek.fusion.SliceVariable(self,shp,firstidx,strides)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/ModelVariable.mbi(73:15-88:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("Variable(") )
    if   (self._name != None):
      ( ( ( sb._a_S("name='") )._a_S(self._name) )._a_S("'; ") )
    ( ( sb._a_S("dimensions=") )._a_I(( self.shape._dim_I(0) )) )
    # src/fusion/ModelVariable.mbi(81:9-84:9)
    i = 1

    while (i < self.shape.nd):
      ( ( sb._a_S(",") )._a_I(( self.shape._dim_I(i) )) )
      i += 1
    ( ( sb._a_S("; size=") )._a_L(self.shape._size) )
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/SemidefiniteVariable.mbi(9:12-178:5)
class PSDVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SIIIL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,int,int,int,long)")
  def __constructor_Omosek_fusion_Model_2SIIIL(self,model_,name_,conesize_,coneidx_,num_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,mosek.fusion.NDSet(conesize_,conesize_),varid_)
    self.__conesize = conesize_
    self.__coneidx = coneidx_
    self.__numcones = num_
  def __init__(self,*args):
    #self.__conesize = None

    #self.__coneidx = None

    #self.__numcones = None

    self.__constructor_Omosek_fusion_Model_2SIIIL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(39:18-58:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(46:9-57:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteVariable.mbi(47:9-57:9)
      k = (idxs[p] / blocksize)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(47:9-57:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(62:18-92:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(75:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteVariable.mbi(76:9-91:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteVariable.mbi(77:9-91:9)
      # { @ src/fusion/SemidefiniteVariable.mbi(78:11-89:11)
      k = (( cnt._get_() ) / blocksize)

      lidx = (( cnt._get_() ) - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(78:11-89:11)
      ( cnt._inc_() )
      # } @ src/fusion/SemidefiniteVariable.mbi(77:9-91:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(96:18-115:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    bars = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(103:9-114:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteVariable.mbi(104:9-114:9)
      k = (idxs[p] / blocksize)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = bars[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = bars[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(104:9-114:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(119:18-150:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    bars = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(132:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteVariable.mbi(133:9-149:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteVariable.mbi(134:9-149:9)
      # { @ src/fusion/SemidefiniteVariable.mbi(135:11-146:11)
      k = (( cnt._get_() ) / blocksize)

      lidx = (( cnt._get_() ) - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = bars[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = bars[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(135:11-146:11)
      ( cnt._inc_() )
      # } @ src/fusion/SemidefiniteVariable.mbi(134:9-149:9)
  @staticmethod
  def _matchargs_instantiate_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(153:18-156:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("instantiate(long)")
  def _instantiate_L(self,index):
    raise mosek.fusion.UnimplementedError("Instantiate for PSD variables")
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(159:18-177:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    coneoffset = int((index / (self.__conesize * self.__conesize)))

    matrixoffset = (index - ((self.__conesize * self.__conesize) * coneoffset))

    nindex[offset] = (- ((1 + self.__coneidx) + coneoffset))
    i = (int(matrixoffset) / ( self.shape._dim_I(1) ))

    j = (int(matrixoffset) - int((i * ( self.shape._dim_I(1) ))))

    if   (i >= j):
      nsubi[offset] = i
      nsubj[offset] = j
    else:
      nsubi[offset] = j
      nsubj[offset] = i
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/LinearVariable.mbi(22:12-281:5)
class LinearVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int32],long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__nativeidxs = nativeidxs_
    if   (nativeidxs_ == None):
      self.__idxmap = mosek.fusion.Utils.IntMap()
    else:
      self.__idxmap = None
    self.__dom = dom_
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__nativeidxs = None

    #self.__dom = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(52:18-78:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(59:11-60:55)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(64:11-76:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(81:18-123:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearVariable.mbi(93:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(96:11-100:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearVariable.mbi(97:11-100:11)
        target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(97:11-100:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(105:11-121:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/LinearVariable.mbi(106:11-121:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(106:11-121:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(128:18-161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(136:11-140:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/LinearVariable.mbi(137:11-140:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = (slx[ni] - sux[ni])
        # } @ src/fusion/LinearVariable.mbi(137:11-140:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(144:11-159:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(164:18-213:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearVariable.mbi(178:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(181:11-187:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearVariable.mbi(182:11-187:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = (slx[ni] - sux[ni])
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(182:11-187:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(192:11-211:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/LinearVariable.mbi(193:11-211:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(193:11-211:11)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(223:18-252:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    if   (self.__nativeidxs != None):
      nindex[offset] = self.__nativeidxs[index]
    else:
      if   (not ( self.__idxmap._hasItem_L(index) )):
        tmpname = None

        if   (self._name != None):
          tmpname = ( ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index) )) )._a_S("]") )._toString_() )
        nidx = ( self._model._alloc_1linearvar_SOmosek_fusion_RelationKey_2F(tmpname,self.__dom._key,( self.__dom._get_1rhs_1item_L(index) )) )

        ( self.__idxmap._setItem_LI(index,nidx) )
        nindex[offset] = nidx
      else:
        nindex[offset] = ( self.__idxmap._getItem_L(index) )
  @staticmethod
  def _matchargs_instantiate_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(256:18-280:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("instantiate(long)")
  def _instantiate_L(self,index):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    if   (self.__nativeidxs != None):
      return self.__nativeidxs[index]
    else:
      if   (not ( self.__idxmap._hasItem_L(index) )):
        tmpname = None

        if   (self._name != None):
          tmpname = ( ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index) )) )._a_S("]") )._toString_() )
        nidx = ( self._model._alloc_1linearvar_SOmosek_fusion_RelationKey_2F(tmpname,self.__dom._key,( self.__dom._get_1rhs_1item_L(index) )) )

        ( self.__idxmap._setItem_LI(index,nidx) )
        return nidx
      else:
        return ( self.__idxmap._getItem_L(index) )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/IntegerVariable.mbi(14:12-71:5)
class IntegerLinearVariable(LinearVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int32],long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_):
    mosek.fusion.LinearVariable._LinearVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(33:18-39:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(43:18-51:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(54:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    ( LinearVariable._inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj) )
    ( self._model._task_1var_1putintlist__3I(([ nindex[offset]])) )
  @staticmethod
  def _matchargs_instantiate_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(65:18-70:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("instantiate(long)")
  def _instantiate_L(self,index):
    idx = ( LinearVariable._instantiate_L(self,index) )

    ( self._model._task_1var_1putintlist__3I(([ idx])) )
    return idx
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/RangedVariable.mbi(19:12-449:5)
class RangedVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int32],long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__nativeidxs = nativeidxs_
    if   (nativeidxs_ == None):
      self.__idxmap = mosek.fusion.Utils.IntMap()
    else:
      self.__idxmap = None
    self.__dom = dom_
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__dom = None

    #self.__nativeidxs = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(54:18-80:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(61:11-62:55)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(66:11-78:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(82:18-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(94:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(97:11-101:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(98:11-101:11)
        target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(98:11-101:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(106:11-122:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(107:11-122:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(107:11-122:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(127:18-160:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(135:11-139:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(136:11-139:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = (slx[ni] - sux[ni])
        # } @ src/fusion/RangedVariable.mbi(136:11-139:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(143:11-158:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(162:18-210:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(175:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(178:11-184:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(179:11-184:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = (slx[ni] - sux[ni])
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(179:11-184:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(189:11-208:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(190:11-208:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(190:11-208:11)
  @staticmethod
  def _matchargs_dual_1l__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(215:18-247:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l([int64],int,[double])")
  def _dual_1l__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(222:11-226:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(223:11-226:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = slx[ni]
        # } @ src/fusion/RangedVariable.mbi(223:11-226:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(230:11-245:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = slx[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1l_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(249:18-295:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l(long,[int32],[int64],int,[double])")
  def _dual_1l_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(261:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(264:11-269:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(265:11-269:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = slx[ni]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(265:11-269:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(274:11-293:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(275:11-293:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = slx[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(275:11-293:11)
  @staticmethod
  def _matchargs_dual_1u__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(300:18-332:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u([int64],int,[double])")
  def _dual_1u__3LI_3F(self,idxs,offset,target):
    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(307:11-311:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(308:11-311:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = sux[ni]
        # } @ src/fusion/RangedVariable.mbi(308:11-311:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(315:11-330:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = sux[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1u_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(335:18-382:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u(long,[int32],[int64],int,[double])")
  def _dual_1u_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(347:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(350:11-356:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(351:11-356:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = sux[ni]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(351:11-356:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(361:11-380:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(362:11-380:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = sux[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(362:11-380:11)
  @staticmethod
  def _matchargs_lowerBoundVar_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedVariable.mbi(392:15-401:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lowerBoundVar()")
  def _lowerBoundVar_(self):
    strides = ([ 0l for _autovar_72 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedVariable.mbi(395:9-398:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * long(( self.shape._dim_I(i) )))
      i -= 1
    return mosek.fusion.BoundInterfaceVariable(self,self.shape,0l,strides,True)
  @staticmethod
  def _matchargs_upperBoundVar_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedVariable.mbi(407:15-417:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("upperBoundVar()")
  def _upperBoundVar_(self):
    strides = ([ 0l for _autovar_73 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedVariable.mbi(411:9-414:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * long(( self.shape._dim_I(i) )))
      i -= 1
    return mosek.fusion.BoundInterfaceVariable(self,self.shape,0l,strides,False)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(421:18-447:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    if   (self.__nativeidxs != None):
      nindex[offset] = self.__nativeidxs[index]
    else:
      if   (not ( self.__idxmap._hasItem_L(index) )):
        s = ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index) )) )._a_S("]") )

        nidx = ( self._model._alloc_1rangedvar_SFF(( s._toString_() ),( self.__dom._get_1lb_1item_L(index) ),( self.__dom._get_1ub_1item_L(index) )) )

        ( self.__idxmap._setItem_LI(index,nidx) )
        nindex[offset] = nidx
      else:
        nindex[offset] = ( self.__idxmap._getItem_L(index) )
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def lowerBoundVar(self,*args):
    if   RangedVariable._matchargs_lowerBoundVar_(args):
      return RangedVariable._lowerBoundVar_(self,*args)
    else:
      argtypestr = "lowerBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundVar()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def upperBoundVar(self,*args):
    if   RangedVariable._matchargs_upperBoundVar_(args):
      return RangedVariable._upperBoundVar_(self,*args)
    else:
      argtypestr = "upperBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundVar()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tindex(int,int)"),(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/IntegerVariable.mbi(132:12-182:5)
class IntegerRangedVariable(RangedVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int32],long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_):
    mosek.fusion.RangedVariable._RangedVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(151:18-157:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(161:18-169:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(172:18-180:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    ( RangedVariable._inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj) )
    ( self._model._task_1var_1putintlist__3I(([ nindex[offset]])) )
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def lowerBoundVar(self,*args):
    if   RangedVariable._matchargs_lowerBoundVar_(args):
      return RangedVariable._lowerBoundVar_(self,*args)
    else:
      argtypestr = "lowerBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundVar()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def upperBoundVar(self,*args):
    if   RangedVariable._matchargs_upperBoundVar_(args):
      return RangedVariable._upperBoundVar_(self,*args)
    else:
      argtypestr = "upperBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundVar()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/ConicVariable.mbi(19:12-138:5)
class ConicVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(args):
    if len(args) != 8:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int32],int,int,int,long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__conesize = conesize_
    self.__coneidx = firstcone_
    self.__numcone = numcone_
    self.__nativeidxs = nativeidxs_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__conesize = None

    #self.__numcone = None

    #self.__nativeidxs = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(*args)
  @staticmethod
  def _matchargs_get_1variable_1index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(47:18-52:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_variable_index(int)")
  def _get_1variable_1index_I(self,idx):
    if   (idx >= int(len(self.__nativeidxs))):
      raise mosek.fusion.IndexError("Variable index out of range")
    else:
      return self.__nativeidxs[idx]
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(55:18-63:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(61:9-62:53)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(66:18-84:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(78:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicVariable.mbi(79:9-83:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicVariable.mbi(80:9-83:9)
      target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
      ( cnt._inc_() )
      # } @ src/fusion/ConicVariable.mbi(80:9-83:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(88:18-96:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(94:9-95:54)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = snx[self.__nativeidxs[idxs[i]]]
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(99:18-117:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    # src/fusion/ConicVariable.mbi(111:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicVariable.mbi(112:9-116:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicVariable.mbi(113:9-116:9)
      target[(i + offset)] = snx[self.__nativeidxs[( cnt._get_() )]]
      ( cnt._inc_() )
      # } @ src/fusion/ConicVariable.mbi(113:9-116:9)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(120:18-129:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int32],[int32],[int32])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0) or (index >= long(len(self.__nativeidxs)))):
      raise mosek.fusion.IndexError("Index out of bounds")
    nindex[offset] = self.__nativeidxs[index]
  @staticmethod
  def _matchargs_instantiate_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(132:18-137:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("instantiate(long)")
  def _instantiate_L(self,index):
    if   ((index < 0) or (index >= long(len(self.__nativeidxs)))):
      raise mosek.fusion.IndexError("Index out of bounds")
    return self.__nativeidxs[index]
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tindex(int,int)"),(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/IntegerVariable.mbi(81:12-122:5)
class IntegerConicVariable(ConicVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(args):
    if len(args) != 8:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int32],int,int,int,long)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    mosek.fusion.ConicVariable._ConicVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(103:18-109:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(113:18-121:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(2,"\tindex(int,int)"),(1,"\tindex([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int32]])"),(1,"\tpick([int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([int64])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Constraint.mbi(23:12-680:5)
class Constraint:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_):
    self._model = model_
    self.shape = shape_
    self._shape_p = shape_
  def __init__(self,*args):
    #self._protected_model = None

    #self.shape = None

    #self._protected_shape_p = None

    self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_reduceDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(46:16-56:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("reduceDims()")
  def __reduceDims_(self):
    if   (self.shape.nd > 1):
      ndim = ( self.shape._realnd_() )

      d = ([ 0 for _autovar_74 in xrange(ndim) ])

      # { @ src/fusion/Constraint.mbi(51:11-111)
      j = 0

      # src/fusion/Constraint.mbi(51:24-109)
      i = 0

      while (i < ndim):
        if   (( self.shape._dim_I(i) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
        i += 1
      # } @ src/fusion/Constraint.mbi(51:11-111)
      self.shape = mosek.fusion.NDSet(d)
      self._shape_p = self.shape
    return self
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(75:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(91:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(98:15-100:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int)")
  def _index_I(self,idx):
    return ( self._slice_II(idx,(idx + 1)) )
  @staticmethod
  def _matchargs_index__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(107:15-111:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index([int32])")
  def _index__3I(self,idx):
    idxplusone = ( Utils.Tools._arraycopy__3I (idx) )

    # src/fusion/Constraint.mbi(109:9-59)
    i = 0

    while (i < int(len(idx))):
      idxplusone[i] += 1
      i += 1
    return ( ( self._slice__3I_3I(idx,idxplusone) ).__reduceDims_() )
  @staticmethod
  def _matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Constraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(126:15-133:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack(mosek.fusion.Constraint,mosek.fusion.Constraint)")
  def _stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(v1,v2):

    vs = ([ None for _autovar_75 in xrange(2) ])
    vs[0] = v1
    vs[1] = v2
    return mosek.fusion.CompoundConstraint(vs)
  @staticmethod
  def _matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Constraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Constraint): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(148:15-156:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")
  def _stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(v1,v2,v3):

    vs = ([ None for _autovar_76 in xrange(2) ])
    vs[0] = v1
    vs[1] = v2
    return mosek.fusion.CompoundConstraint(vs)
  @staticmethod
  def _matchargs_stack__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(171:15-174:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([mosek.fusion.Constraint])")
  def _stack__3Omosek_fusion_Constraint_2(clist):
    return mosek.fusion.CompoundConstraint(clist)
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(180:15-182:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self._shape_p._size
  @staticmethod
  def _matchargs_get_1nd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(187:15-189:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get_nd()")
  def _get_1nd_(self):
    return self._shape_p._nd_p
  @staticmethod
  def _matchargs_get_1model_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(194:15-196:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get_model()")
  def _get_1model_(self):
    return self._model
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(228:18-234:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(237:18-241:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(249:18-258:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(int,[double])")
  def _level_1values_I_3F(self,offset,target):
    strides = ([ 0l for _autovar_77 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_78 in xrange(self.shape.nd) ])

    # src/fusion/Constraint.mbi(255:9-65)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Constraint.mbi(256:9-62)
    for i in xrange(0,self.shape.nd):
      dims[i] = ( self.shape._dim_I(i) )
    ( self._level_1values_L_3I_3LI_3F(0l,dims,strides,offset,target) )
  @staticmethod
  def _matchargs_level_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(276:15-292:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int,int)")
  def _level_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx < 0)) or (firstidx > lastidx)) or (lastidx > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_79 in xrange(num) ])

    dims = ([ (lastidx - firstidx)])

    strides = ([ 1l])

    ( self._level_1values_L_3I_3LI_3F(long(firstidx),dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(311:15-342:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level([int32],[int32])")
  def _level__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Constraint.mbi(321:9-328:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] > ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] - firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_80 in xrange(num) ])

    dims = ([ 0 for _autovar_81 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_82 in xrange(self.shape.nd) ])

    # src/fusion/Constraint.mbi(333:9-63)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Constraint.mbi(334:9-72)
    for i in xrange(0,self.shape.nd):
      dims[i] = (lastidx[i] - firstidx[i])
    start = 0l

    # src/fusion/Constraint.mbi(337:9-338:58)
    for i in xrange(0,self.shape.nd):
      start = (start + (long(firstidx[i]) * strides[i]))
    ( self._level_1values_L_3I_3LI_3F(start,dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(359:15-368:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int)")
  def _level_I(self,index):
    if   (((self.shape.nd != 1) or (index < 0)) or (index >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid index.")
    idxs = ([ long(index)])

    res = ([ 0.0 for _autovar_83 in xrange(1) ])

    ( self._level_1values__3LI_3F(idxs,0,res) )
    return res[0]
  @staticmethod
  def _matchargs_level_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(379:15-383:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("level()")
  def _level_(self):
    res = ([ 0.0 for _autovar_84 in xrange(self.shape._size) ])

    ( self._level_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(416:18-422:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(425:18-429:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(433:18-446:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(int,[double])")
  def _dual_1values_I_3F(self,offset,target):
    nsize = ([ 0 for _autovar_85 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_86 in xrange(self.shape.nd) ])

    # src/fusion/Constraint.mbi(439:9-443:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Constraint.mbi(440:9-443:9)
      nsize[i] = ( self.shape._dim_I(i) )
      strides[i] = ( self.shape._stride_I(i) )
      # } @ src/fusion/Constraint.mbi(440:9-443:9)
    ( self._dual_1values_L_3I_3LI_3F(0l,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_dual_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(457:15-461:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dual()")
  def _dual_(self):
    res = ([ 0.0 for _autovar_87 in xrange(self.shape._size) ])

    ( self._dual_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(481:15-494:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual(int,int)")
  def _dual_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx > lastidx)) or (firstidx < 0)) or (lastidx >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_88 in xrange(num) ])

    ( self._dual_1values_L_3I_3LI_3F(long(firstidx),([ num]),([ 1l]),0,res) )
    return res
  @staticmethod
  def _matchargs_dual__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(513:15-541:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int32],[int32])")
  def _dual__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Constraint.mbi(520:9-527:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] >= ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] * firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_89 in xrange(num) ])

    nsize = ([ 0 for _autovar_90 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_91 in xrange(self.shape.nd) ])

    firstelm = 0l

    # src/fusion/Constraint.mbi(532:9-537:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Constraint.mbi(533:9-537:9)
      nsize[i] = (lastidx[i] - firstidx[i])
      strides[i] = ( self.shape._stride_I(i) )
      firstelm = (firstelm + (strides[i] * firstidx[i]))
      # } @ src/fusion/Constraint.mbi(533:9-537:9)
    ( self._dual_1values_L_3I_3LI_3F(firstelm,nsize,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(569:18-582:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([int64],[int64],[int32],[int32],[int32],[double],[double],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    raise mosek.fusion.UnimplementedError("add_l not implemented")
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Constraint.mbi(605:15-636:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression)")
  def _add_Omosek_fusion_Expression_2(self,e_):
    if   (not ( e_._shape._compare_Omosek_fusion_Set_2(self.shape) )):
      raise mosek.fusion.DimensionError("The added expression does not have the same shape as the constraint")
    e = ( e_._eval_() )

    nrows = (int(len(e.ptrb)) - 1)

    tmpsubj = ([ 0 for _autovar_92 in xrange(e.nnz) ])

    tmpsubk = ([ 0 for _autovar_93 in xrange(e.nnz) ])

    tmpsubl = ([ 0 for _autovar_94 in xrange(e.nnz) ])

    # src/fusion/Constraint.mbi(617:9-618:58)
    for i in xrange(0l,e.nnz):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],i,tmpsubj,tmpsubk,tmpsubl) )
    subi = e.inst

    if   (subi == None):
      subi = ( Utils.Tools._range_LL (0l,long(nrows)) )
    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FLII(subi,e.ptrb,tmpsubj,tmpsubk,tmpsubl,e.cof,e.bfix,0l,0,nrows) )
    return self
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Constraint.mbi(646:15-679:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable)")
  def _add_Omosek_fusion_Variable_2(self,v):
    if   (not ( v.shape._compare_Omosek_fusion_Set_2(self.shape) )):
      raise mosek.fusion.DimensionError("The added variable does not have the same shape as the constraint")
    nrows = v.shape._size

    tmpsubj = ([ 0 for _autovar_95 in xrange(nrows) ])

    tmpsubk = ([ 0 for _autovar_96 in xrange(nrows) ])

    tmpsubl = ([ 0 for _autovar_97 in xrange(nrows) ])

    ptrb = ( Utils.Tools._range_LL (0l,(nrows + 1)) )

    cof = ([ 0.0 for _autovar_98 in xrange(nrows) ])

    # src/fusion/Constraint.mbi(657:9-661:9)
    for i in xrange(0l,nrows):
      # { @ src/fusion/Constraint.mbi(658:9-661:9)
      ( v._inst_LL_3I_3I_3I(i,i,tmpsubj,tmpsubk,tmpsubl) )
      cof[i] = 1.0
      # } @ src/fusion/Constraint.mbi(658:9-661:9)
    subi = ( Utils.Tools._range_LL (0l,nrows) )

    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FLII(subi,ptrb,tmpsubj,tmpsubk,tmpsubk,cof,None,0l,0,int(nrows)) )
    return self
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   Constraint._matchargs_slice_II(args):
      return Constraint._slice_II(self,*args)
    elif Constraint._matchargs_slice__3I_3I(args):
      return Constraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/SliceConstraint.mbi(18:12-375:5)
class SliceConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.ModelConstraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.ModelConstraint,mosek.fusion.Set,long,[int64])")
  def __constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,origin_._model,shape_)
    self._origin = origin_
    self._first = first_
    self._strides = strides_
  def __init__(self,*args):
    #self._protected_origin = None

    #self._protected_first = None

    #self._protected_strides = None

    self.__constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(*args)
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(38:18-43:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[int64])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.SliceConstraint(self._origin,shape_,first_,strides_)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(46:15-51:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    shp = ( self.shape._slice_II(firstidx,lastidx) )

    return ( self._slice_1_Omosek_fusion_Set_2L_3L(shp,(self._first + firstidx),self._strides) )
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(53:15-61:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,firstidx,lastidx):
    shp = ( self.shape._slice__3I_3I(firstidx,lastidx) )

    newfirst = self._first

    # src/fusion/SliceConstraint.mbi(58:9-59:62)
    i = 0

    while (i < int(len(firstidx))):
      newfirst = (newfirst + (long(firstidx[i]) * self._strides[i]))
      i += 1
    return ( self._slice_1_Omosek_fusion_Set_2L_3L(shp,newfirst,self._strides) )
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(67:15-69:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self.shape._size
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(109:18-125:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_99 in xrange(int(len(idxs))) ])

    # src/fusion/SliceConstraint.mbi(115:9-122:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceConstraint.mbi(116:9-122:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceConstraint.mbi(119:11-120:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self._strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceConstraint.mbi(116:9-122:9)
    ( self._origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(128:18-203:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_100 in xrange(self.shape.nd) ])

      # src/fusion/SliceConstraint.mbi(139:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self._origin._level_1values_L_3I_3LI_3F(self._first,tmp_nsize,self._strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceConstraint.mbi(146:11-147:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self._first

        # { @ src/fusion/SliceConstraint.mbi(152:13-160:13)
        tmp = start

        # src/fusion/SliceConstraint.mbi(154:15-159:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceConstraint.mbi(155:15-159:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceConstraint.mbi(155:15-159:15)
        # } @ src/fusion/SliceConstraint.mbi(152:13-160:13)
        ( self._origin._level_1values_L_3I_3LI_3F(slice_start,nsize,self._strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceConstraint.mbi(166:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_101 in xrange(totalsize) ])

        # { @ src/fusion/SliceConstraint.mbi(169:13-198:13)
        ii = ([ 0 for _autovar_102 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_103 in xrange(int(len(nsize))) ])

        # src/fusion/SliceConstraint.mbi(171:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceConstraint.mbi(172:15-197:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceConstraint.mbi(173:15-197:15)
          # { @ src/fusion/SliceConstraint.mbi(174:17-184:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceConstraint.mbi(177:19-182:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceConstraint.mbi(178:19-182:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self._strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceConstraint.mbi(178:19-182:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceConstraint.mbi(174:17-184:17)
          # { @ src/fusion/SliceConstraint.mbi(188:17-196:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceConstraint.mbi(190:20-194:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceConstraint.mbi(195:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceConstraint.mbi(188:17-196:17)
          # } @ src/fusion/SliceConstraint.mbi(173:15-197:15)
        # } @ src/fusion/SliceConstraint.mbi(169:13-198:13)
        ( self._origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(211:18-227:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_104 in xrange(int(len(idxs))) ])

    # src/fusion/SliceConstraint.mbi(217:9-224:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceConstraint.mbi(218:9-224:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceConstraint.mbi(221:11-222:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self._strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceConstraint.mbi(218:9-224:9)
    ( self._origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(230:18-305:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_105 in xrange(self.shape.nd) ])

      # src/fusion/SliceConstraint.mbi(241:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self._origin._dual_1values_L_3I_3LI_3F(self._first,tmp_nsize,self._strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceConstraint.mbi(248:11-249:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self._first

        # { @ src/fusion/SliceConstraint.mbi(254:13-262:13)
        tmp = start

        # src/fusion/SliceConstraint.mbi(256:15-261:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceConstraint.mbi(257:15-261:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceConstraint.mbi(257:15-261:15)
        # } @ src/fusion/SliceConstraint.mbi(254:13-262:13)
        ( self._origin._dual_1values_L_3I_3LI_3F(slice_start,nsize,self._strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceConstraint.mbi(268:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_106 in xrange(totalsize) ])

        # { @ src/fusion/SliceConstraint.mbi(271:13-300:13)
        ii = ([ 0 for _autovar_107 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_108 in xrange(int(len(nsize))) ])

        # src/fusion/SliceConstraint.mbi(273:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceConstraint.mbi(274:15-299:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceConstraint.mbi(275:15-299:15)
          # { @ src/fusion/SliceConstraint.mbi(276:17-286:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceConstraint.mbi(279:19-284:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceConstraint.mbi(280:19-284:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self._strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceConstraint.mbi(280:19-284:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceConstraint.mbi(276:17-286:17)
          # { @ src/fusion/SliceConstraint.mbi(290:17-298:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceConstraint.mbi(292:20-296:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceConstraint.mbi(297:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceConstraint.mbi(290:17-298:17)
          # } @ src/fusion/SliceConstraint.mbi(275:15-299:15)
        # } @ src/fusion/SliceConstraint.mbi(271:13-300:13)
        ( self._origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(308:18-330:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    sl_subi = ([ 0l for _autovar_109 in xrange(num) ])

    sl_bfix = ([ 0.0 for _autovar_110 in xrange(num) ])

    ( Utils.Tools._arraycopy__3FI_3FII (bfix,srcoffset,sl_bfix,0,num) )
    # src/fusion/SliceConstraint.mbi(320:9-327:9)
    for i in xrange(0,num):
      # { @ src/fusion/SliceConstraint.mbi(321:9-327:9)
      index = ( self.shape._idxtokey_L(subi[(srcoffset + i)]) )

      sl_index = 0l

      # src/fusion/SliceConstraint.mbi(324:11-89)
      for j in xrange(0,int(len(index))):
        sl_index = (sl_index + (long(index[j]) * self._strides[j]))
      sl_subi[i] = sl_index
      # } @ src/fusion/SliceConstraint.mbi(321:9-327:9)
    ( self._origin._add_1fx__3L_3FLII(sl_subi,sl_bfix,0l,0,num) )
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(333:18-374:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([int64],[int64],[int32],[int32],[int32],[double],[double],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    numnz = (ptrb[(srcoffset + num)] - ptrb[srcoffset])

    sl_subi = ([ 0l for _autovar_111 in xrange(num) ])

    sl_ptrb = ([ 0l for _autovar_112 in xrange((num + 1)) ])

    sl_bfix = None

    if   (bfix != None):
      sl_bfix = ([ 0.0 for _autovar_113 in xrange(num) ])
    # src/fusion/SliceConstraint.mbi(351:9-62)
    for i in xrange(0,(num + 1)):
      sl_ptrb[i] = ptrb[(srcoffset + i)]
    if   (self.shape.nd == 1):
      # src/fusion/SliceConstraint.mbi(355:11-356:62)
      for i in xrange(0,num):
        sl_subi[i] = ((subi[(i + srcoffset)] - subibase) + self._first)
    else:
      # src/fusion/SliceConstraint.mbi(360:11-367:11)
      for i in xrange(0,num):
        # { @ src/fusion/SliceConstraint.mbi(361:11-367:11)
        index = ( self.shape._idxtokey_L((subi[(srcoffset + i)] - subibase)) )

        sl_index = 0l

        # src/fusion/SliceConstraint.mbi(364:13-91)
        for j in xrange(0,int(len(index))):
          sl_index = (sl_index + (long(index[j]) * self._strides[j]))
        sl_subi[i] = sl_index
        # } @ src/fusion/SliceConstraint.mbi(361:11-367:11)
    if   (bfix != None):
      ( Utils.Tools._arraycopy__3FI_3FII (bfix,srcoffset,sl_bfix,0,num) )
    ( self._origin._add_1l__3L_3L_3I_3I_3I_3F_3FLII(sl_subi,sl_ptrb,subj,subk,subl,cof,sl_bfix,0l,0,num) )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   SliceConstraint._matchargs_slice_II(args):
      return SliceConstraint._slice_II(self,*args)
    elif SliceConstraint._matchargs_slice__3I_3I(args):
      return SliceConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   SliceConstraint._matchargs_size_(args):
      return SliceConstraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/BoundInterfaceConstraint.mbi(22:12-71:5)
class BoundInterfaceConstraint(SliceConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangedConstraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[4],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RangedConstraint,mosek.fusion.Set,long,[int64],bool)")
  def __constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(self,origin_,shape_,first_,strides_,islower_):
    mosek.fusion.SliceConstraint._SliceConstraint__constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_)
    self.__origincon = origin_
    self.__islower = islower_
  def __init__(self,*args):
    #self.__islower = None

    #self.__origincon = None

    self.__constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(42:18-50:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    if   self.__islower:
      ( self.__origincon._dual_1l__3LI_3F(idxs,offset,target) )
    else:
      ( self.__origincon._dual_1u__3LI_3F(idxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(52:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   self.__islower:
      ( self.__origincon._dual_1l_L_3I_3LI_3F(start,nsize,strides_,offset,target) )
    else:
      ( self.__origincon._dual_1u_L_3I_3LI_3F(start,nsize,strides_,offset,target) )
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(65:18-70:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[int64])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.BoundInterfaceConstraint(self.__origincon,shape_,first_,strides_,self.__islower)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   SliceConstraint._matchargs_slice_II(args):
      return SliceConstraint._slice_II(self,*args)
    elif SliceConstraint._matchargs_slice__3I_3I(args):
      return SliceConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   SliceConstraint._matchargs_size_(args):
      return SliceConstraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/CompoundConstraint.mbi(18:12-429:5)
class CompoundConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([mosek.fusion.Constraint])")
  def __constructor__3Omosek_fusion_Constraint_2(self,c):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( CompoundConstraint.__model_1from_1con__3Omosek_fusion_Constraint_2 (c) ),( CompoundConstraint.__compute_1shape__3Omosek_fusion_Constraint_2I (c,0) ))
    dim = 0

    numnz = 0

    dimsize = 0

    # src/fusion/CompoundConstraint.mbi(102:9-114:9)
    i = 0

    while (i < int(len(c))):
      if   (c[i].shape._size == 1):
        numnz += 1
        dimsize += 1
      elif (c[i].shape._size > 1):
        numnz += 1
        dimsize = (dimsize + ( c[i].shape._dim_I(dim) ))
      i += 1
    self.__cons = ([ None for _autovar_114 in xrange(numnz) ])
    self.__consb = ([ 0 for _autovar_115 in xrange((numnz + 1)) ])
    self.__consb[0] = 0
    self.__stackdim = dim
    # { @ src/fusion/CompoundConstraint.mbi(121:9-132:9)
    j = 0

    # src/fusion/CompoundConstraint.mbi(123:11-133:12)
    i = 0

    while (i < int(len(c))):
      if   (c[i].shape._size > 0):
        self.__cons[j] = c[i]
        j += 1
        if   (c[i].shape._size == 1):
          self.__consb[(i + 1)] = (self.__consb[i] + 1)
        else:
          self.__consb[(i + 1)] = (self.__consb[i] + ( c[i].shape._dim_I(dim) ))
      i += 1
    # } @ src/fusion/CompoundConstraint.mbi(121:9-132:9)
  def __init__(self,*args):
    #self.__cons = None

    #self.__consb = None

    #self.__stackdim = None

    self.__constructor__3Omosek_fusion_Constraint_2(*args)
  @staticmethod
  def _matchargs_model_1from_1con__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(30:16-33:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from_con([mosek.fusion.Constraint])")
  def __model_1from_1con__3Omosek_fusion_Constraint_2(c):
    return c[0]._model
  @staticmethod
  def _matchargs_count_1numcon__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(36:16-53:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("count_numcon([mosek.fusion.Constraint])")
  def __count_1numcon__3Omosek_fusion_Constraint_2(c):
    num = 0

    # src/fusion/CompoundConstraint.mbi(39:9-51:9)
    i = 0

    while (i < int(len(c))):
      ci = c[i]

      _autovar_116 = ci
      if   isinstance(_autovar_116,mosek.fusion.CompoundConstraint):
        cc = _autovar_116
        num = (num + int(len(cc.__cons)))
      else:
        cc = _autovar_116
        num += 1
      i += 1
    return num
  @staticmethod
  def _matchargs_compute_1shape__3Omosek_fusion_Constraint_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(56:16-84:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compute_shape([mosek.fusion.Constraint],int)")
  def __compute_1shape__3Omosek_fusion_Constraint_2I(v,dim):
    s = v[0].shape

    sdsize = 0

    # src/fusion/CompoundConstraint.mbi(60:9-74:9)
    for i in xrange(0,int(len(v))):
      # { @ src/fusion/CompoundConstraint.mbi(61:9-74:9)
      if   (v[i].shape._size > 0):
        if   (v[i].shape.nd != s.nd):
          raise mosek.fusion.DimensionError("Mismatching variable shape")
        # src/fusion/CompoundConstraint.mbi(67:13-71:21)
        j = 0

        while (j < s.nd):
          if   ((j != dim) and (( s._dim_I(j) ) != ( v[i].shape._dim_I(j) ))):
            raise mosek.fusion.DimensionError("Mismatching variable shape")
          j += 1
        sdsize = (sdsize + ( v[i].shape._dim_I(dim) ))
      else:
        raise mosek.fusion.DimensionError("Empty element in compound variable")
      # } @ src/fusion/CompoundConstraint.mbi(61:9-74:9)
    if   (s.nd == 1):
      return mosek.fusion.IntSet(sdsize)
    else:
      d = ([ 0 for _autovar_117 in xrange(s.nd) ])

      # src/fusion/CompoundConstraint.mbi(80:11-57)
      i = 0

      while (i < s.nd):
        d[i] = ( s._dim_I(i) )
        i += 1
      d[dim] = sdsize
      return mosek.fusion.NDSet(d)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(136:15-140:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    raise mosek.fusion.UnimplementedError("Compound constraints cannot be sliced")
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(143:15-147:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    raise mosek.fusion.UnimplementedError("Compound constraints cannot be sliced")
  @staticmethod
  def _matchargs_add__3L_3I_3F_3FI_3II(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[4],int): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[6],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(151:18-161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([int64],[int32],[double],[double],int,[int32],int)")
  def _add__3L_3I_3F_3FI_3II(self,eptrb,esubj,ecof,ebfix,firstrow,tgtidxs,num):
    raise mosek.fusion.UnimplementedError("Functionality not implemented yet.")
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(167:18-193:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_118 in xrange(1) ])

    index = ([ 0 for _autovar_119 in xrange(self.shape.nd) ])

    # src/fusion/CompoundConstraint.mbi(174:9-192:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundConstraint.mbi(175:9-192:9)
      # { @ src/fusion/CompoundConstraint.mbi(176:11-183:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundConstraint.mbi(178:13-182:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(179:13-182:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundConstraint.mbi(179:13-182:13)
      # } @ src/fusion/CompoundConstraint.mbi(176:11-183:11)
      # { @ src/fusion/CompoundConstraint.mbi(185:11-191:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(187:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(185:11-191:11)
      # } @ src/fusion/CompoundConstraint.mbi(175:9-192:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(196:18-255:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundConstraint.mbi(204:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_120 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundConstraint.mbi(213:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_121 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_122 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_123 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundConstraint.mbi(216:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_124 in xrange(1) ])

    # src/fusion/CompoundConstraint.mbi(220:9-254:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundConstraint.mbi(221:9-254:9)
      # { @ src/fusion/CompoundConstraint.mbi(223:11-230:11)
      tmpval = st[0]

      # src/fusion/CompoundConstraint.mbi(225:13-229:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(226:13-229:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundConstraint.mbi(226:13-229:13)
      # } @ src/fusion/CompoundConstraint.mbi(223:11-230:11)
      # { @ src/fusion/CompoundConstraint.mbi(233:11-239:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(235:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(233:11-239:11)
      # { @ src/fusion/CompoundConstraint.mbi(242:11-253:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundConstraint.mbi(246:13-249:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundConstraint.mbi(251:13-252:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundConstraint.mbi(242:11-253:11)
      # } @ src/fusion/CompoundConstraint.mbi(221:9-254:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(261:18-287:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_125 in xrange(1) ])

    index = ([ 0 for _autovar_126 in xrange(self.shape.nd) ])

    # src/fusion/CompoundConstraint.mbi(268:9-286:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundConstraint.mbi(269:9-286:9)
      # { @ src/fusion/CompoundConstraint.mbi(270:11-277:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundConstraint.mbi(272:13-276:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(273:13-276:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundConstraint.mbi(273:13-276:13)
      # } @ src/fusion/CompoundConstraint.mbi(270:11-277:11)
      # { @ src/fusion/CompoundConstraint.mbi(279:11-285:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(281:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(279:11-285:11)
      # } @ src/fusion/CompoundConstraint.mbi(269:9-286:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(290:18-349:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundConstraint.mbi(298:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_127 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundConstraint.mbi(307:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_128 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_129 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_130 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundConstraint.mbi(310:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_131 in xrange(1) ])

    # src/fusion/CompoundConstraint.mbi(314:9-348:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundConstraint.mbi(315:9-348:9)
      # { @ src/fusion/CompoundConstraint.mbi(317:11-324:11)
      tmpval = st[0]

      # src/fusion/CompoundConstraint.mbi(319:13-323:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(320:13-323:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundConstraint.mbi(320:13-323:13)
      # } @ src/fusion/CompoundConstraint.mbi(317:11-324:11)
      # { @ src/fusion/CompoundConstraint.mbi(327:11-333:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(329:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(327:11-333:11)
      # { @ src/fusion/CompoundConstraint.mbi(336:11-347:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundConstraint.mbi(340:13-343:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundConstraint.mbi(345:13-346:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundConstraint.mbi(336:11-347:11)
      # } @ src/fusion/CompoundConstraint.mbi(315:9-348:9)
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(352:17-428:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([int64],[int64],[int32],[int32],[int32],[double],[double],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    subi_ = ([ 0l for _autovar_132 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(364:42-102)
    for i in xrange(0,num):
      subi_[i] = (subi[(srcoffset + i)] - subibase)
    perm = ([ 0l for _autovar_133 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(365:42-84)
    for i in xrange(0,num):
      perm[i] = long(i)
    cdimiidx = ([ 0l for _autovar_134 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(367:9-368:84)
    for i in xrange(0,num):
      cdimiidx[i] = long(( self.shape._idxtokey_L((subi[(srcoffset + i)] - subibase)) )[self.__stackdim])
    ( CommonTools._argQsort__3L_3L_3LLL (perm,cdimiidx,subi_,0l,long(num)) )
    csubi = ([ 0 for _autovar_135 in xrange(num) ])

    # { @ src/fusion/CompoundConstraint.mbi(372:9-380:9)
    ci = 0

    # src/fusion/CompoundConstraint.mbi(373:23-65)
    while (self.__consb[ci] < cdimiidx[perm[0]]):
      ci += 1
    csubi[0] = ci
    # src/fusion/CompoundConstraint.mbi(375:11-379:11)
    for i in xrange(1,num):
      # { @ src/fusion/CompoundConstraint.mbi(376:11-379:11)
      # src/fusion/CompoundConstraint.mbi(377:13-55)
      while (self.__consb[ci] < cdimiidx[perm[i]]):
        ci += 1
      csubi[i] = ci
      # } @ src/fusion/CompoundConstraint.mbi(376:11-379:11)
    # } @ src/fusion/CompoundConstraint.mbi(372:9-380:9)
    # { @ src/fusion/CompoundConstraint.mbi(383:9-427:9)
    sl_subi = ([ 0l for _autovar_136 in xrange(num) ])

    sl_ptrb = ([ 0l for _autovar_137 in xrange((num + 1)) ])

    nnz = (ptrb[(srcoffset + num)] - ptrb[srcoffset])

    sl_subj = ([ 0 for _autovar_138 in xrange(nnz) ])

    sl_subk = ([ 0 for _autovar_139 in xrange(nnz) ])

    sl_subl = ([ 0 for _autovar_140 in xrange(nnz) ])

    sl_cof = ([ 0.0 for _autovar_141 in xrange(nnz) ])

    sl_bfix = None

    if   (bfix != None):
      sl_bfix = ([ 0.0 for _autovar_142 in xrange(nnz) ])
    sl_ptrb[0] = 0l
    # src/fusion/CompoundConstraint.mbi(394:11-412:11)
    for i in xrange(0,num):
      # { @ src/fusion/CompoundConstraint.mbi(395:11-412:11)
      ci = csubi[i]

      if   (self.__cons[ci].shape._size == 1):
        sl_subi[i] = 0l
      else:
        subi_conidx = ( self.shape._idxtokey_L(subi_[perm[i]]) )

        subi_conidx[self.__stackdim] = (subi_conidx[self.__stackdim] - self.__consb[ci])
        sl_subi[i] = ( self.__cons[ci].shape._linearidx__3I(subi_conidx) )
      numinz = (ptrb[(perm[i] + 1)] - ptrb[perm[i]])

      sl_ptrb[(i + 1)] = (sl_ptrb[i] + numinz)
      ( Utils.Tools._arraycopy__3IL_3ILL (subj,ptrb[perm[i]],sl_subj,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3IL_3ILL (subk,ptrb[perm[i]],sl_subk,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3IL_3ILL (subl,ptrb[perm[i]],sl_subl,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3FL_3FLL (cof,ptrb[perm[i]],sl_cof,sl_ptrb[i],numinz) )
      # } @ src/fusion/CompoundConstraint.mbi(395:11-412:11)
    if   (bfix != None):
      # src/fusion/CompoundConstraint.mbi(414:13-415:41)
      for i in xrange(0,num):
        sl_bfix[i] = bfix[perm[i]]
    # { @ src/fusion/CompoundConstraint.mbi(418:11-426:11)
    i = 0

    # src/fusion/CompoundConstraint.mbi(420:13-425:13)
    while (i < num):
      istart = i

      i += 1
      # src/fusion/CompoundConstraint.mbi(422:36-85)
      while ((i < num) and (csubi[i] == csubi[istart])):
        i += 1
      ( self.__cons[csubi[istart]]._add_1l__3L_3L_3I_3I_3I_3F_3FLII(sl_subi,sl_ptrb,sl_subj,sl_subk,sl_subl,sl_cof,sl_bfix,0l,istart,(i - istart)) )
    # } @ src/fusion/CompoundConstraint.mbi(418:11-426:11)
    # } @ src/fusion/CompoundConstraint.mbi(383:9-427:9)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   CompoundConstraint._matchargs_slice_II(args):
      return CompoundConstraint._slice_II(self,*args)
    elif CompoundConstraint._matchargs_slice__3I_3I(args):
      return CompoundConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/ModelConstraint.mbi(13:12-607:5)
class ModelConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 11:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int32],[int64],[int32],[double],[double],[int32],[int32],[[int32]])")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_)
    self._cache = None
    self._nativeindexes = nidxs_
    self._name = name_
    if   (bfix != None):
      self._cache_bfix = ( Utils.Tools._arraycopy__3F (bfix) )
    else:
      self._cache_bfix = ([ 0.0 for _autovar_143 in xrange(int(len(nidxs_))) ])
    if   (((barsubi_ != None) and (barsubj_ != None)) and (barsymmatidx_ != None)):
      self.__barsubi = barsubi_
      self.__barsubj = barsubj_
      self.__barsymmatidx = barsymmatidx_
    else:
      self.__barsubi = ([ 0 for _autovar_144 in xrange(0) ])
      self.__barsubj = ([ 0 for _autovar_145 in xrange(0) ])
      self.__barsymmatidx = ([ 0 for _autovar_146 in xrange(0) ])
  def __init__(self,*args):
    #self._protected_cache = None

    #self._protected_cache_bfix = None

    #self._protected_name = None

    #self._protected_nativeindexes = None

    #self.__barsubi = None

    #self.__barsubj = None

    #self.__barsymmatidx = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(88:15-94:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    strides = ([ 1l])

    return mosek.fusion.SliceConstraint(self,( self.shape._slice_II(first,last) ),long(first),strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(97:15-132:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    shp = ( self.shape._slice__3I_3I(first,last) )

    strides = ([ 0l for _autovar_147 in xrange(self.shape.nd) ])

    i = self.shape.nd

    j = self.shape.nd

    strides[(i - 1)] = 1l
    i = (i - 1)
    # src/fusion/ModelConstraint.mbi(110:9-120:9)
    while (i > 0):
      if   ((last[i] - first[i]) > 1):
        j = (j - 1)
        strides[(j - 1)] = strides[j]
      strides[(j - 1)] = (strides[(j - 1)] * ( self.shape._dim_I(i) ))
      i = (i - 1)
    firstidx = 0l

    # src/fusion/ModelConstraint.mbi(124:9-127:9)
    i = 0
    while (i < int(len(strides))):
      firstidx = (firstidx + (strides[i] * first[i]))
      i += 1
    return mosek.fusion.SliceConstraint(self,shp,firstidx,strides)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(137:18-144:7)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    pass
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(152:18-481:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([int64],[int64],[int32],[int32],[int32],[double],[double],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    # src/fusion/ModelConstraint.mbi(164:9-170:14)
    for i in xrange(1,int(len(subi))):
      if   (subi[(i - 1)] >= subi[i]):
        raise mosek.fusion.UnimplementedError("Not supported: Non-contiguous index ranges in ModelConstraint.add_l")
    perm = ([ 0l for _autovar_148 in xrange((ptrb[(srcoffset + num)] - ptrb[srcoffset])) ])

    # src/fusion/ModelConstraint.mbi(170:9-90)
    for i in xrange(0l,(ptrb[(srcoffset + num)] - ptrb[srcoffset])):
      perm[i] = (ptrb[srcoffset] + i)
    # src/fusion/ModelConstraint.mbi(171:9-172:109)
    for i in xrange(0,num):
      ( CommonTools._argQsort__3L_3I_3ILL (perm,subj,None,ptrb[(srcoffset + i)],(ptrb[((srcoffset + i) + 1)] - ptrb[(srcoffset + i)])) )
    numlnz = 0

    numbarnz = 0

    # src/fusion/ModelConstraint.mbi(176:9-180:23)
    for k in xrange(ptrb[srcoffset],ptrb[(srcoffset + num)]):
      if   (subj[k] >= 0):
        numlnz += 1
      else:
        numbarnz += 1
    if   ((numlnz > 0) or (bfix != None)):
      lptrb = ([ 0l for _autovar_149 in xrange((self._cache.nrows + 1)) ])

      lsubj = ([ 0 for _autovar_150 in xrange(numlnz) ])

      lcof = ([ 0.0 for _autovar_151 in xrange(numlnz) ])

      lbfix = None

      if   (bfix != None):
        lbfix = ([ 0.0 for _autovar_152 in xrange(self._cache.nrows) ])
        # src/fusion/ModelConstraint.mbi(192:13-193:70)
        for i in xrange(0,num):
          lbfix[(subi[(i + srcoffset)] - subibase)] = bfix[(srcoffset + i)]
      lptrb[0] = 0l
      ii = srcoffset

      # src/fusion/ModelConstraint.mbi(198:11-217:11)
      for i in xrange(0,self._cache.nrows):
        # { @ src/fusion/ModelConstraint.mbi(199:11-217:11)
        if   ((ii < num) and ((subi[ii] - subibase) == i)):
          b = lptrb[i]

          # src/fusion/ModelConstraint.mbi(203:15-211:22)
          for l in xrange(ptrb[ii],ptrb[(ii + 1)]):
            if   (subj[l] >= 0):
              lsubj[b] = subj[l]
              lcof[b] = cof[l]
              b += 1
          lptrb[(i + 1)] = b
          ii += 1
        else:
          lptrb[(i + 1)] = lptrb[i]
        # } @ src/fusion/ModelConstraint.mbi(199:11-217:11)
      ( self._cache._add__3L_3I_3F_3F(lptrb,lsubj,lcof,lbfix) )
      # { @ src/fusion/ModelConstraint.mbi(221:11-245:11)
      nrows = self._cache.nrows

      nn = int(( self._cache._numUnsorted_() ))

      nptrb = ([ 0l for _autovar_153 in xrange((nrows + 1)) ])

      nsubj = ([ 0 for _autovar_154 in xrange(nn) ])

      ncof = ([ 0.0 for _autovar_155 in xrange(nn) ])

      nx = ( self._cache._flush__3L_3I_3F_3F(nptrb,nsubj,ncof,None) )

      nsubi = ([ 0 for _autovar_156 in xrange(nx) ])

      k = 0

      # src/fusion/ModelConstraint.mbi(232:13-239:13)
      for i in xrange(0,nrows):
        # { @ src/fusion/ModelConstraint.mbi(233:13-239:13)
        # src/fusion/ModelConstraint.mbi(234:15-238:15)
        for j in xrange(nptrb[i],nptrb[(i + 1)]):
          # { @ src/fusion/ModelConstraint.mbi(235:15-238:15)
          nsubi[k] = self._nativeindexes[i]
          k += 1
          # } @ src/fusion/ModelConstraint.mbi(235:15-238:15)
        # } @ src/fusion/ModelConstraint.mbi(233:13-239:13)
      ( self._model._task_1putaijlist__3I_3I_3FL(nsubi,nsubj,ncof,long(k)) )
      if   (bfix != None):
        ( self._add_1fx__3L_3FLII(subi,self._cache.bfix,subibase,srcoffset,num) )
      # } @ src/fusion/ModelConstraint.mbi(221:11-245:11)
    if   (numbarnz > 0):
      numbaraentry = 0

      # { @ src/fusion/ModelConstraint.mbi(253:11-266:11)
      pbase = ptrb[srcoffset]

      # src/fusion/ModelConstraint.mbi(255:13-265:13)
      for i in xrange(0,num):
        # { @ src/fusion/ModelConstraint.mbi(256:13-265:13)
        if   (subj[perm[(ptrb[srcoffset] - pbase)]] < 0):
          numbaraentry = 1
          # src/fusion/ModelConstraint.mbi(260:17-265:18)
          for k in xrange(((ptrb[(srcoffset + i)] - pbase) + 1),(ptrb[((srcoffset + i) + 1)] - pbase)):
            if   ((subj[perm[k]] < 0) and (subj[perm[k]] != subj[perm[(k - 1)]])):
              numbaraentry += 1
        # } @ src/fusion/ModelConstraint.mbi(256:13-265:13)
      # } @ src/fusion/ModelConstraint.mbi(253:11-266:11)
      nbaraijsubi = ([ 0 for _autovar_157 in xrange(numbaraentry) ])

      nbaraijsubj = ([ 0 for _autovar_158 in xrange(numbaraentry) ])

      nbaraijidx = ([ 0 for _autovar_159 in xrange(numbaraentry) ])

      # { @ src/fusion/ModelConstraint.mbi(272:11-344:11)
      pbase = ptrb[srcoffset]

      l = 0

      # src/fusion/ModelConstraint.mbi(275:13-343:13)
      for i in xrange(0,num):
        # { @ src/fusion/ModelConstraint.mbi(276:13-343:13)
        k = (ptrb[(srcoffset + i)] - pbase)

        kend = (ptrb[((srcoffset + i) + 1)] - pbase)

        if   (subj[perm[k]] < 0):
          # src/fusion/ModelConstraint.mbi(282:17-341:17)
          while ((k < kend) and (subj[perm[k]] < 0)):
            nbaraijsubi[l] = int(subi[(srcoffset + i)])
            nbaraijsubj[l] = (1 - subj[perm[k]])
            kbase = k

            # src/fusion/ModelConstraint.mbi(288:19-291:24)
            while (((k < kend) and (subj[perm[k]] < 0)) and (subj[perm[k]] == subj[perm[kbase]])):
              k += 1



            numbaraijnumnz = 1

            if   ((k - kbase) > 1):
              ( CommonTools._argQsort__3L_3I_3ILL (perm,subk,subl,long(kbase),long((k - kbase))) )
              numaijsymmatnz = 1

              # src/fusion/ModelConstraint.mbi(305:21-311:30)
              for z in xrange(1l,(k - kbase)):
                if   ((subk[perm[((k + z) - 1)]] != subk[perm[(k + z)]]) or (subl[perm[((k + z) - 1)]] != subl[perm[(k + z)]])):
                  numaijsymmatnz += 1
              aijsubk = ([ 0 for _autovar_160 in xrange(numaijsymmatnz) ])
              aijsubl = ([ 0 for _autovar_161 in xrange(numaijsymmatnz) ])
              aijcof = ([ 0.0 for _autovar_162 in xrange(numaijsymmatnz) ])
              aijsubk[0] = subk[perm[0]]
              aijsubl[0] = subl[perm[0]]
              aijcof[0] = cof[perm[0]]
              kp = 0

              # src/fusion/ModelConstraint.mbi(318:21-329:21)
              for z in xrange(1l,(k - kbase)):
                # { @ src/fusion/ModelConstraint.mbi(319:21-329:21)
                if   ((aijsubk[perm[((k + z) - 1)]] != aijsubk[perm[(k + z)]]) or (aijsubl[perm[((k + z) - 1)]] != aijsubl[perm[(k + z)]])):
                  kp += 1
                  aijsubk[kp] = subk[perm[(k + z)]]
                  aijsubl[kp] = subl[perm[(k + z)]]
                aijcof[kp] = (aijcof[kp] + cof[perm[(k + z)]])
                # } @ src/fusion/ModelConstraint.mbi(319:21-329:21)
            else:
              aijsubk = ([ subk[perm[kbase]]])
              aijsubl = ([ subl[perm[kbase]]])
              aijcof = ([ cof[perm[kbase]]])
            idx = ( self._model._task_1append_1barmatrix_I_3I_3I_3F(( self._model._task_1barvardim_I(nbaraijsubj[k]) ),aijsubk,aijsubl,aijcof) )

            nbaraijidx[l] = idx
            l += 1
        # } @ src/fusion/ModelConstraint.mbi(276:13-343:13)
      # } @ src/fusion/ModelConstraint.mbi(272:11-344:11)
      # { @ src/fusion/ModelConstraint.mbi(347:11-426:11)
      numunique = 0

      # { @ src/fusion/ModelConstraint.mbi(349:13-369:13)
      kold = 0

      knew = 0

      # src/fusion/ModelConstraint.mbi(352:15-368:15)
      while ((kold < int(len(self.__barsubi))) and (knew < int(len(nbaraijsubi)))):
        if   ((self.__barsubi[kold] < nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] < nbaraijsubj[knew]))):
          kold += 1
        elif ((self.__barsubi[kold] > nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] > nbaraijsubj[knew]))):
          knew += 1
        else:
          kold += 1
          knew += 1
        numunique += 1
      # } @ src/fusion/ModelConstraint.mbi(349:13-369:13)
      oldbarsubi = self.__barsubi

      oldbarsubj = self.__barsubj

      oldbarmatidx = self.__barsymmatidx

      if   (numunique > int(len(self.__barsubi))):
        self.__barsubi = ([ 0 for _autovar_163 in xrange(numunique) ])
        self.__barsubj = ([ 0 for _autovar_164 in xrange(numunique) ])
        self.__barsymmatidx = ([ 0 for _autovar_165 in xrange(numunique) ])
      # { @ src/fusion/ModelConstraint.mbi(382:13-425:13)
      kold = 0

      knew = 0

      i = 0

      # src/fusion/ModelConstraint.mbi(384:15-424:15)
      while ((kold < int(len(self.__barsubi))) and (knew < int(len(nbaraijsubi)))):
        if   ((self.__barsubi[kold] < nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] < nbaraijsubj[knew]))):
          self.__barsubi[i] = oldbarsubi[kold]
          self.__barsubj[i] = oldbarsubj[kold]
          self.__barsymmatidx[i] = oldbarmatidx[kold]
          kold += 1
        elif ((self.__barsubi[kold] > nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] > nbaraijsubj[knew]))):
          self.__barsubi[i] = nbaraijsubi[knew]
          self.__barsubj[i] = nbaraijsubj[knew]
          self.__barsymmatidx[i] = ([ nbaraijidx[knew]])
          ( self._model._task_1putbaraij_II_3I(self.__barsubi[i],self.__barsubj[i],self.__barsymmatidx[i]) )
          knew += 1
        else:
          self.__barsubi[i] = nbaraijsubi[knew]
          self.__barsubj[i] = nbaraijsubj[knew]
          self.__barsymmatidx[i] = ([ 0 for _autovar_166 in xrange((int(len(oldbarmatidx[kold])) + 1)) ])
          # src/fusion/ModelConstraint.mbi(414:19-415:63)
          for j in xrange(0,int(len(oldbarmatidx[kold]))):
            self.__barsymmatidx[i][j] = oldbarmatidx[kold][j]
          self.__barsymmatidx[i][int(len(oldbarmatidx[kold]))] = nbaraijidx[knew]
          ( self._model._task_1putbaraij_II_3I(self.__barsubi[i],self.__barsubj[i],self.__barsymmatidx[i]) )
          kold += 1
          knew += 1
        i += 1
      # } @ src/fusion/ModelConstraint.mbi(382:13-425:13)
      # } @ src/fusion/ModelConstraint.mbi(347:11-426:11)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/ConicConstraint.mbi(19:12-228:5)
class ConicConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 16:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[12]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[13]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[14]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[15]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int32],int,int,int,int,int,[int64],[int32],[double],[double],[int32],[int32],[[int32]])")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    self.__first_slack = first_slack_
    self.__last_slack = last_slack_
    self.__first = firstcone_
    self.__last = (firstcone_ + numcone_)
    self.__conesize = conesize_
    self.__coneidx = firstcone_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__first_slack = None

    #self.__last_slack = None

    #self.__first = None

    #self.__last = None

    #self.__conesize = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_dual_1values__3I_3II_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],int): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(73:18-104:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int32],[int32],int,[double])")
  def _dual_1values__3I_3II_3F(self,first__,last__,offset,tgt):
    if   ((int(len(first__)) != 1) or (int(len(last__)) != 1)):
      raise mosek.fusion.SliceError("Invalid slice dimensions")
    first_ = first__[0]

    last_ = last__[0]

    if   ((last_ - first_) > (int(len(tgt)) - offset)):
      raise mosek.fusion.SliceError("Wrong target array length")
    elif ((last_ < first_) or (last_ > (self.__last_slack - self.__first_slack))):
      raise mosek.fusion.SliceError("Slice indexes out of bounds")

    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )
    # src/fusion/ConicConstraint.mbi(100:11-103:11)
    i = 0

    while (i < (last_ - first_)):
      tgt[(i + offset)] = snx[((first_ + i) + self.__first_slack)]
      i += 1
  @staticmethod
  def _matchargs_dual__3IIII_3F(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(107:18-128:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int32],int,int,int,[double])")
  def _dual__3IIII_3F(self,idxs,first_,last_,offset,tgt):
    if   ((last_ - first_) > (int(len(tgt)) - offset)):
      raise mosek.fusion.SliceError("Wrong target array length")
    elif ((last_ < first_) or (last_ >= int(len(idxs)))):
      raise mosek.fusion.SliceError("Slice indexes out of bounds")
    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(124:11-127:11)
    i = 0

    while (i < (last_ - first_)):
      tgt[(i + offset)] = snx[(self.__first_slack + idxs[(first_ + i)])]
      i += 1
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(135:18-154:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    boundval = ([ 0.0 for _autovar_167 in xrange(num) ])
    idxs = ([ 0 for _autovar_168 in xrange(num) ])

    # src/fusion/ConicConstraint.mbi(147:9-148:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/ConicConstraint.mbi(150:9-151:59)
    for i in xrange(0,int(len(boundval))):
      boundval[i] = (- bfix[(subi[(srcoffset + i)] - subibase)])
    ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(161:18-169:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(167:9-168:62)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[(long(self.__first_slack) + idxs[i])]
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(172:18-192:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(186:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicConstraint.mbi(187:9-191:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicConstraint.mbi(188:9-191:9)
      target[(i + offset)] = xx[(long(self.__first_slack) + ( cnt._get_() ))]
      ( cnt._inc_() )
      # } @ src/fusion/ConicConstraint.mbi(188:9-191:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(198:18-206:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(204:9-205:62)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[(long(self.__first_slack) + idxs[i])]
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(209:18-227:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(221:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicConstraint.mbi(222:9-226:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicConstraint.mbi(223:9-226:9)
      target[(i + offset)] = xx[(long(self.__first_slack) + ( cnt._get_() ))]
      ( cnt._inc_() )
      # } @ src/fusion/ConicConstraint.mbi(223:9-226:9)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/SemidefiniteConstraint.mbi(13:12-218:5)
class PSDConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 14:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[12]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[13]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int32],int,int,int,[int64],[int32],[double],[double],[int32],[int32],[[int32]])")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    self.__coneidx = firstcone_
    self.__conesize = conesize_
    self.__numcones = numcone_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__conesize = None

    #self.__numcones = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(57:18-76:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(64:9-75:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteConstraint.mbi(65:9-75:9)
      k = ((idxs[p] / blocksize) + self.__coneidx)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[k][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[k][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(65:9-75:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(80:18-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    ii = ([ 0 for _autovar_169 in xrange(n) ])

    st = ([ 0l for _autovar_170 in xrange(n) ])

    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(94:9-41)
    for i in xrange(0,n):
      st[i] = start
    # src/fusion/SemidefiniteConstraint.mbi(95:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteConstraint.mbi(96:9-123:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteConstraint.mbi(97:9-123:9)
      # { @ src/fusion/SemidefiniteConstraint.mbi(98:11-108:11)
      k = (st[0] / blocksize)

      lidx = (st[0] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(98:11-108:11)
      # { @ src/fusion/SemidefiniteConstraint.mbi(110:11-122:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      l = 0

      # src/fusion/SemidefiniteConstraint.mbi(114:13-118:13)
      l = 0
      while ((l < (n - 1)) and (ii[l] == nsize[l])):
        ii[l] = 0
        ii[(l + 1)] += 1
        st[(l + 1)] = (st[(l + 1)] + strides[((n - 2) - l)])
        l += 1
      # src/fusion/SemidefiniteConstraint.mbi(120:13-121:28)
      for k in xrange(0,l):
        st[k] = st[l]
      # } @ src/fusion/SemidefiniteConstraint.mbi(110:11-122:11)
      # } @ src/fusion/SemidefiniteConstraint.mbi(97:9-123:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(129:18-148:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(136:9-147:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteConstraint.mbi(137:9-147:9)
      k = ((idxs[p] / blocksize) + self.__coneidx)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[k][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[k][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(137:9-147:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(151:18-195:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    ii = ([ 0 for _autovar_171 in xrange(n) ])

    st = ([ 0l for _autovar_172 in xrange(n) ])

    barx = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(165:9-41)
    for i in xrange(0,n):
      st[i] = start
    # src/fusion/SemidefiniteConstraint.mbi(166:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteConstraint.mbi(167:9-194:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteConstraint.mbi(168:9-194:9)
      # { @ src/fusion/SemidefiniteConstraint.mbi(169:11-179:11)
      k = (st[0] / blocksize)

      lidx = (st[0] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(169:11-179:11)
      # { @ src/fusion/SemidefiniteConstraint.mbi(181:11-193:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      l = 0

      # src/fusion/SemidefiniteConstraint.mbi(185:13-189:13)
      l = 0
      while ((l < (n - 1)) and (ii[l] == nsize[l])):
        ii[l] = 0
        ii[(l + 1)] += 1
        st[(l + 1)] = (st[(l + 1)] + strides[((n - 2) - l)])
        l += 1
      # src/fusion/SemidefiniteConstraint.mbi(191:13-192:28)
      for k in xrange(0,l):
        st[k] = st[l]
      # } @ src/fusion/SemidefiniteConstraint.mbi(181:11-193:11)
      # } @ src/fusion/SemidefiniteConstraint.mbi(168:9-194:9)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(198:18-217:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    boundval = ([ 0.0 for _autovar_173 in xrange(num) ])
    idxs = ([ 0 for _autovar_174 in xrange(num) ])

    # src/fusion/SemidefiniteConstraint.mbi(210:9-211:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/SemidefiniteConstraint.mbi(213:9-214:59)
    for i in xrange(0,int(len(boundval))):
      boundval[i] = (- bfix[(subi[(srcoffset + i)] - subibase)])
    ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/RangedConstraint.mbi(19:12-369:5)
class RangedConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(args):
    if len(args) != 9:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int32],[int64],[int32],[double],[double])")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,None,None,None)
    self.__dom = dom_
    self.__idxmap = None
  def __init__(self,*args):
    #self.__dom = None

    #self.__idxmap = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(*args)
  @staticmethod
  def _matchargs_lowerBoundCon_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(56:15-65:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lowerBoundCon()")
  def _lowerBoundCon_(self):
    strides = ([ 0l for _autovar_175 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedConstraint.mbi(59:9-62:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i -= 1
    return mosek.fusion.BoundInterfaceConstraint(self,self.shape,0l,strides,True)
  @staticmethod
  def _matchargs_upperBoundCon_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(71:15-79:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("upperBoundCon()")
  def _upperBoundCon_(self):
    strides = ([ 0l for _autovar_176 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedConstraint.mbi(74:9-77:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i -= 1
    return mosek.fusion.BoundInterfaceConstraint(self,self.shape,0l,strides,False)
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FIII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(83:18-112:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([int64],[int64],[int32],[int32],[int32],[double],[double],int,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FIII(self,esubi,eptrb,esubj,esubk,esubl,ecof,ebfix,subibase,srcoffset,num):
    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FIII(esubi,eptrb,esubj,esubk,esubl,ecof,ebfix,subibase,srcoffset,num) )
    if   (ebfix != None):
      nrows = self.__dom._shape._size

      real_bl = ([ 0.0 for _autovar_177 in xrange(nrows) ])

      real_bu = ([ 0.0 for _autovar_178 in xrange(nrows) ])

      idxs = ([ 0 for _autovar_179 in xrange(num) ])

      # src/fusion/RangedConstraint.mbi(104:11-109:11)
      for i in xrange(0,num):
        # { @ src/fusion/RangedConstraint.mbi(105:11-109:11)
        real_bl[i] = (( self.__dom._get_1lb_1item_L(esubi[i]) ) - self._cache.bfix[i])
        real_bu[i] = (( self.__dom._get_1ub_1item_L(esubi[i]) ) - self._cache.bfix[i])
        idxs[i] = self._nativeindexes[esubi[i]]
        # } @ src/fusion/RangedConstraint.mbi(105:11-109:11)
      ( self._model._task_1con_1putboundlist_1ra__3I_3F_3F(idxs,real_bl,real_bu) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(125:18-140:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(132:11-133:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(135:11-139:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(143:18-175:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(155:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(158:11-162:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(159:11-162:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(159:11-162:11)
    else:
      # src/fusion/RangedConstraint.mbi(166:11-173:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(167:11-173:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(167:11-173:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(180:18-195:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(187:11-188:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(190:11-194:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(198:18-230:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(210:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(213:11-217:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(214:11-217:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(214:11-217:11)
    else:
      # src/fusion/RangedConstraint.mbi(221:11-228:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(222:11-228:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(222:11-228:11)
  @staticmethod
  def _matchargs_dual_1l__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(237:18-252:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l([int64],int,[double])")
  def _dual_1l__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1slc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(244:11-245:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(247:11-251:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1l_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(255:18-287:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l(long,[int32],[int64],int,[double])")
  def _dual_1l_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1slc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(267:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(270:11-274:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(271:11-274:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(271:11-274:11)
    else:
      # src/fusion/RangedConstraint.mbi(278:11-285:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(279:11-285:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(279:11-285:11)
  @staticmethod
  def _matchargs_dual_1u__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(293:18-308:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u([int64],int,[double])")
  def _dual_1u__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1suc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(300:11-301:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(303:11-307:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1u_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(311:18-343:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u(long,[int32],[int64],int,[double])")
  def _dual_1u_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1suc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(323:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(326:11-330:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(327:11-330:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(327:11-330:11)
    else:
      # src/fusion/RangedConstraint.mbi(334:11-341:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(335:11-341:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(335:11-341:11)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(346:18-367:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    boundvallo = ([ 0.0 for _autovar_180 in xrange(num) ])

    boundvalup = ([ 0.0 for _autovar_181 in xrange(num) ])

    idxs = ([ 0 for _autovar_182 in xrange(num) ])

    # src/fusion/RangedConstraint.mbi(357:9-358:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/RangedConstraint.mbi(360:9-364:9)
    for i in xrange(0,int(len(boundvallo))):
      # { @ src/fusion/RangedConstraint.mbi(361:9-364:9)
      boundvallo[i] = (( self.__dom._get_1lb_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      boundvalup[i] = (( self.__dom._get_1ub_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      # } @ src/fusion/RangedConstraint.mbi(361:9-364:9)
    ( self._model._task_1con_1putboundlist_1ra__3I_3F_3F(idxs,boundvallo,boundvalup) )
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    elif ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int32],[int32])"),(2,"\tslice(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def lowerBoundCon(self,*args):
    if   RangedConstraint._matchargs_lowerBoundCon_(args):
      return RangedConstraint._lowerBoundCon_(self,*args)
    else:
      argtypestr = "lowerBoundCon(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundCon()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def upperBoundCon(self,*args):
    if   RangedConstraint._matchargs_upperBoundCon_(args):
      return RangedConstraint._upperBoundCon_(self,*args)
    else:
      argtypestr = "upperBoundCon(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundCon()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/LinearConstraint.mbi(24:12-225:5)
class LinearConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 12:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int32],[int64],[int32],[double],[double],[int32],[int32],[[int32]])")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    self.__dom = dom_
    self.__idxmap = None
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__dom = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(70:18-87:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([int64],int,[double])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(77:11-79:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache_bfix[idxs[i]])
    else:
      # src/fusion/LinearConstraint.mbi(81:11-86:59)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache_bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(90:18-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int32],[int64],int,[double])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearConstraint.mbi(103:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(107:11-111:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(108:11-111:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache_bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(108:11-111:11)
    else:
      # src/fusion/LinearConstraint.mbi(115:11-122:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(116:11-122:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache_bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(116:11-122:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(133:18-148:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int64],int,[double])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(140:11-141:58)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self._nativeindexes[idxs[i]]]
    else:
      # src/fusion/LinearConstraint.mbi(143:11-147:59)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(151:18-183:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int32],[int64],int,[double])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearConstraint.mbi(163:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(166:11-170:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(167:11-170:11)
        target[(i + offset)] = xx[self._nativeindexes[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(167:11-170:11)
    else:
      # src/fusion/LinearConstraint.mbi(174:11-181:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(175:11-181:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          target[i] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(175:11-181:11)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(186:18-224:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([int64],[double],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    if   (self.__dom._key == RelationKey.IsFree):
      pass
    else:
      boundval = ([ 0.0 for _autovar_183 in xrange(num) ])
      idxs = ([ 0 for _autovar_184 in xrange(num) ])

      # src/fusion/LinearConstraint.mbi(204:11-205:64)
      for i in xrange(0,num):
        idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
      # src/fusion/LinearConstraint.mbi(207:11-208:106)
      for i in xrange(0,int(len(boundval))):
        boundval[i] = (( self.__dom._get_1rhs_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      if   (self.__dom._key == RelationKey.EqualsTo):
        ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
      elif (self.__dom._key == RelationKey.LessThan):
        ( self._model._task_1con_1putboundlist_1up__3I_3F(idxs,boundval) )
      elif (self.__dom._key == RelationKey.GreaterThan):
        ( self._model._task_1con_1putboundlist_1up__3I_3F(idxs,boundval) )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int32])"),(1,"\tindex(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int32],[int32])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int32],[int32])"),(2,"\tlevel(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(13:12-17:5)
class FusionRuntimeException(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg_):
    Exception.__init__(self,msg_)
    self.__msg = msg_
  def __init__(self,*args):
    #self.__msg = None

    self.__constructor_S(*args)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Errors.mbi(17:15-16:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    return self.__msg
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(67:12-70:5)
class IndexError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(29:12-35:5)
class ExpressionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(186:12-192:5)
class SparseFormatError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(115:12-121:5)
class ModelError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(156:12-167:5)
class SliceError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__()")
  def __constructor_(self):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,"Invalid slice range")
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(22:12-25:5)
class IOError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(84:12-87:5)
class LengthError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(74:12-76:5)
class RangeError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(96:12-99:5)
class DimensionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(49:12-55:5)
class ValueConversionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(125:12-131:5)
class NameError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(146:12-152:5)
class SetDefinitionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(135:12-141:5)
class OptimizeError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(60:12-63:5)
class DomainError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(106:12-109:5)
class MatrixError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(39:12-45:5)
class ParameterError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Expression.mbi(12:12-129:5)
class Expression:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,m,s):
    self._model = m
    self._shape = s
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable,mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(self,v,s):
    if   (v == None):
      self._model = None
    else:
      self._model = v._model
    self._shape = s
  def __init__(self,*args):
    #self._protected_model = None

    #self._protected_shape = None

    if   self._matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
    elif self._matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_getShape_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(26:15-25:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getShape()")
  def _getShape_(self):
    return self._shape
  @staticmethod
  def _matchargs_getModel_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(40:15-41:24)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getModel()")
  def _getModel_(self):
    return self._model
  @staticmethod
  def _matchargs_eval_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(49:15-50:10)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("eval()")
  def _eval_(self):
    pass
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(61:15-62:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    pass
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(73:15-74:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    pass
  @staticmethod
  def _matchargs_inplaceMul_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/Expression.mbi(84:15-85:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceMul(float)")
  def _inplaceMul_F(self,rhs):
    pass
  @staticmethod
  def _matchargs_inplaceElmMul__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expression.mbi(97:15-98:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceElmMul([double])")
  def _inplaceElmMul__3F(self,rhs):
    pass
  @staticmethod
  def _matchargs_inplaceNeg_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(108:15-109:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceNeg()")
  def _inplaceNeg_(self):
    pass
  @staticmethod
  def _matchargs_neg_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(117:15-116:49)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("neg()")
  def _neg_(self):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(123:15-128:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("Expression(size=") )
    ( sb._a_L(( self._size_() )) )
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @_cliptrace
  def inplaceNeg(self,*args):
    if   Expression._matchargs_inplaceNeg_(args):
      return Expression._inplaceNeg_(self,*args)
    else:
      argtypestr = "inplaceNeg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinplaceNeg()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inplaceMul(self,*args):
    if   Expression._matchargs_inplaceMul_F(args):
      return Expression._inplaceMul_F(self,*args)
    else:
      argtypestr = "inplaceMul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinplaceMul(float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getShape(self,*args):
    if   Expression._matchargs_getShape_(args):
      return Expression._getShape_(self,*args)
    else:
      argtypestr = "getShape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetShape()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Expression._matchargs_toString_(args):
      return Expression._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inplaceElmMul(self,*args):
    if   Expression._matchargs_inplaceElmMul__3F(args):
      return Expression._inplaceElmMul__3F(self,*args)
    else:
      argtypestr = "inplaceElmMul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinplaceElmMul([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def eval(self,*args):
    if   Expression._matchargs_eval_(args):
      return Expression._eval_(self,*args)
    else:
      argtypestr = "eval(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\teval()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def neg(self,*args):
    if   Expression._matchargs_neg_(args):
      return Expression._neg_(self,*args)
    else:
      argtypestr = "neg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tneg()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getModel(self,*args):
    if   Expression._matchargs_getModel_(args):
      return Expression._getModel_(self,*args)
    else:
      argtypestr = "getModel(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetModel()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Expression._matchargs_numNonzeros_(args):
      return Expression._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Expression._matchargs_size_(args):
      return Expression._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Expr.mbi(120:12-5186:5)
class Expr(Expression):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Expression)")
  def __constructor_Omosek_fusion_Expression_2(self,e):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,e._model,e._shape)
    fe = ( e._eval_() )

    self.__ptrb = fe.ptrb
    self.__subj = fe.subj
    self.__x = fe.x
    self.__cof_v = fe.cof
    self.__bfix = fe.bfix
    self.__inst = fe.inst
  @staticmethod
  def _matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[7],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int64],mosek.fusion.Variable,[int64],[double],[double],mosek.fusion.Set,[int64],int)")
  def __constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(self,ptrb_,v,subj_,cof_,bfix_,shape_,inst_,unchecked_):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(self,v,shape_)
    self.__x = v
    self.__ptrb = ptrb_
    self.__subj = subj_
    self.__cof_v = cof_
    self.__bfix = bfix_
    if   (shape_ == None):
      self._shape = mosek.fusion.IntSet((int(len(ptrb_)) - 1))
    else:
      self._shape = shape_
    self.__inst = inst_
  @staticmethod
  def _matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int64],mosek.fusion.Variable,[int64],[double],[double],mosek.fusion.Set,[int64])")
  def __constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(self,ptrb_,v,subj_,cof_,bfix_,shape_,inst_):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( Expr.__model_1from_Omosek_fusion_Variable_2 (v) ),shape_)
    self.__x = v
    exprnume = (int(len(ptrb_)) - 1)

    numelm = ptrb_[(int(len(ptrb_)) - 1)]

    numvar = 0l

    if   (v != None):
      numvar = v.shape._size
    if   (int(len(ptrb_)) < 1):
      raise mosek.fusion.ExpressionError("Array 'ptrb' in expression is too short")
    if   (numelm > int(len(subj_))):
      raise mosek.fusion.ExpressionError("Array 'subj' in expression is too short")
    if   (numelm > int(len(cof_))):
      raise mosek.fusion.ExpressionError("Array 'cof' in expression is too short")
    if   ((bfix_ != None) and (exprnume != int(len(bfix_)))):
      raise mosek.fusion.ExpressionError("Array 'bfix' in expression has wrong length")
    if   (shape_ != None):
      if   (inst_ != None):
        self.__inst = inst_
        if   (int(len(self.__inst)) != (int(len(ptrb_)) - 1)):
          raise mosek.fusion.ExpressionError("Array 'inst' in expression has wrong length")
        if   (int(len(self.__inst)) > 0):
          if   ((self.__inst[0] < 0) or (self.__inst[0] >= shape_._size)):
            raise mosek.fusion.ExpressionError("Array 'inst' contains an invalid index")
          # src/fusion/Expr.mbi(290:15-296:15)
          i = 1

          while (i < int(len(inst_))):
            if   ((self.__inst[i] < 0) or (self.__inst[i] >= shape_._size)):
              raise mosek.fusion.ExpressionError("Array 'inst' contains an invalid index")
            elif (self.__inst[i] <= self.__inst[(i - 1)]):
              raise mosek.fusion.ExpressionError("Array 'inst' is not correctly ordered")
            i += 1
      else:
        self.__inst = None
        if   (shape_._size != (long(len(ptrb_)) - 1l)):
          raise mosek.fusion.ExpressionError("Array 'ptrb' in expression has wrong length")
    else:
      self.__inst = None
      self._shape = mosek.fusion.IntSet((int(len(ptrb_)) - 1))
    # src/fusion/Expr.mbi(313:9-317:9)
    i = 0

    while (i < exprnume):
      if   (ptrb_[i] > ptrb_[(i + 1)]):
        raise mosek.fusion.ExpressionError("Invalid 'ptrb' argument in expression")
      i += 1
    # src/fusion/Expr.mbi(319:9-325:9)
    i = 0l

    while (i < numelm):
      if   (subj_[i] > numvar):
        raise mosek.fusion.ExpressionError("Invalid 'subj' argument in expression")
      i += 1
    self.__ptrb = ( Utils.Tools._arraycopy__3L (ptrb_) )
    self.__subj = ([ 0l for _autovar_185 in xrange(numelm) ])
    ( Utils.Tools._arraycopy__3LL_3LLL (subj_,0l,self.__subj,0l,numelm) )
    self.__cof_v = ([ 0.0 for _autovar_186 in xrange(numelm) ])
    ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,self.__cof_v,0l,numelm) )
    self.__bfix = None
    if   (bfix_ != None):
      self.__bfix = ( Utils.Tools._arraycopy__3F (bfix_) )
    else:
      self.__bfix = None
  def __init__(self,*args):
    #self.__bfix = None

    #self.__ptrb = None

    #self.__subj = None

    #self.__x = None

    #self.__cof_v = None

    #self.__inst = None

    if   self._matchargs_constructor_Omosek_fusion_Expression_2(args):
      self.__constructor_Omosek_fusion_Expression_2(*args)
    elif self._matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(args):
      self.__constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(*args)
    elif self._matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(args):
      self.__constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_model_1from_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(208:16-207:110)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from(mosek.fusion.Variable)")
  def __model_1from_Omosek_fusion_Variable_2(v):
    if   (v == None):
      return None
    else:
      return v._model
  @staticmethod
  def _matchargs_stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(343:16-365:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack_x_vars(mosek.fusion.Variable,mosek.fusion.Variable)")
  def __stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(x1,x2):

    if   (x1 != None):
      if   (x2 != None):
        x = mosek.fusion.CompoundVariable(([ ( x1._flatten_() ),( x2._flatten_() )]),0)
      else:
        x = x1
    else:
      if   (x2 != None):
        x = x2
      else:
        x = None
    return x
  @staticmethod
  def _matchargs_addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],bool): return False
    return True
  # origin: src/fusion/Expr.mbi(371:16-755:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("addsub_op(mosek.fusion.Expression,mosek.fusion.Expression,bool)")
  def __addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B(lhs_,rhs_,plus):
    if   (((lhs_._model != None) and (rhs_._model != None)) and (lhs_._model != rhs_._model)):
      raise mosek.fusion.LengthError("Operands belong to different models")
    if   ((lhs_._shape != None) or (rhs_._shape != None)):
      if   ((rhs_._shape == None) and (( lhs_._shape._realnd_() ) != 1)):
        raise mosek.fusion.LengthError("Operand shapes do not match")
      elif ((lhs_._shape == None) and (( rhs_._shape._realnd_() ) != 1)):
        raise mosek.fusion.LengthError("Operand shapes do not match")
      elif (not ( lhs_._shape._compare_Omosek_fusion_Set_2(rhs_._shape) )):
        raise mosek.fusion.LengthError("Operand shapes do not match")
    elif (( lhs_._size_() ) != ( rhs_._size_() )):
      raise mosek.fusion.LengthError("Operand dimensions do not match")
    lhs = ( lhs_._eval_() )

    rhs = ( rhs_._eval_() )


    if   (lhs.inst == None):
      num = (int(len(lhs.ptrb)) - 1)
    elif (rhs.inst == None):
      num = (int(len(rhs.ptrb)) - 1)
    else:
      num = 0
      i0 = 0

      i1 = 0

      # src/fusion/Expr.mbi(407:11-412:11)
      while ((i0 < int(len(lhs.inst))) and (i1 < int(len(rhs.inst)))):
        if   (lhs.inst[i0] < rhs.inst[i1]):
          i0 += 1
        elif (lhs.inst[i0] > rhs.inst[i1]):
          i1 += 1
        else:
          i0 += 1
          i1 += 1
        num += 1
      num = ((num + (int(len(lhs.inst)) - i0)) + (int(len(rhs.inst)) - i1))
    nnz = 0l

    if   (lhs.cof != None):
      nnz = (nnz + long(len(lhs.cof)))
    if   (rhs.cof != None):
      nnz = (nnz + long(len(rhs.cof)))
    subj = ([ 0l for _autovar_187 in xrange(nnz) ])

    cof = ([ 0.0 for _autovar_188 in xrange(nnz) ])

    ptrb = ([ 0l for _autovar_189 in xrange((num + 1)) ])

    bfix = None

    x = ( Expr.__stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2 (lhs.x,rhs.x) )

    inst = None

    rhsnvar = 0l

    lhsnvar = 0l

    if   (lhs.x != None):
      lhsnvar = ( lhs.x._size_() )
    if   (rhs.x != None):
      rhsnvar = ( rhs.x._size_() )
    if   ((lhs.inst == None) or (rhs.inst == None)):
      if   (lhs.inst == None):
        # src/fusion/Expr.mbi(442:13-445:13)
        i = 0

        while (i < num):
          ptrb[i] = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])
          i += 1
      else:
        # src/fusion/Expr.mbi(449:13-452:13)
        i = 0

        while (i < int(len(lhs.inst))):
          ptrb[lhs.inst[i]] = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])
          i += 1
      if   (rhs.inst == None):
        # src/fusion/Expr.mbi(457:13-460:13)
        i = 0

        while (i < num):
          ptrb[i] = ((ptrb[i] + rhs.ptrb[(i + 1)]) - rhs.ptrb[i])
          i += 1
      else:
        # src/fusion/Expr.mbi(464:13-467:13)
        i = 0

        while (i < int(len(rhs.inst))):
          ptrb[rhs.inst[i]] = ((ptrb[rhs.inst[i]] + rhs.ptrb[(i + 1)]) - rhs.ptrb[i])
          i += 1
    else:
      i0 = 0

      i1 = 0

      i = 0

      # src/fusion/Expr.mbi(474:11-483:11)
      while ((i0 < int(len(lhs.inst))) and (i1 < int(len(rhs.inst)))):
        if   (lhs.inst[i0] < rhs.inst[i1]):
          ptrb[i] = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])
          i0 += 1
        elif (lhs.inst[i0] > rhs.inst[i1]):
          ptrb[i] = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])
          i1 += 1
        else:
          ptrb[i] = (((lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0]) + rhs.ptrb[(i1 + 1)]) - rhs.ptrb[i1])
          i0 += 1
          i1 += 1
        i += 1
      # src/fusion/Expr.mbi(484:11-487:11)
      while (i0 < int(len(lhs.inst))):
        ptrb[i] = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])
        i0 += 1
        i += 1
      # src/fusion/Expr.mbi(489:11-492:11)
      while (i1 < int(len(rhs.inst))):
        ptrb[i] = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i0])
        i1 += 1
        i += 1
    # { @ src/fusion/Expr.mbi(496:9-504:9)
    tmp = ptrb[0]

    ptrb[0] = 0l
    # src/fusion/Expr.mbi(498:11-503:11)
    i = 0

    while (i < num):
      tmp2 = ptrb[(i + 1)]

      ptrb[(i + 1)] = (ptrb[i] + tmp)
      tmp = tmp2
      i += 1
    # } @ src/fusion/Expr.mbi(496:9-504:9)
    if   ((lhs.bfix != None) or (rhs.bfix != None)):
      bfix = ([ 0.0 for _autovar_190 in xrange((int(len(ptrb)) - 1)) ])
    if   ((lhs.inst != None) and (rhs.inst != None)):
      inst = ([ 0l for _autovar_191 in xrange(num) ])
      i0 = 0

      l0 = int(len(lhs.inst))

      i1 = 0

      l1 = int(len(rhs.inst))


      if   (lhs.x != None):
        xoffset = lhs.x.shape._size
      else:
        xoffset = 0l
      # src/fusion/Expr.mbi(531:11-570:11)
      i = 0

      while (i < num):
        offset = ptrb[i]

        if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
          n = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])

          inst[i] = lhs.inst[i0]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i0],cof,offset,n) )
          i0 += 1
        elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
          n = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])

          inst[i] = rhs.inst[i1]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          # src/fusion/Expr.mbi(548:15-88)
          j = 0

          while (j < n):
            subj[(offset + j)] = (subj[(offset + j)] + xoffset)
            j += 1
          ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i1],cof,offset,n) )
          i1 += 1
        else:
          n = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])

          n2 = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])

          inst[i] = lhs.inst[i0]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i1],subj,(offset + n),n2) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i0],cof,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i1],cof,(offset + n),n2) )
          # src/fusion/Expr.mbi(562:15-92)
          j = 0

          while (j < n):
            subj[((offset + n) + j)] = (subj[((offset + n) + j)] + xoffset)
            j += 1
          if   (not plus):
            # src/fusion/Expr.mbi(566:17-84)
            j = 0

            while (j < n):
              cof[((offset + n) + j)] = (- cof[((offset + n) + j)])
              j += 1
          i1 += 1
          i0 += 1
        i += 1
      if   (lhs.bfix != None):
        i0 = 0
        i1 = 0
        # src/fusion/Expr.mbi(575:13-580:13)
        i = 0

        while (i < num):
          if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
            bfix[i] = lhs.bfix[i0]
            i0 += 1
          elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
            i1 += 1
          else:
            bfix[i] = lhs.bfix[i0]
            i1 += 1
            i0 += 1
          i += 1
      if   (rhs.bfix != None):
        i0 = 0
        i1 = 0
        if   plus:
          # src/fusion/Expr.mbi(587:15-592:15)
          i = 0

          while (i < num):
            if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
              i0 += 1
            elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
              bfix[i] = rhs.bfix[i1]
              i1 += 1
            else:
              bfix[i] = (bfix[i] + rhs.bfix[i1])
              i1 += 1
              i0 += 1
            i += 1
        else:
          # src/fusion/Expr.mbi(596:15-601:15)
          i = 0

          while (i < num):
            if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
              i0 += 1
            elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
              bfix[i] = (- rhs.bfix[i1])
              i1 += 1
            else:
              bfix[i] = (bfix[i] - rhs.bfix[i1])
              i1 += 1
              i0 += 1
            i += 1
    else:
      if   (lhs.inst == None):
        # src/fusion/Expr.mbi(610:13-617:13)
        i = 0

        while (i < num):
          n = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])

          offset = ptrb[i]

          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i],cof,offset,n) )
          ptrb[i] = (offset + n)
          i += 1
        if   (lhs.bfix != None):
          ( Utils.Tools._arraycopy__3FI_3FII (lhs.bfix,0,bfix,0,int(len(bfix))) )
      else:
        # src/fusion/Expr.mbi(626:13-635:13)
        i = 0

        while (i < int(len(lhs.inst))):
          n = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])

          tidx = lhs.inst[i]

          offset = ptrb[tidx]

          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i],cof,offset,n) )
          ptrb[tidx] = (offset + n)
          i += 1
        if   (lhs.bfix != None):
          # src/fusion/Expr.mbi(639:15-642:15)
          i = 0

          while (i < int(len(lhs.inst))):
            bfix[lhs.inst[i]] = lhs.bfix[i]
            i += 1
      xoffset = 0l

      if   (lhs.x != None):
        xoffset = lhs.x.shape._size
      if   plus:
        if   (rhs.inst == None):
          # src/fusion/Expr.mbi(653:15-663:15)
          i = 0

          while (i < num):
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            offset = ptrb[i]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(660:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            ptrb[i] = (offset + n)
            i += 1
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(667:17-670:17)
            i = 0

            while (i < int(len(rhs.bfix))):
              bfix[i] = (bfix[i] + rhs.bfix[i])
              i += 1
        else:
          # src/fusion/Expr.mbi(675:15-686:15)
          i = 0

          while (i < int(len(rhs.inst))):
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            tidx = rhs.inst[i]

            offset = ptrb[tidx]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(683:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            ptrb[tidx] = (offset + n)
            i += 1
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(689:17-692:17)
            i = 0

            while (i < int(len(lhs.inst))):
              bfix[rhs.inst[i]] = (bfix[rhs.inst[i]] + lhs.bfix[i])
              i += 1
      else:
        if   (rhs.inst == None):
          # src/fusion/Expr.mbi(700:15-710:15)
          for i in xrange(0,num):
            # { @ src/fusion/Expr.mbi(701:15-710:15)
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            offset = ptrb[i]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(707:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            # src/fusion/Expr.mbi(708:17-81)
            j = 0l

            while (j < n):
              cof[(j + offset)] = (- cof[(j + offset)])
              j += 1
            ptrb[i] = (offset + n)
            # } @ src/fusion/Expr.mbi(701:15-710:15)
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(714:17-715:50)
            for i in xrange(0,int(len(rhs.bfix))):
              bfix[i] = (bfix[i] - rhs.bfix[i])
        else:
          # src/fusion/Expr.mbi(720:15-732:15)
          for i in xrange(0,int(len(rhs.inst))):
            # { @ src/fusion/Expr.mbi(721:15-732:15)
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            tidx = rhs.inst[i]

            offset = ptrb[tidx]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(728:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            # src/fusion/Expr.mbi(729:17-81)
            j = 0l

            while (j < n):
              cof[(j + offset)] = (- cof[(j + offset)])
              j += 1
            ptrb[tidx] = (offset + n)
            # } @ src/fusion/Expr.mbi(721:15-732:15)
          if   (rhs.bfix != None):
            if   (lhs.bfix != None):
              # src/fusion/Expr.mbi(737:19-738:72)
              for i in xrange(0,int(len(rhs.inst))):
                bfix[rhs.inst[i]] = (bfix[rhs.inst[i]] - lhs.bfix[i])
            else:
              # src/fusion/Expr.mbi(742:19-743:58)
              for i in xrange(0,int(len(rhs.inst))):
                bfix[rhs.inst[i]] = bfix[rhs.inst[i]]
      # src/fusion/Expr.mbi(749:11-64)
      i = num

      while (i > 0):
        ptrb[i] = ptrb[(i - 1)]
        i -= 1
      ptrb[0] = 0l
    shape = lhs.shape

    return mosek.fusion.Expr(ptrb,x,subj,cof,bfix,lhs.shape,inst)
  @staticmethod
  def _matchargs_add__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(774:15-808:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("add([mosek.fusion.Variable])")
  def _add__3Omosek_fusion_Variable_2(vs):
    s = vs[0].shape

    nd = s.nd

    sz = s._size

    num = s._size

    # src/fusion/Expr.mbi(781:9-787:9)
    i = 1

    while (i < int(len(vs))):
      if   (not ( s._compare_Omosek_fusion_Set_2(vs[i].shape) )):
        raise mosek.fusion.DimensionError("Mismatching operand dimensions")
      i += 1
    nnz = (sz * int(len(vs)))

    ptrb = ( Utils.Tools._range_LLL (0l,(nnz + long(len(vs))),long(len(vs))) )

    v = ( Variable._vstack__3Omosek_fusion_Variable_2 (vs) )

    subj = ([ 0l for _autovar_192 in xrange(nnz) ])

    cof = ( Utils.Tools._ones_I (int(nnz)) )

    N = long(len(vs))

    k = 0

    # src/fusion/Expr.mbi(798:9-805:9)
    i = 0l

    while (i < sz):
      # src/fusion/Expr.mbi(800:11-804:11)
      j = 0l

      while (j < N):
        subj[k] = (i + (j * sz))
        k += 1
        j += 1
      i += 1
    return mosek.fusion.Expr(ptrb,v,subj,cof,None,s,None,1)
  @staticmethod
  def _matchargs_add__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(822:15-1116:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("add([mosek.fusion.Expression])")
  def _add__3Omosek_fusion_Expression_2(exps):
    sz = ( exps[0]._size_() )

    shp = exps[0]._shape

    fe = ([ None for _autovar_193 in xrange(int(len(exps))) ])

    nnz = 0l

    full = False

    hasbfix = False

    xoffset = ([ 0l for _autovar_194 in xrange(int(len(exps))) ])

    vs = ([ None for _autovar_195 in xrange(int(len(exps))) ])

    fe[0] = ( exps[0]._eval_() )
    # src/fusion/Expr.mbi(838:9-851:9)
    for i in xrange(0,int(len(exps))):
      # { @ src/fusion/Expr.mbi(839:9-851:9)
      fe[i] = ( exps[i]._eval_() )
      if   (not ( fe[i].shape._compare_Omosek_fusion_Set_2(fe[0].shape) )):
        raise mosek.fusion.DimensionError("Mismatching operand dimensions")
      vs[i] = fe[i].x
      if   (fe[i].bfix != None):
        hasbfix = True
      nnz = (nnz + fe[i].nnz)
      full = (full or (fe[i].inst == None))
      # } @ src/fusion/Expr.mbi(839:9-851:9)
    # src/fusion/Expr.mbi(853:9-84)
    for i in xrange(1,int(len(exps))):
      # { @ src/fusion/Expr.mbi(853:36-84)
      xoffset[i] = (xoffset[(i - 1)] + ( fe[(i - 1)].x._size_() ))
      # } @ src/fusion/Expr.mbi(853:36-84)
    shape = None

    inst = None

    if   (exps[0]._shape != None):
      shape = exps[0]._shape
    else:
      shape = mosek.fusion.IntSet(int(sz))

    if   (not full):
      totallen = 0

      b = 0

      # src/fusion/Expr.mbi(872:11-77)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(872:36-77)
        totallen = (totallen + int(len(fe[i].inst)))
        # } @ src/fusion/Expr.mbi(872:36-77)
      tempinst = ([ 0l for _autovar_196 in xrange(totallen) ])

      # src/fusion/Expr.mbi(874:11-878:11)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(875:11-878:11)
        ( Utils.Tools._arraycopy__3LI_3LII (fe[i].inst,0,tempinst,b,int(len(fe[i].inst))) )
        b = (b + int(len(fe[i].inst)))
        # } @ src/fusion/Expr.mbi(875:11-878:11)
      ( Utils.Tools._sort__3LII (tempinst,0,totallen) )
      num = 1
      # src/fusion/Expr.mbi(882:11-84)
      for i in xrange(1,totallen):
        # { @ src/fusion/Expr.mbi(882:38-84)
        if   (tempinst[(i - 1)] < tempinst[i]):
          num += 1
        # } @ src/fusion/Expr.mbi(882:38-84)
      if   (num == shape._size):
        full = True
      else:
        inst = ([ 0l for _autovar_197 in xrange(num) ])
        inst[0] = tempinst[0]
        j = 0

        # src/fusion/Expr.mbi(892:13-899:13)
        for i in xrange(0,totallen):
          # { @ src/fusion/Expr.mbi(893:13-899:13)
          if   (inst[j] != tempinst[i]):
            j += 1
            inst[j] = tempinst[i]
          # } @ src/fusion/Expr.mbi(893:13-899:13)
    else:
      num = int(shape._size)
    ptr = ([ 0l for _autovar_198 in xrange((num + 1)) ])

    bfix = None

    if   hasbfix:
      bfix = ([ 0.0 for _autovar_199 in xrange(num) ])
    if   (inst == None):
      # src/fusion/Expr.mbi(915:11-932:11)
      i = 0

      while (i < int(len(fe))):
        e = fe[i]

        if   (e.inst != None):
          # src/fusion/Expr.mbi(920:15-923:15)
          j = 0l

          while (j < long(len(e.inst))):
            ptr[(e.inst[j] + 1l)] = ((ptr[(e.inst[j] + 1l)] + e.ptrb[(j + 1l)]) - e.ptrb[j])
            j += 1
        else:
          # src/fusion/Expr.mbi(927:15-930:15)
          j = 0

          while (j < (int(len(e.ptrb)) - 1)):
            ptr[(j + 1)] = ((ptr[(j + 1)] + e.ptrb[(j + 1)]) - e.ptrb[j])
            j += 1
        i += 1
    else:
      # src/fusion/Expr.mbi(945:11-960:11)
      i = 0

      while (i < int(len(fe))):
        jj = 0

        # src/fusion/Expr.mbi(952:13-959:13)
        j = 0

        while ((j < int(len(inst))) and (jj < int(len(fe[i].inst)))):
          if   (fe[i].inst[jj] == inst[j]):
            ptr[(j + 1)] = ((ptr[(j + 1)] + fe[i].ptrb[(jj + 1)]) - fe[i].ptrb[jj])
            jj += 1
          j += 1
        i += 1
    # src/fusion/Expr.mbi(962:9-74)
    i = 1

    while (i < int(len(ptr))):
      ptr[i] = (ptr[i] + ptr[(i - 1)])
      i += 1
    if   (inst != None):
      pass
    subj = ([ 0l for _autovar_200 in xrange(nnz) ])

    cof = ([ 0.0 for _autovar_201 in xrange(nnz) ])

    if   (inst == None):
      # src/fusion/Expr.mbi(982:11-1052:11)
      i = 0

      while (i < int(len(fe))):
        e = fe[i]

        if   (e.inst == None):
          # src/fusion/Expr.mbi(993:15-1007:15)
          j = 0

          while (j < (int(len(e.ptrb)) - 1)):
            b = ptr[j]

            n = (e.ptrb[(j + 1)] - e.ptrb[j])

            ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[j],cof,b,n) )
            # src/fusion/Expr.mbi(1001:17-1005:17)
            k = 0l

            while (k < n):
              subj[(b + k)] = (e.subj[(e.ptrb[j] + k)] + xoffset[i])
              k += 1
            ptr[j] = (ptr[j] + n)
            j += 1
          if   (hasbfix and (e.bfix != None)):
            # src/fusion/Expr.mbi(1011:17-1014:17)
            j = 0

            while (j < int(len(e.inst))):
              bfix[j] = (bfix[j] + e.bfix[j])
              j += 1
        else:
          # src/fusion/Expr.mbi(1028:15-1041:15)
          j = 0

          while (j < int(len(e.inst))):
            idx = e.inst[j]

            n = (e.ptrb[(j + 1)] - e.ptrb[j])

            b = ptr[idx]

            ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[j],cof,ptr[idx],n) )
            # src/fusion/Expr.mbi(1034:17-1037:17)
            k = 0l

            while (k < n):
              subj[(b + k)] = (e.subj[(e.ptrb[j] + k)] + xoffset[i])
              k += 1
            ptr[idx] = (ptr[idx] + n)
            j += 1
          if   (hasbfix and (e.bfix != None)):
            # src/fusion/Expr.mbi(1045:17-1049:17)
            j = 0

            while (j < int(len(e.inst))):
              idx = e.inst[j]

              bfix[idx] = (bfix[idx] + e.bfix[j])
              j += 1
        i += 1
    else:
      # src/fusion/Expr.mbi(1058:11-1078:11)
      i = 0

      while (i < int(len(fe))):
        jj = 0

        # src/fusion/Expr.mbi(1061:13-1077:13)
        j = 0

        while ((j < int(len(inst))) and (jj < int(len(fe[i].inst)))):
          if   (fe[i].inst[jj] == inst[j]):
            b = fe[i].ptrb[jj]

            N = (fe[i].ptrb[(jj + 1)] - b)

            ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,b,cof,ptr[j],N) )
            # src/fusion/Expr.mbi(1070:17-1073:17)
            k = 0

            while (k < N):
              subj[(ptr[j] + k)] = (fe[i].subj[(b + k)] + xoffset[i])
              k += 1
            ptr[j] = (ptr[j] + N)
            jj += 1
          j += 1
        i += 1
    # src/fusion/Expr.mbi(1110:9-60)
    i = num

    while (i > 0):
      ptr[i] = ptr[(i - 1)]
      i -= 1
    ptr[0] = 0l
    v = ( Variable._vstack__3Omosek_fusion_Variable_2 (vs) )

    return mosek.fusion.Expr(ptr,v,subj,cof,None,shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1125:15-1130:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1138:15-1143:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( rhs._asExpr_() ),True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1150:15-1155:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1162:15-1172:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(lhs,rhs):
    if   (not ( lhs.shape._compare_Omosek_fusion_Set_2(rhs.shape) )):
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( rhs._asExpr_() ),True) )
  @staticmethod
  def _matchargs_add__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1181:15-1200:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([double],mosek.fusion.Variable)")
  def _add__3FOmosek_fusion_Variable_2(lhs,rhs):
    if   (( rhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
    elif (( rhs.shape._dim_I(0) ) != int(len(lhs))):
      raise mosek.fusion.LengthError("Operands have mismatching lengths.")
    ptrb = ( Utils.Tools._range_LL (0l,(long(len(lhs)) + 1)) )

    subj = ( Utils.Tools._range_LL (0l,long(len(lhs))) )

    cof = ( Utils.Tools._ones_I (int(len(lhs))) )

    bfix = ( Utils.Tools._arraycopy__3F (lhs) )

    return mosek.fusion.Expr(ptrb,rhs,subj,cof,bfix,rhs.shape,None,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1208:15-1213:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,[double])")
  def _add_Omosek_fusion_Variable_2_3F(lhs,rhs):
    return ( Expr._add__3FOmosek_fusion_Variable_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_add__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1221:15-1226:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([double],mosek.fusion.Expression)")
  def _add__3FOmosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1234:15-1239:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,[double])")
  def _add_Omosek_fusion_Expression_2_3F(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( Expr._constTerm__3F (rhs) ),True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(1247:15-1264:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,float)")
  def _add_Omosek_fusion_Expression_2F(lhs,rhs):
    fe = ( lhs._eval_() )

    bfix = None

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI (rhs,(int(len(fe.ptrb)) - 1)) )
    else:
      bfix = ( Utils.Tools._arraycopy__3F (fe.bfix) )
      # src/fusion/Expr.mbi(1260:11-70)
      i = 0

      while (i < int(len(bfix))):
        bfix[i] = (bfix[i] + rhs)
        i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(1272:15-1282:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,float)")
  def _add_Omosek_fusion_Variable_2F(lhs,rhs):
    n = lhs.shape._size

    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(n + 1)) ),lhs,( Utils.Tools._range_LL (0l,n) ),( Utils.Tools._ones_I (int(n)) ),( Utils.Tools._makevector_FI (rhs,int(n)) ),lhs.shape,None,1)
  @staticmethod
  def _matchargs_add__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1291:15-1308:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([double],[double])")
  def _add__3F_3F(lhs,rhs):
    if   (int(len(lhs)) != int(len(rhs))):
      raise mosek.fusion.LengthError("Operand lengths do not match")
    r = ([ 0.0 for _autovar_202 in xrange(int(len(lhs))) ])

    # src/fusion/Expr.mbi(1299:9-57)
    for i in xrange(0,int(len(lhs))):
      r[i] = (lhs[i] + rhs[i])
    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,long(len(r))) ),None,([ 0l for _autovar_203 in xrange(0) ]),([ 0.0 for _autovar_204 in xrange(0) ]),r,mosek.fusion.IntSet(int(len(r))),None,1)
  @staticmethod
  def _matchargs_stack__3Omosek_fusion_Expression_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Expr.mbi(1312:18-1585:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack([mosek.fusion.Expression],int)")
  def _stack__3Omosek_fusion_Expression_2I(exprs,dim):
    if   (int(len(exprs)) == 1):
      return exprs[0]
    nd = (dim + 1)

    # src/fusion/Expr.mbi(1320:9-1325:14)
    for i in xrange(0,int(len(exprs))):
      if   (exprs[i]._shape.nd > nd):
        nd = exprs[i]._shape.nd
    fe = ([ None for _autovar_205 in xrange(int(len(exprs))) ])

    e0 = exprs[0]

    r_dims = ([ 0 for _autovar_206 in xrange(nd) ])

    is_dense = True

    has_bfix = False

    r = None

    if   (e0._shape.nd < dim):
      raise mosek.fusion.LengthError("Invalid stack dimension")
    numxs = 0

    # src/fusion/Expr.mbi(1335:9-1349:9)
    for i in xrange(0,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1336:9-1349:9)
      ei = exprs[i]

      # src/fusion/Expr.mbi(1340:11-1345:19)
      for j in xrange(0,ei._shape.nd):
        if   ((dim != j) and (( e0._shape._dim_I(j) ) != ( ei._shape._dim_I(j) ))):
          raise mosek.fusion.DimensionError("Mismatching dimensions")
      r_dims[dim] = (r_dims[dim] + ( ei._shape._dim_I(dim) ))
      fe[i] = ( exprs[i]._eval_() )
      is_dense = (is_dense and (fe[i].inst == None))
      has_bfix = (has_bfix or (fe[i].bfix != None))
      if   (fe[i].x != None):
        numxs += 1
      # } @ src/fusion/Expr.mbi(1336:9-1349:9)
    # src/fusion/Expr.mbi(1351:9-1356:14)
    for j in xrange(0,nd):
      if   (j != dim):
        r_dims[j] = ( e0._shape._dim_I(j) )
    r_shape = mosek.fusion.NDSet(r_dims)

    xs = ([ None for _autovar_207 in xrange(numxs) ])

    xofs = ([ 0l for _autovar_208 in xrange(int(len(exprs))) ])

    # { @ src/fusion/Expr.mbi(1359:9-1371:9)
    b = 0

    xb = 0l

    # src/fusion/Expr.mbi(1362:11-1370:11)
    for i in xrange(0,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1363:11-1370:11)
      xofs[i] = xb
      if   (fe[i].x != None):
        xs[b] = ( Variable._reshape_Omosek_fusion_Variable_2I (fe[i].x,int(( fe[i].x._size_() ))) )
        b += 1
        xb = (xb + ( fe[i].x._size_() ))
      # } @ src/fusion/Expr.mbi(1363:11-1370:11)
    # } @ src/fusion/Expr.mbi(1359:9-1371:9)
    nnz = fe[0].nnz

    nrows = (int(len(fe[0].ptrb)) - 1)

    bfix = None

    # src/fusion/Expr.mbi(1377:9-1381:9)
    for i in xrange(1,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1378:9-1381:9)
      nnz = (nnz + fe[i].nnz)
      nrows = ((nrows + int(len(fe[i].ptrb))) - 1)
      # } @ src/fusion/Expr.mbi(1378:9-1381:9)
    if   has_bfix:
      bfix = ([ 0.0 for _autovar_209 in xrange(nrows) ])
    if   (dim == 0):
      r_x = mosek.fusion.CompoundVariable(xs,0)

      ptrb = ([ 0l for _autovar_210 in xrange((nrows + 1)) ])

      subj = ([ 0l for _autovar_211 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_212 in xrange(nnz) ])

      inst = None

      if   (not is_dense):
        inst = ([ 0l for _autovar_213 in xrange(nrows) ])
      ptr = 0l

      ofs = 0l

      cofs = 0l

      # src/fusion/Expr.mbi(1403:11-1433:11)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(1404:11-1433:11)
        ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,0l,cof,ofs,fe[i].nnz) )
        if   (fe[i].bfix != None):
          ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,0l,bfix,ptr,long(len(fe[i].bfix))) )
        # src/fusion/Expr.mbi(1408:13-1409:52)
        for j in xrange(0,(int(len(fe[i].ptrb)) - 1)):
          ptrb[((ptr + j) + 1)] = (fe[i].ptrb[(j + 1)] + ofs)
        # src/fusion/Expr.mbi(1410:13-1411:52)
        for j in xrange(0l,fe[i].nnz):
          subj[(ofs + j)] = (xofs[i] + fe[i].subj[j])
        if   (not is_dense):
          if   (fe[i].inst == None):
            # src/fusion/Expr.mbi(1417:17-1418:41)
            for j in xrange(0,(int(len(fe[i].ptrb)) - 1)):
              inst[(ptr + j)] = (cofs + j)
            ptr = ((ptr + int(len(fe[i].ptrb))) - 1)
          else:
            # src/fusion/Expr.mbi(1423:17-1424:53)
            for j in xrange(0,int(len(fe[i].inst))):
              inst[(ptr + j)] = (cofs + fe[i].inst[j])
            ptr = (ptr + int(len(fe[i].inst)))
        else:
          ptr = ((ptr + int(len(fe[i].ptrb))) - 1)
        cofs = (cofs + fe[i].shape._size)
        ofs = (ofs + fe[i].nnz)
        # } @ src/fusion/Expr.mbi(1404:11-1433:11)
      r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
    else:
      r_x = mosek.fusion.CompoundVariable(xs,0)

      ptrb = ([ 0l for _autovar_214 in xrange((nrows + 1)) ])

      subj = ([ 0l for _autovar_215 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_216 in xrange(nnz) ])

      inst = None

      ptr = 0l

      ofs = 0l

      cofs = 0l

      npasses = 1

      # src/fusion/Expr.mbi(1462:11-1463:42)
      for i in xrange(0,dim):
        npasses = (npasses * r_dims[i])
      chunksize = 1

      # src/fusion/Expr.mbi(1465:11-1466:46)
      for i in xrange((dim + 1),int(len(r_dims))):
        chunksize = (chunksize * r_dims[i])
      basechunksize = chunksize

      chunksize = (chunksize * r_dims[dim])
      echunk = ([ 0 for _autovar_217 in xrange(int(len(fe))) ])

      # src/fusion/Expr.mbi(1472:11-1473:61)
      for i in xrange(0,int(len(fe))):
        echunk[i] = (basechunksize * ( fe[i].shape._dim_I(dim) ))
      eptr = ([ 0l for _autovar_218 in xrange(int(len(fe))) ])

      if   is_dense:
        # src/fusion/Expr.mbi(1483:13-1506:13)
        for k in xrange(0,npasses):
          # { @ src/fusion/Expr.mbi(1484:13-1506:13)
          # src/fusion/Expr.mbi(1485:15-1505:15)
          for i in xrange(0,int(len(fe))):
            # { @ src/fusion/Expr.mbi(1486:15-1505:15)
            block_nnz = (fe[i].ptrb[(eptr[i] + echunk[i])] - fe[i].ptrb[eptr[i]])

            ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
            if   (fe[i].bfix != None):
              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,long(echunk[i])) )
            eptrb = fe[i].ptrb[eptr[i]]

            # src/fusion/Expr.mbi(1496:17-1497:62)
            for j in xrange(0l,block_nnz):
              subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
            # src/fusion/Expr.mbi(1498:17-1499:98)
            for j in xrange(0,echunk[i]):
              ptrb[((ptr + j) + 1)] = ((fe[i].ptrb[((eptr[i] + j) + 1)] - fe[i].ptrb[(eptr[i] + j)]) + ptrb[(ptr + j)])
            ofs = (ofs + block_nnz)
            ptr = (ptr + echunk[i])
            cofs = (cofs + fe[i].shape._size)
            eptr[i] = (eptr[i] + echunk[i])
            # } @ src/fusion/Expr.mbi(1486:15-1505:15)
          # } @ src/fusion/Expr.mbi(1484:13-1506:13)
        r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
      else:
        ceofs = ([ 0l for _autovar_219 in xrange(int(len(fe))) ])

        # src/fusion/Expr.mbi(1518:13-1578:13)
        for k in xrange(0,npasses):
          # { @ src/fusion/Expr.mbi(1519:13-1578:13)
          # src/fusion/Expr.mbi(1520:15-1577:15)
          for i in xrange(0,int(len(fe))):
            # { @ src/fusion/Expr.mbi(1521:15-1577:15)
            if   (fe[i].inst == None):
              block_nnz = (fe[i].ptrb[(eptr[i] + echunk[i])] - fe[i].ptrb[eptr[i]])

              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
              if   (fe[i].bfix != None):
                ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,long(echunk[i])) )
              eptrb = fe[i].ptrb[eptr[i]]

              # src/fusion/Expr.mbi(1533:19-1534:64)
              for j in xrange(0l,block_nnz):
                subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
              # src/fusion/Expr.mbi(1535:19-1536:68)
              for j in xrange(0,echunk[i]):
                ptrb[(ptr + j)] = (fe[i].ptrb[(eptr[i] + j)] + ptrb[ptr])
              # src/fusion/Expr.mbi(1538:19-1539:43)
              for j in xrange(0,echunk[i]):
                inst[(ptr + j)] = (cofs + j)
              ofs = (ofs + block_nnz)
              ptr = (ptr + echunk[i])
              cofs = (cofs + fe[i].shape._size)
              eptr[i] = (eptr[i] + echunk[i])
            else:
              block_rows = 0l

              # { @ src/fusion/Expr.mbi(1549:19-1553:19)
              j = 0l

              # src/fusion/Expr.mbi(1551:21-77)
              while (fe[i].inst[(eptr[i] + j)] < (ceofs[i] + echunk[i])):
                j += 1
              block_rows = j
              # } @ src/fusion/Expr.mbi(1549:19-1553:19)
              block_nnz = (fe[i].ptrb[(eptr[i] + block_rows)] - fe[i].ptrb[eptr[i]])

              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
              if   (fe[i].bfix != None):
                ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,block_rows) )
              eptrb = fe[i].ptrb[eptr[i]]

              # src/fusion/Expr.mbi(1564:19-1565:64)
              for j in xrange(0l,block_nnz):
                subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
              # src/fusion/Expr.mbi(1566:19-1567:98)
              for j in xrange(0l,block_rows):
                ptrb[((ptr + j) + 1)] = ((fe[i].ptrb[((eptr[i] + j) + 1)] - fe[i].ptrb[(eptr[i] + j)]) + ptrb[(ptr + j)])
              # src/fusion/Expr.mbi(1568:19-1569:53)
              for j in xrange(0l,block_rows):
                inst[(ptr + j)] = (fe[i].inst[j] + cofs)
              ofs = (ofs + block_nnz)
              ptr = (ptr + block_rows)
              cofs = (cofs + fe[i].shape._size)
              eptr[i] = (eptr[i] + block_rows)
              ceofs[i] = (ceofs[i] + echunk[i])
            # } @ src/fusion/Expr.mbi(1521:15-1577:15)
          # } @ src/fusion/Expr.mbi(1519:13-1578:13)
        r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
    return r
  @staticmethod
  def _matchargs_hstack__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1610:15-1613:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("hstack([mosek.fusion.Expression])")
  def _hstack__3Omosek_fusion_Expression_2(exprs):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (exprs,1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1639:15-1643:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1670:15-1675:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,e3]),1) )
  @staticmethod
  def _matchargs_vstack__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1681:15-1684:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("vstack([mosek.fusion.Expression])")
  def _vstack__3Omosek_fusion_Expression_2(exprs):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (exprs,1) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1690:15-1694:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1702:15-1707:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,e3]),0) )
  @staticmethod
  def _matchargs_stack__3_3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1715:15-1722:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([[mosek.fusion.Expression]])")
  def _stack__3_3Omosek_fusion_Expression_2(exprs):
    tmp = ([ None for _autovar_220 in xrange(int(len(exprs))) ])

    # src/fusion/Expr.mbi(1718:9-1719:37)
    for i in xrange(0,int(len(exprs))):
      tmp[i] = ( Expr._stack__3Omosek_fusion_Expression_2I (exprs[i],1) )
    return ( Expr._stack__3Omosek_fusion_Expression_2I (tmp,0) )
  @staticmethod
  def _matchargs_dot__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1734:15-1793:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot([double],mosek.fusion.Expression)")
  def _dot__3FOmosek_fusion_Expression_2(lhs,rhs_):
    rhs = ( rhs_._eval_() )

    if   (rhs.shape._size != long(len(lhs))):
      raise mosek.fusion.LengthError("Lengths of operands do not match")
    elif (( rhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    ptrb = ([ 0l,long(len(rhs.subj))])

    cof = ([ 0.0 for _autovar_221 in xrange(int(len(rhs.cof))) ])

    subj = ( Utils.Tools._arraycopy__3L (rhs.subj) )

    bfix = None

    if   (rhs.inst != None):
      # src/fusion/Expr.mbi(1752:11-1759:11)
      k = 0

      while (k < int(len(rhs.inst))):
        i = rhs.inst[k]

        # src/fusion/Expr.mbi(1755:13-1758:13)
        j = rhs.ptrb[k]

        while (j < rhs.ptrb[(k + 1)]):
          cof[j] = (lhs[i] * rhs.cof[j])
          j += 1
        k += 1
      if   (rhs.bfix != None):
        bfixval = 0.0

        # src/fusion/Expr.mbi(1764:13-1767:13)
        k = 0

        while (k < int(len(rhs.inst))):
          bfixval = (bfixval + (rhs.bfix[k] * lhs[rhs.inst[k]]))
          k += 1
        bfix = ([ bfixval])
    else:
      # src/fusion/Expr.mbi(1773:11-1779:11)
      i = 0

      while (i < (int(len(rhs.ptrb)) - 1)):
        # src/fusion/Expr.mbi(1775:13-1778:13)
        k = rhs.ptrb[i]

        while (k < rhs.ptrb[(i + 1)]):
          cof[k] = (rhs.cof[k] * lhs[i])
          k += 1
        i += 1
      if   (rhs.bfix != None):
        bfixval = 0.0

        # src/fusion/Expr.mbi(1783:13-1786:13)
        i = 0

        while (i < int(len(rhs.bfix))):
          bfixval = (bfixval + (rhs.bfix[i] * lhs[i]))
          i += 1
        bfix = ([ bfixval])
    x = None

    if   (rhs.x != None):
      x = ( Variable._reshape_Omosek_fusion_Variable_2I (rhs.x,int(rhs.x.shape._size)) )
    return mosek.fusion.Expr(ptrb,x,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1806:15-1811:9)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Expression,[double])")
  def _dot_Omosek_fusion_Expression_2_3F(lhs,rhs):
    return ( Expr._dot__3FOmosek_fusion_Expression_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_dot__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1824:15-1829:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot([double],mosek.fusion.Variable)")
  def _dot__3FOmosek_fusion_Variable_2(lhs,rhs):
    return ( Expr._dot_Omosek_fusion_Variable_2_3F (rhs,lhs) )
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1844:15-1863:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Variable,[double])")
  def _dot_Omosek_fusion_Variable_2_3F(lhs,rhs):
    if   (( lhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    elif (lhs.shape._size != int(len(rhs))):
      raise mosek.fusion.LengthError("Operand lengths do not match")
    ptrb = ([ 0l,long(len(rhs))])

    subj = ( Utils.Tools._range_LL (0l,long(len(rhs))) )

    cof = ( Utils.Tools._arraycopy__3F (rhs) )

    bfix = None

    return mosek.fusion.Expr(ptrb,( Variable._reshape_Omosek_fusion_Variable_2I (lhs,int(lhs.shape._size)) ),subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(1878:15-1882:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs):
    return ( Expr._dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1897:15-1985:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs_,rhs):
    if   (((rhs.shape.nd != 2) or (( rhs.shape._dim_I(0) ) != lhs_._dimi)) or (( rhs.shape._dim_I(1) ) != lhs_._dimj)):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    res = None

    _autovar_222 = lhs_
    if   isinstance(_autovar_222,mosek.fusion.DenseMatrix):
      lhs = _autovar_222
      data = lhs._data

      numnz = 0

      # src/fusion/Expr.mbi(1914:13-1917:17)
      for i in xrange(0l,lhs._nnz):
        if   ((0.0 < lhs._data[i]) or (lhs._data[i] < 0.0)):
          numnz += 1
      if   (numnz < lhs._nnz):
        ptrb = ([ 0l,long(numnz)])

        subj = ([ 0l for _autovar_223 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_224 in xrange(numnz) ])

        k = 0

        # src/fusion/Expr.mbi(1923:15-1932:20)
        for i in xrange(0l,lhs._nnz):
          if   ((0.0 < lhs._data[i]) or (lhs._data[i] < 0.0)):
            subj[k] = i
            cof[k] = lhs._data[i]
            k += 1
        res = mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
      else:
        res = mosek.fusion.Expr(([ 0l,lhs._nnz]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),( Utils.Tools._range_L (lhs._nnz) ),lhs._data,None,None,None,1)
    else:
      lhs = _autovar_222
      nnz = ( lhs._numNonzeros_() )

      if   (nnz > 0):
        subi = ([ 0 for _autovar_225 in xrange(nnz) ])

        subj = ([ 0 for _autovar_226 in xrange(nnz) ])

        val = ([ 0.0 for _autovar_227 in xrange(nnz) ])

        ( lhs._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
        sub = ([ 0l for _autovar_228 in xrange(nnz) ])

        # src/fusion/Expr.mbi(1960:15-1961:61)
        for k in xrange(0l,nnz):
          sub[k] = long(((subi[k] * lhs._dimj) + subj[k]))
        res = mosek.fusion.Expr(([ 0l,nnz]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),sub,val,None,None,None,1)
      else:
        res = mosek.fusion.Expr(([ 0l,0l]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),([ 0l for _autovar_229 in xrange(0) ]),([ 0.0 for _autovar_230 in xrange(0) ]),None,None,None,1)
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1997:15-2028:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,[double])")
  def _mul_Omosek_fusion_Variable_2_3F(lhs,rhs):
    if   (lhs.shape._size == 1):
      ptrb = ( Utils.Tools._range_LL (0l,(long(len(rhs)) + 1)) )

      subj = ( Utils.Tools._makevector_LI (0l,int(len(rhs))) )

      cof = ( Utils.Tools._arraycopy__3F (rhs) )

      bfix = None

      return mosek.fusion.Expr(ptrb,lhs,subj,cof,bfix,None,None,1)
    elif (lhs.shape.nd == 2):
      if   (( lhs.shape._dim_I(1) ) != int(len(rhs))):
        raise mosek.fusion.DimensionError("Dimensions of operands do not match")
      ptrb = ( Utils.Tools._range_LLL (0l,(lhs.shape._size + ( lhs.shape._dim_I(1) )),long(( lhs.shape._dim_I(1) ))) )

      subj = ( Utils.Tools._range_LL (0l,lhs.shape._size) )

      cof = ([ 0.0 for _autovar_231 in xrange(lhs.shape._size) ])

      rowlen = long(( lhs.shape._dim_I(1) ))

      # src/fusion/Expr.mbi(2019:11-2020:68)
      for i in xrange(0l,long(( lhs.shape._dim_I(0) ))):
        ( Utils.Tools._arraycopy__3FL_3FLL (rhs,0l,cof,(i * rowlen),rowlen) )
      bfix = None

      return mosek.fusion.Expr(ptrb,( lhs._flatten_() ),subj,cof,bfix,None,None,1)
    else:
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
  @staticmethod
  def _matchargs_mul__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2035:15-2078:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul([double],mosek.fusion.Variable)")
  def _mul__3FOmosek_fusion_Variable_2(lhs,rhs):
    if   ((rhs.shape._size == 1) or (rhs.shape.nd == 1)):
      return ( Expr._mul_Omosek_fusion_Variable_2_3F (rhs,lhs) )
    elif (rhs.shape.nd == 2):
      if   (( rhs.shape._dim_I(0) ) != int(len(lhs))):
        raise mosek.fusion.DimensionError("Dimensions of operands do not match")
      nrow = long(( rhs.shape._dim_I(0) ))

      ncol = long(( rhs.shape._dim_I(1) ))

      ptrb = ( Utils.Tools._range_LLL (0l,((ncol + 1) * nrow),nrow) )

      subj = ([ 0l for _autovar_232 in xrange(rhs.shape._size) ])

      cof = ([ 0.0 for _autovar_233 in xrange(rhs.shape._size) ])

      # src/fusion/Expr.mbi(2056:11-2060:11)
      i = 0l

      while (i < ncol):
        B = (i * ncol)

        ( Utils.Tools._arraycopy__3FL_3FLL (lhs,0l,cof,B,ncol) )
        i += 1
      k = 0l

      # src/fusion/Expr.mbi(2063:11-2069:11)
      i = 0l

      while (i < nrow):
        # src/fusion/Expr.mbi(2065:13-2068:13)
        j = 0l

        while (j < ncol):
          subj[k] = (i + (j * nrow))
          k += 1
          j += 1
        i += 1
      bfix = None

      return mosek.fusion.Expr(ptrb,( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),subj,cof,bfix,None,None,1)
    else:
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
  @staticmethod
  def _matchargs_mul_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2085:15-2095:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(float,mosek.fusion.Variable)")
  def _mul_FOmosek_fusion_Variable_2(lhs,rhs):
    ptrb = ( Utils.Tools._range_LL (0l,(rhs.shape._size + 1l)) )

    cof = ( Utils.Tools._makevector_FI (lhs,int(rhs.shape._size)) )

    subj = ( Utils.Tools._range_LL (0l,rhs.shape._size) )

    bfix = None

    return mosek.fusion.Expr(ptrb,rhs,subj,cof,bfix,rhs.shape,None)
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2102:15-2107:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,float)")
  def _mul_Omosek_fusion_Variable_2F(lhs,rhs):
    return ( Expr._mul_FOmosek_fusion_Variable_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2114:15-2119:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Expression,float)")
  def _mul_Omosek_fusion_Expression_2F(lhs,rhs):
    return ( Expr._mul_FOmosek_fusion_Expression_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_mul_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2126:15-2144:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(float,mosek.fusion.Expression)")
  def _mul_FOmosek_fusion_Expression_2(lhs,rhs):
    fe = ( rhs._eval_() )

    # src/fusion/Expr.mbi(2131:9-74)
    i = 0l

    while (i < fe.nnz):
      fe.cof[i] = (fe.cof[i] * lhs)
      i += 1
    if   (fe.bfix != None):
      # src/fusion/Expr.mbi(2134:11-83)
      i = 0

      while (i < int(len(fe.bfix))):
        fe.bfix[i] = (fe.bfix[i] * lhs)
        i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,fe.bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_mul__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2159:15-2320:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul([double],mosek.fusion.Expression)")
  def _mul__3FOmosek_fusion_Expression_2(lhs,rhs):
    res = None

    if   ((rhs._shape == None) or (rhs._shape.nd == 1)):
      res = ( Expr._dot__3FOmosek_fusion_Expression_2 (lhs,rhs) )
    elif (rhs._shape.nd == 2):
      e = ( rhs._eval_() )

      if   (( e.shape._dim_I(0) ) != int(len(lhs))):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
      if   (e.inst == None):
        dim0 = ( e.shape._dim_I(0) )

        dim1 = ( e.shape._dim_I(1) )

        ptrb = ([ 0l for _autovar_234 in xrange((dim1 + 1)) ])

        subj = ([ 0l for _autovar_235 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_236 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_237 in xrange(dim1) ])
        # src/fusion/Expr.mbi(2188:13-2195:13)
        i = 0

        while (i < dim0):
          b = (long(i) * long(dim1))

          # src/fusion/Expr.mbi(2191:15-2194:15)
          j = 0

          while (j < dim1):
            ptrb[(j + 1)] = ((ptrb[(j + 1)] + e.ptrb[((b + j) + 1)]) - e.ptrb[(b + j)])
            j += 1
          i += 1
        # src/fusion/Expr.mbi(2196:13-79)
        j = 0

        while (j < dim1):
          ptrb[(j + 1)] = (ptrb[(j + 1)] + ptrb[j])
          j += 1
        # src/fusion/Expr.mbi(2198:13-2221:13)
        i = 0

        while (i < dim0):
          # src/fusion/Expr.mbi(2200:15-2220:15)
          j = 0

          while (j < dim1):
            baseidx = ((i * dim1) + j)

            baseofs = e.ptrb[baseidx]

            num = (e.ptrb[(baseidx + 1)] - e.ptrb[baseidx])

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,baseofs,subj,ptrb[j],num) )
            # src/fusion/Expr.mbi(2209:17-2212:17)
            k = 0

            while (k < num):
              cof[(ptrb[j] + k)] = (cof[(ptrb[j] + k)] + (lhs[i] * e.cof[(baseofs + k)]))
              k += 1
            if   (bfix != None):
              bfix[j] = (bfix[j] + (lhs[i] * e.bfix[baseidx]))
            ptrb[j] = (ptrb[j] + num)
            j += 1
          i += 1
        # src/fusion/Expr.mbi(2222:13-67)
        j = dim1

        while (j > 0):
          ptrb[j] = ptrb[(j - 1)]
          j -= 1
        ptrb[0] = 0l
        res = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,None,None,1)
      else:
        dim0 = ( e.shape._dim_I(0) )

        dim1 = ( e.shape._dim_I(1) )

        numentries = int(len(e.inst))

        if   (numentries > 0):
          ssubi = ([ 0 for _autovar_238 in xrange(numentries) ])

          ssubj = ([ 0 for _autovar_239 in xrange(numentries) ])

          # src/fusion/Expr.mbi(2236:15-2240:15)
          k = 0

          while (k < numentries):
            ssubi[k] = int((e.inst[k] / dim1))
            ssubj[k] = int((e.inst[k] - (long(ssubi[k]) * dim1)))
            k += 1
          perm = ([ 0l for _autovar_240 in xrange(numentries) ])

          # src/fusion/Expr.mbi(2241:43-92)
          k = 0l

          while (k < numentries):
            perm[k] = k
            k += 1
          ( Sort._argsort__3L_3I_3I (perm,ssubj,ssubi) )
          numcol = 1

          # src/fusion/Expr.mbi(2247:15-2250:15)
          k = 1

          while (k < numentries):
            if   (ssubj[perm[k]] > ssubj[perm[(k - 1)]]):
              numcol += 1
            k += 1
          ptrb = ([ 0l for _autovar_241 in xrange((numcol + 1)) ])

          bfix = None

          if   (e.bfix != None):
            bfix = ([ 0.0 for _autovar_242 in xrange(numcol) ])
          subj = ([ 0l for _autovar_243 in xrange(e.nnz) ])

          cof = ([ 0.0 for _autovar_244 in xrange(e.nnz) ])

          inst = ([ 0l for _autovar_245 in xrange(numcol) ])

          # { @ src/fusion/Expr.mbi(2258:15-2268:15)
          inst[0] = long(ssubj[perm[0]])
          it = 0

          # src/fusion/Expr.mbi(2261:17-2267:17)
          i = 1

          while (i < numentries):
            if   (inst[it] < ssubj[perm[i]]):
              it += 1
              inst[it] = long(ssubj[perm[i]])
            i += 1
          # } @ src/fusion/Expr.mbi(2258:15-2268:15)
          # { @ src/fusion/Expr.mbi(2271:15-2282:15)
          p = 0

          prevsj = (- 1)

          # src/fusion/Expr.mbi(2274:17-2279:17)
          k = 0

          while (k < numentries):
            pk = perm[k]

            if   (ssubj[pk] > prevsj):
              p += 1
              prevsj = ssubj[pk]
            ptrb[(ssubj[pk] + 1)] = ((ptrb[(ssubj[pk] + 1)] + e.ptrb[(pk + 1)]) - e.ptrb[pk])
            k += 1
          # src/fusion/Expr.mbi(2281:17-85)
          k = 0

          while (k < numcol):
            ptrb[(k + 1)] = (ptrb[(k + 1)] + ptrb[k])
            k += 1
          # } @ src/fusion/Expr.mbi(2271:15-2282:15)
          # src/fusion/Expr.mbi(2284:15-2299:15)
          k = 0

          while (k < numentries):
            pk = perm[k]

            idx = ssubj[pk]

            num = (e.ptrb[(pk + 1)] - e.ptrb[pk])

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[pk],subj,ptrb[idx],num) )
            # src/fusion/Expr.mbi(2292:17-2295:17)
            p = 0

            while (p < num):
              cof[(ptrb[idx] + p)] = (cof[(ptrb[idx] + p)] + (e.cof[(e.ptrb[pk] + p)] * lhs[ssubi[pk]]))
              p += 1
            ptrb[idx] = (ptrb[idx] + num)
            if   (bfix != None):
              bfix[idx] = (bfix[idx] + (lhs[ssubi[pk]] * e.bfix[pk]))
            k += 1
          res = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,mosek.fusion.IntSet((int(len(ptrb)) - 1)),inst)
        else:
          ptrb = ([ 0l])

          subj = ([ 0l for _autovar_246 in xrange(0) ])

          cof = ([ 0.0 for _autovar_247 in xrange(0) ])

          bfix = None

          inst = ([ 0l for _autovar_248 in xrange(0) ])

          res = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,mosek.fusion.IntSet((int(len(ptrb)) - 1)),inst)
    else:
      raise mosek.fusion.DimensionError("Expression operand must be one- or two-dimensional")
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(2333:15-2434:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Expression,[double])")
  def _mul_Omosek_fusion_Expression_2_3F(lhs,rhs):
    res = None

    if   ((lhs._shape == None) or (lhs._shape.nd == 1)):
      res = ( Expr._dot_Omosek_fusion_Expression_2_3F (lhs,rhs) )
    elif ((lhs._shape.nd == 2) and (( lhs._shape._dim_I(1) ) == int(len(rhs)))):
      e = ( lhs._eval_() )

      edimi = ( e.shape._dim_I(0) )

      edimj = ( e.shape._dim_I(1) )

      if   (e.inst == None):
        ptrb = ([ 0l for _autovar_249 in xrange((edimi + 1)) ])

        subj = ([ 0l for _autovar_250 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_251 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_252 in xrange(edimi) ])
        p = 0l

        ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,0l,subj,0l,e.nnz) )
        # src/fusion/Expr.mbi(2356:13-2373:13)
        i = 0

        while (i < edimi):
          ptr = ptrb[i]

          # src/fusion/Expr.mbi(2359:15-2371:15)
          j = 0

          while (j < edimj):
            num = (e.ptrb[(p + 1)] - e.ptrb[p])

            # src/fusion/Expr.mbi(2362:17-2363:59)
            l = 0

            while (l < num):
              cof[(ptr + l)] = (e.cof[(e.ptrb[p] + l)] * rhs[j])
              l += 1
            if   (bfix != None):
              bfix[i] = (bfix[i] + (rhs[j] * e.bfix[p]))
            ptr = (ptr + num)
            p += 1
            j += 1
          ptrb[(i + 1)] = ptr
          i += 1
        res = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,None,None,1)
      else:
        numrow = 0

        nnz = e.nnz

        if   (int(len(e.subj)) > 0):
          prev = (- 1l)

          # src/fusion/Expr.mbi(2383:15-2386:16)
          i = 0l

          while (i < (int(len(e.ptrb)) - 1)):
            if   ((e.inst[i] / edimj) > prev):
              numrow += 1
              prev = (e.inst[i] / edimj)
            i += 1
        ptrb = ([ 0l for _autovar_253 in xrange((numrow + 1)) ])

        subj = ([ 0l for _autovar_254 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_255 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_256 in xrange(numrow) ])
        inst = None

        if   (numrow < edimi):
          inst = ([ 0l for _autovar_257 in xrange(numrow) ])
        shape = mosek.fusion.IntSet(edimi)

        ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,0l,subj,0l,e.nnz) )
        # { @ src/fusion/Expr.mbi(2396:13-2422:13)
        previ = (- 1l)

        rp = 0l

        ptr = 0l

        # src/fusion/Expr.mbi(2401:15-2420:15)
        i = 0l

        while (i < (long(len(e.ptrb)) - 1)):
          if   ((e.inst[i] / edimj) > previ):
            previ = (e.inst[i] / edimj)
            if   (inst != None):
              inst[rp] = previ
            ptrb[rp] = ptr
            rp += 1
          num = (e.ptrb[(i + 1)] - e.ptrb[i])

          j = (e.inst[i] - (previ * edimj))

          # src/fusion/Expr.mbi(2413:17-2414:59)
          l = 0

          while (l < num):
            cof[(ptr + l)] = (rhs[j] * e.cof[(e.ptrb[i] + l)])
            l += 1
          if   (bfix != None):
            bfix[(rp - 1)] = (bfix[(rp - 1)] + (rhs[j] * e.bfix[i]))
          ptr = (ptr + num)
          i += 1
        ptrb[rp] = ptr
        # } @ src/fusion/Expr.mbi(2396:13-2422:13)
        res = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst,1)
    else:
      raise mosek.fusion.DimensionError("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
    return res
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2443:15-2477:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs,rhs):
    shape = rhs.shape

    if   (shape.nd != 2):
      raise mosek.fusion.DimensionError("Variable and matrix must have same dimension")
    else:
      if   ((( shape._dim_I(0) ) != lhs._dimi) or (( shape._dim_I(1) ) != lhs._dimj)):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    _autovar_258 = lhs
    if   isinstance(_autovar_258,mosek.fusion.DenseMatrix):
      m = _autovar_258
      ptrb = ( Utils.Tools._range_LL (0l,long(((m._dimi * m._dimj) + 1))) )

      subj = ( Utils.Tools._range_LL (0l,long((m._dimi * m._dimj))) )

      return mosek.fusion.Expr(ptrb,rhs,subj,m._data,None,shape,None)
    else:
      m = _autovar_258
      nnz = ( m._numNonzeros_() )

      subi_ = ([ 0 for _autovar_259 in xrange(nnz) ])

      subj_ = ([ 0 for _autovar_260 in xrange(nnz) ])

      val_ = ([ 0.0 for _autovar_261 in xrange(nnz) ])

      ptrb = ( Utils.Tools._range_LL (0l,(nnz + 1)) )

      inst = ([ 0l for _autovar_262 in xrange(nnz) ])

      ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
      # src/fusion/Expr.mbi(2472:11-2473:59)
      for i in xrange(0l,nnz):
        inst[i] = long(((subi_[i] * m._dimj) + subj_[i]))
      return mosek.fusion.Expr(ptrb,rhs,inst,val_,None,shape,inst)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2485:15-2674:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs):
    shape = rhs._shape

    if   (shape.nd != 2):
      raise mosek.fusion.DimensionError("Variable and matrix must have same dimension")
    else:
      if   ((( shape._dim_I(0) ) != lhs._dimi) or (( shape._dim_I(1) ) != lhs._dimj)):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    fe = ( rhs._eval_() )

    if   (fe.inst == None):
      _autovar_263 = lhs
      if   isinstance(_autovar_263,mosek.fusion.DenseMatrix):
        m = _autovar_263
        nnz = ( m._numNonzeros_() )

        ptrb = fe.ptrb

        # src/fusion/Expr.mbi(2503:13-2507:13)
        i = 0l

        while (i < nnz):
          # src/fusion/Expr.mbi(2505:15-2506:50)
          k = ptrb[i]

          while (k < ptrb[(i + 1)]):
            fe.cof[k] = (fe.cof[k] * m._data[i])
            k += 1
          i += 1
        if   (fe.bfix != None):
          # src/fusion/Expr.mbi(2510:15-2511:52)
          i = 0l

          while (i < nnz):
            fe.bfix[i] = (fe.bfix[i] * m._data[i])
            i += 1
        return mosek.fusion.Expr(ptrb,fe.x,fe.subj,fe.cof,fe.bfix,shape,None,1)
      else:
        m = _autovar_263
        nnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_264 in xrange(nnz) ])

        msubj = ([ 0 for _autovar_265 in xrange(nnz) ])

        mcof = ([ 0.0 for _autovar_266 in xrange(nnz) ])

        # { @ src/fusion/Expr.mbi(2521:13-2537:13)
        subi = ([ 0 for _autovar_267 in xrange(nnz) ])

        subj_ = ([ 0 for _autovar_268 in xrange(nnz) ])

        val = ([ 0.0 for _autovar_269 in xrange(nnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi,subj_,val) )
        perm = ([ 0l for _autovar_270 in xrange(nnz) ])

        # src/fusion/Expr.mbi(2528:36-78)
        k = 0l

        while (k < nnz):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,subi,subj_) )
        # src/fusion/Expr.mbi(2531:15-2536:15)
        k = 0l

        while (k < nnz):
          msubi[k] = subi[perm[k]]
          msubj[k] = subj_[perm[k]]
          mcof[k] = val[perm[k]]
          k += 1
        # } @ src/fusion/Expr.mbi(2521:13-2537:13)
        numexpnz = 0l

        numnz = 0l

        # src/fusion/Expr.mbi(2542:13-2547:13)
        i = 0

        while (i < nnz):
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          numexpnz += 1
          numnz = (numnz + (fe.ptrb[(lidx + 1l)] - fe.ptrb[lidx]))
          i += 1
        # { @ src/fusion/Expr.mbi(2548:13-2570:13)
        ptrb = ([ 0l for _autovar_271 in xrange((numexpnz + 1)) ])

        ptrb[0] = 0l

        if   (fe.bfix == None):
          bfix = None
        else:
          bfix = ([ 0.0 for _autovar_272 in xrange(numexpnz) ])
        subj_ = ([ 0l for _autovar_273 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_274 in xrange(numnz) ])

        inst = ([ 0l for _autovar_275 in xrange(numnz) ])

        # src/fusion/Expr.mbi(2554:15-2567:15)
        i = 0

        while (i < nnz):
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          l = (fe.ptrb[(lidx + 1)] - fe.ptrb[lidx])

          ptrb[(i + 1)] = (ptrb[i] + l)
          # src/fusion/Expr.mbi(2559:17-2563:17)
          j = 0l

          while (j < l):
            subj_[(ptrb[lidx] + j)] = fe.subj[(fe.ptrb[lidx] + j)]
            cof[(ptrb[lidx] + j)] = (fe.cof[(fe.ptrb[lidx] + j)] * mcof[i])
            l += 1
          if   (fe.bfix != None):
            bfix[i] = (fe.bfix[lidx] * mcof[i])
          inst[i] = lidx
          i += 1
        return mosek.fusion.Expr(ptrb,fe.x,subj_,mcof,bfix,shape,inst,1)
        # } @ src/fusion/Expr.mbi(2548:13-2570:13)
    else:
      _autovar_276 = lhs
      if   isinstance(_autovar_276,mosek.fusion.DenseMatrix):
        m = _autovar_276
        ptrb = fe.ptrb

        subj_ = fe.subj

        cof = fe.cof

        bfix = fe.bfix

        # src/fusion/Expr.mbi(2582:13-2587:13)
        i = 0l

        while (i < fe.nnz):
          idx = fe.inst[i]

          # src/fusion/Expr.mbi(2585:15-2586:59)
          k = fe.ptrb[i]

          while (k < fe.ptrb[(i + 1)]):
            fe.cof[k] = (fe.cof[k] * m._data[fe.inst[i]])
            k += 1
          i += 1
        if   (fe.bfix != None):
          # src/fusion/Expr.mbi(2590:15-2591:61)
          i = 0l

          while (i < fe.nnz):
            fe.bfix[i] = (fe.bfix[i] * m._data[fe.inst[i]])
            i += 1
        return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,fe.bfix,shape,fe.inst,1)
      else:
        m = _autovar_276
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_277 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_278 in xrange(mnnz) ])

        mcof = ([ 0.0 for _autovar_279 in xrange(mnnz) ])

        # { @ src/fusion/Expr.mbi(2601:13-2617:13)
        subi = ([ 0 for _autovar_280 in xrange(mnnz) ])

        subj_ = ([ 0 for _autovar_281 in xrange(mnnz) ])

        val = ([ 0.0 for _autovar_282 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi,subj_,val) )
        perm = ([ 0l for _autovar_283 in xrange(mnnz) ])

        # src/fusion/Expr.mbi(2608:37-80)
        k = 0l

        while (k < mnnz):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,subj_,subi) )
        # src/fusion/Expr.mbi(2611:15-2616:15)
        k = 0l

        while (k < mnnz):
          msubi[k] = subi[perm[k]]
          msubj[k] = subj_[perm[k]]
          mcof[k] = val[perm[k]]
          k += 1
        # } @ src/fusion/Expr.mbi(2601:13-2617:13)
        numexpnz = 0l

        numnz = 0l

        # src/fusion/Expr.mbi(2624:13-2637:13)
        i = 0

        j = 0

        while (i < mnnz):
          lidx = ((msubi[i] * m._dimj) + msubj[i])

          if   (lidx < fe.inst[j]):
            i += 1
          elif (lidx > fe.inst[j]):
            j += 1
          else:
            numexpnz = ((numexpnz + fe.ptrb[(j + 1)]) - fe.ptrb[j])
            numnz += 1
            i += 1
            j += 1
        # { @ src/fusion/Expr.mbi(2638:13-2671:13)
        ptrb = ([ 0l for _autovar_284 in xrange((numexpnz + 1)) ])

        ptrb[0] = 0l

        if   (fe.bfix == None):
          bfix = None
        else:
          bfix = ([ 0.0 for _autovar_285 in xrange(numexpnz) ])
        subj_ = ([ 0l for _autovar_286 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_287 in xrange(numnz) ])

        inst = ([ 0l for _autovar_288 in xrange(numnz) ])

        # src/fusion/Expr.mbi(2645:15-2668:15)
        i = 0

        j = 0

        k = 0

        while (i < mnnz):
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          if   (lidx < fe.inst[j]):
            i += 1
          elif (lidx > fe.inst[j]):
            j += 1
          else:
            l = (fe.ptrb[(j + 1)] - fe.ptrb[j])

            b = ptrb[k]

            ptrb[(k + 1)] = (b + l)
            # src/fusion/Expr.mbi(2657:19-2661:19)
            p = 0

            while (p < l):
              subj_[(b + l)] = fe.subj[(fe.ptrb[j] + l)]
              cof[(b + l)] = (fe.cof[(fe.ptrb[j] + l)] * mcof[i])
              p += 1
            inst[k] = lidx
            if   (bfix != None):
              bfix[k] = (fe.bfix[k] * mcof[i])
            i += 1
            j += 1
            k += 1
        return mosek.fusion.Expr(ptrb,fe.x,subj_,cof,bfix,shape,inst,1)
        # } @ src/fusion/Expr.mbi(2638:13-2671:13)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2682:15-2686:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2694:15-2698:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs):
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2712:15-2969:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(rhs,lhs):

    e = ( lhs._eval_() )

    if   (e.shape.nd != 2):
      raise mosek.fusion.DimensionError("Expression operand must have 2 dimensions")
    if   ((( e.shape._dim_I(0) ) != rhs._dimj) or (( e.shape._dim_I(1) ) != rhs._dimi)):
      raise mosek.fusion.DimensionError("Mismatching operand dimensions")
    edi = ( e.shape._dim_I(0) )

    edj = ( e.shape._dim_I(1) )

    _autovar_289 = rhs
    if   isinstance(_autovar_289,mosek.fusion.DenseMatrix):
      m = _autovar_289
      if   (e.inst == None):
        numEntries = m._dimi

        ptrb = ([ 0l for _autovar_290 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_291 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_292 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_293 in xrange(numEntries) ])
        p = 1

        # { @ src/fusion/Expr.mbi(2739:13-2764:13)
        # src/fusion/Expr.mbi(2740:15-2763:15)
        i = 0

        while (i < m._dimi):
          rhsptridx = i

          ptrb[p] = ptrb[(p - 1)]
          # src/fusion/Expr.mbi(2746:17-2761:17)
          k = 0

          while (k < m._dimj):
            b = e.ptrb[rhsptridx]

            num = (e.ptrb[(rhsptridx + 1)] - b)

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,b,subj_,ptrb[p],num) )
            c = m._data[((i * m._dimj) + k)]

            # src/fusion/Expr.mbi(2753:19-2754:54)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (e.cof[(b + l)] * c)
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (e.bfix[rhsptridx] * c))
            rhsptridx = (rhsptridx + m._dimi)
            ptrb[p] = (ptrb[p] + num)
            k += 1
          p += 1
          i += 1
        # } @ src/fusion/Expr.mbi(2739:13-2764:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,None,None)
      else:
        numEntries = m._dimi

        ptrb = ([ 0l for _autovar_294 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_295 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_296 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_297 in xrange(numEntries) ])
        # { @ src/fusion/Expr.mbi(2776:13-2787:13)
        n = int(len(e.inst))

        # src/fusion/Expr.mbi(2778:15-2784:15)
        i = 0

        while (i < n):
          esubi = (e.inst[i] / m._dimi)

          esubj = (e.inst[i] - (esubi * m._dimi))

          ptrb[(esubj + 1)] = (ptrb[(esubj + 1)] + (e.ptrb[(i + 1)] - e.ptrb[i]))
          i += 1
        # src/fusion/Expr.mbi(2785:15-2786:50)
        i = 0

        while (i < m._dimi):
          ptrb[(i + 1)] = (ptrb[(i + 1)] + ptrb[i])
          i += 1
        # } @ src/fusion/Expr.mbi(2776:13-2787:13)
        # { @ src/fusion/Expr.mbi(2789:13-2813:13)
        n = int(len(e.inst))

        # src/fusion/Expr.mbi(2791:15-2808:15)
        i = 0

        while (i < n):
          esubi = (e.inst[i] / edj)

          esubj = (e.inst[i] - (esubi * edj))

          num = (e.ptrb[(i + 1)] - e.ptrb[i])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj_,ptrb[esubj],num) )
          c = m._data[((esubj * m._dimj) + esubi)]

          # src/fusion/Expr.mbi(2801:17-2802:64)
          l = 0

          while (l < num):
            cof[(ptrb[esubj] + l)] = (e.cof[(e.ptrb[i] + l)] * c)
            l += 1
          if   (bfix != None):
            bfix[esubj] = (bfix[esubj] + (c * e.bfix[i]))
          ptrb[esubj] = (ptrb[esubj] + num)
          i += 1
        # src/fusion/Expr.mbi(2810:15-2811:38)
        i = m._dimi

        while (i > 1):
          ptrb[i] = ptrb[(i - 1)]
          i -= 1
        ptrb[0] = 0l
        # } @ src/fusion/Expr.mbi(2789:13-2813:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,None,None)
    else:
      m = _autovar_289
      if   (e.inst == None):
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_298 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_299 in xrange(mnnz) ])

        mval = ([ 0.0 for _autovar_300 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
        numEntries = 1

        # src/fusion/Expr.mbi(2829:13-91)
        i = 1

        while (i < mnnz):
          if   (msubi[i] > msubi[(i - 1)]):
            numEntries += 1
          i += 1
        ptrb = ([ 0l for _autovar_301 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_302 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_303 in xrange(e.nnz) ])

        shape = None

        inst = None

        if   (numEntries < m._dimi):
          shape = mosek.fusion.IntSet(numEntries)
          inst = ([ 0l for _autovar_304 in xrange(numEntries) ])
        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_305 in xrange(numEntries) ])
        # { @ src/fusion/Expr.mbi(2844:13-2870:13)
        p = 0

        curi = (- 1)

        # src/fusion/Expr.mbi(2847:15-2869:15)
        k = 0

        while (k < mnnz):
          if   (curi < msubi[k]):
            curi = msubi[k]
            if   (inst != None):
              inst[p] = long(msubi[k])
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          rhsptridx = ((msubj[k] * m._dimi) + msubi[k])

          num = (e.ptrb[(rhsptridx + 1)] - e.ptrb[rhsptridx])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[rhsptridx],subj_,ptrb[p],num) )
          # src/fusion/Expr.mbi(2862:17-2863:74)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (mval[k] * e.cof[(e.ptrb[rhsptridx] + l)])
            l += 1
          if   (bfix != None):
            bfix[(p - 1)] = (bfix[(p - 1)] + (mval[k] * e.bfix[rhsptridx]))
          ptrb[p] = (ptrb[p] + num)
          k += 1
        # } @ src/fusion/Expr.mbi(2844:13-2870:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,shape,inst)
      else:
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_306 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_307 in xrange(mnnz) ])

        mval = ([ 0.0 for _autovar_308 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
        eNEntries = int(len(e.inst))

        esubi = ([ 0 for _autovar_309 in xrange(eNEntries) ])

        esubj = ([ 0 for _autovar_310 in xrange(eNEntries) ])

        # src/fusion/Expr.mbi(2888:13-2892:13)
        k = 0

        while (k < eNEntries):
          esubi[k] = int((e.inst[k] / m._dimi))
          esubj[k] = int((e.inst[k] - long((esubi[k] * m._dimi))))
          k += 1
        perm = ([ 0l for _autovar_311 in xrange(eNEntries) ])

        # src/fusion/Expr.mbi(2893:40-88)
        k = 0l

        while (k < eNEntries):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numEntries = 0

        numNz = 0l

        # { @ src/fusion/Expr.mbi(2900:13-2919:13)
        i = 0

        j = 0

        previ = (- 1)

        # src/fusion/Expr.mbi(2902:15-2918:15)
        while ((i < mnnz) and (j < e.nnz)):
          if   (msubi[i] < esubj[perm[j]]):
            i += 1
          elif (msubi[i] > esubj[perm[j]]):
            j += 1
          elif (msubj[i] < esubi[perm[j]]):
            i += 1
          elif (msubj[i] > esubi[perm[j]]):
            j += 1
          else:
            if   (previ < msubi[i]):
              previ = msubi[i]
              numEntries += 1
            numNz = (numNz + (e.ptrb[(perm[j] + 1)] - e.ptrb[perm[j]]))
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(2900:13-2919:13)
        ptrb = ([ 0l for _autovar_312 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_313 in xrange(numNz) ])

        cof = ([ 0.0 for _autovar_314 in xrange(numNz) ])

        inst = ([ 0l for _autovar_315 in xrange(numEntries) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_316 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(m._dimi)

        # { @ src/fusion/Expr.mbi(2931:13-2963:13)
        p = 0

        i = 0

        j = 0

        previ = (- 1)

        # src/fusion/Expr.mbi(2934:15-2962:15)
        while ((i < mnnz) and (j < e.nnz)):
          if   (msubi[i] < esubj[perm[j]]):
            i += 1
          elif (msubi[i] > esubj[perm[j]]):
            j += 1
          elif (msubj[i] < esubi[perm[j]]):
            i += 1
          elif (msubj[i] > esubi[perm[j]]):
            j += 1
          else:
            if   (previ < msubi[i]):
              previ = msubi[i]
              inst[p] = long(msubi[i])
              p += 1
              ptrb[p] = ptrb[(p - 1)]
            num = (e.ptrb[(perm[j] + 1)] - e.ptrb[perm[j]])

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[perm[j]],subj_,ptrb[p],num) )
            # src/fusion/Expr.mbi(2951:19-2952:74)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (mval[i] * e.cof[(e.ptrb[perm[j]] + l)])
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (mval[i] * e.bfix[perm[j]]))
            ptrb[p] = (ptrb[p] + num)
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(2931:13-2963:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2982:15-3232:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):

    e = ( lhs._eval_() )

    if   (e.shape.nd != 2):
      raise mosek.fusion.DimensionError("Expression operand must have 2 dimensions")
    if   ((( e.shape._dim_I(0) ) != rhs._dimj) or (( e.shape._dim_I(1) ) != rhs._dimi)):
      raise mosek.fusion.DimensionError("Mismatching operand dimensions")
    edi = ( e.shape._dim_I(0) )

    edj = ( e.shape._dim_I(1) )

    _autovar_317 = rhs
    if   isinstance(_autovar_317,mosek.fusion.DenseMatrix):
      m = _autovar_317
      if   (e.inst == None):
        ptrb = ([ 0l for _autovar_318 in xrange((edi + 1)) ])

        subj = ([ 0l for _autovar_319 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_320 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_321 in xrange(edi) ])
        inst = None

        shape = None

        eptridx = 0

        # src/fusion/Expr.mbi(3011:13-3030:13)
        i = 0

        while (i < edi):
          ptrb[(i + 1)] = ptrb[i]
          # src/fusion/Expr.mbi(3014:15-3029:15)
          j = 0

          while (j < edj):
            num = (e.ptrb[(eptridx + 1)] - e.ptrb[eptridx])

            c = m._data[((j * edi) + i)]

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[eptridx],subj,ptrb[(i + 1)],num) )
            # src/fusion/Expr.mbi(3020:17-3021:68)
            l = 0

            while (l < num):
              cof[(ptrb[(i + 1)] + l)] = (c * e.cof[(e.ptrb[eptridx] + l)])
              l += 1
            if   (bfix != None):
              bfix[i] = (bfix[i] + (c * e.bfix[eptridx]))
            ptrb[(i + 1)] = (ptrb[(i + 1)] + num)
            eptridx += 1
            j += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        numElements = 0

        # { @ src/fusion/Expr.mbi(3037:13-3048:13)
        previ = (- 1l)

        # src/fusion/Expr.mbi(3039:15-3047:15)
        i = 0

        while (i < int(len(e.inst))):
          ei = (e.inst[i] / long(edj))

          if   (previ < ei):
            previ = ei
            numElements += 1
          i += 1
        # } @ src/fusion/Expr.mbi(3037:13-3048:13)
        ptrb = ([ 0l for _autovar_322 in xrange((numElements + 1)) ])

        subj = ([ 0l for _autovar_323 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_324 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_325 in xrange(numElements) ])
        inst = None

        if   (numElements < edi):
          inst = ([ 0l for _autovar_326 in xrange(numElements) ])
        shape = mosek.fusion.IntSet(edi)

        # { @ src/fusion/Expr.mbi(3057:13-3088:13)
        previ = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(3060:15-3087:15)
        i = 0

        while (i < int(len(e.inst))):
          ei = (e.inst[i] / long(edj))

          ej = (e.inst[i] - (ei * long(edj)))

          if   (previ < ei):
            previ = ei
            if   (inst != None):
              inst[p] = ei
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          num = (e.ptrb[(i + 1)] - e.ptrb[i])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj,ptrb[p],num) )
          c = m._data[((ej * edi) + ei)]

          # src/fusion/Expr.mbi(3076:17-3079:17)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (c * e.cof[(e.ptrb[i] + l)])
            l += 1
          if   (bfix != None):
            bfix[(p - 1)] = (bfix[(p - 1)] + (c * e.bfix[i]))
          ptrb[p] = (ptrb[p] + num)
          i += 1
        # } @ src/fusion/Expr.mbi(3057:13-3088:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    else:
      m = _autovar_317
      mnnz = ( m._numNonzeros_() )

      msubi = ([ 0 for _autovar_327 in xrange(mnnz) ])

      msubj = ([ 0 for _autovar_328 in xrange(mnnz) ])

      mval = ([ 0.0 for _autovar_329 in xrange(mnnz) ])

      perm = ( Utils.Tools._range_L (long(mnnz)) )

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      ( Sort._argsort__3L_3I_3I (perm,msubj,msubi) )
      if   (e.inst == None):
        numEntries = 0

        nnz = 0l

        # { @ src/fusion/Expr.mbi(3107:13-3115:13)
        prevj = (- 1)

        # src/fusion/Expr.mbi(3109:15-3114:15)
        k = 0

        while (k < mnnz):
          if   (prevj < msubj[perm[k]]):
            numEntries += 1
            prevj = msubj[perm[k]]
          eptrbidx = ((msubj[perm[k]] * m._dimi) + msubi[perm[k]])

          nnz = (nnz + (e.ptrb[(eptrbidx + 1)] - e.ptrb[eptrbidx]))
          k += 1
        # } @ src/fusion/Expr.mbi(3107:13-3115:13)
        ptrb = ([ 0l for _autovar_330 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_331 in xrange(nnz) ])

        cof = ([ 0.0 for _autovar_332 in xrange(nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_333 in xrange(numEntries) ])
        inst = None

        if   (numEntries < m._dimj):
          inst = ([ 0l for _autovar_334 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(m._dimj)

        # { @ src/fusion/Expr.mbi(3124:13-3149:13)
        prevj = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(3127:15-3148:15)
        k = 0

        while (k < mnnz):
          if   (prevj < msubj[perm[k]]):
            prevj = long(msubj[perm[k]])
            if   (inst != None):
              inst[p] = prevj
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          eptrbidx = ((msubj[perm[k]] * m._dimi) + msubi[perm[k]])

          num = (e.ptrb[(eptrbidx + 1)] - e.ptrb[eptrbidx])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[eptrbidx],subj,ptrb[p],num) )
          # src/fusion/Expr.mbi(3140:17-109)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (e.cof[(e.ptrb[eptrbidx] + l)] * mval[perm[k]])
            l += 1
          if   (bfix != None):
            bfix[prevj] = (bfix[prevj] + (e.bfix[eptrbidx] * mval[perm[k]]))
          ptrb[p] = (ptrb[p] + num)
          k += 1
        # } @ src/fusion/Expr.mbi(3124:13-3149:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        numEntries = 0

        nnz = 0l

        # { @ src/fusion/Expr.mbi(3158:13-3181:13)
        i = 0

        j = 0

        previ = (- 1l)

        # src/fusion/Expr.mbi(3160:15-3180:15)
        while ((i < int(len(e.inst))) and (j < mnnz)):
          curlhsi = (e.inst[i] / edj)

          curlhsj = (e.inst[i] - (curlhsi * edj))

          if   (curlhsi < msubj[perm[j]]):
            i += 1
          elif (curlhsi > msubj[perm[j]]):
            j += 1
          elif (curlhsj < msubi[perm[j]]):
            i += 1
          elif (curlhsj > msubi[perm[j]]):
            j += 1
          else:
            if   (previ < curlhsi):
              numEntries += 1
              previ = curlhsi
            nnz = (nnz + (e.ptrb[(i + 1)] - e.ptrb[i]))
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(3158:13-3181:13)
        ptrb = ([ 0l for _autovar_335 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_336 in xrange(nnz) ])

        cof = ([ 0.0 for _autovar_337 in xrange(nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_338 in xrange(numEntries) ])
        inst = None

        if   (numEntries < edi):
          inst = ([ 0l for _autovar_339 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(edi)

        # { @ src/fusion/Expr.mbi(3190:13-3225:13)
        i = 0

        j = 0

        previ = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(3192:15-3224:15)
        while ((i < int(len(e.inst))) and (j < mnnz)):
          curlhsi = (e.inst[i] / long(edj))

          curlhsj = (e.inst[i] - (curlhsi * long(edj)))

          if   (curlhsi < msubj[perm[j]]):
            i += 1
          elif (curlhsi > msubj[perm[j]]):
            j += 1
          elif (curlhsj < msubi[perm[j]]):
            i += 1
          elif (curlhsj > msubi[perm[j]]):
            j += 1
          else:
            if   (previ < curlhsi):
              if   (inst != None):
                inst[p] = curlhsi
              p += 1
              ptrb[p] = ptrb[(p - 1)]
              previ = curlhsi
            num = (e.ptrb[(i + 1)] - e.ptrb[i])

            c = mval[perm[j]]

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj,ptrb[p],num) )
            # src/fusion/Expr.mbi(3215:19-3216:62)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (c * e.cof[(e.ptrb[i] + l)])
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (c * e.bfix[i]))
            ptrb[p] = (ptrb[p] + num)
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(3190:13-3225:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(3245:15-3296:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs,rhs):
    if   (((rhs.shape.nd != 2) or (lhs._dimj != ( rhs.shape._dim_I(0) ))) or (lhs._dimi != ( rhs.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    _autovar_340 = lhs
    if   isinstance(_autovar_340,mosek.fusion.DenseMatrix):
      m = _autovar_340
      ptrb = ( Utils.Tools._range_LLL (0l,long((m._dimj * (1 + m._dimi))),long(m._dimj)) )

      subj = ([ 0l for _autovar_341 in xrange((m._dimi * m._dimj)) ])

      cof = m._data

      k = 0

      # src/fusion/Expr.mbi(3264:11-3274:11)
      i = 0

      while (i < m._dimi):
        vk = long(i)

        # src/fusion/Expr.mbi(3267:13-3273:13)
        j = 0

        while (j < m._dimj):
          subj[k] = vk
          k += 1
          vk = (vk + m._dimi)
          j += 1
        i += 1
      return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
    elif isinstance(_autovar_340,mosek.fusion.SparseMatrix):
      m = _autovar_340
      ptrb = ([ 0l for _autovar_342 in xrange((m._dimi + 1)) ])

      subj = ([ 0l for _autovar_343 in xrange(m._nnz) ])

      cof = m._val

      nnz = m._nnz

      # src/fusion/Expr.mbi(3286:11-68)
      k = 0

      while (k < nnz):
        ptrb[(m._subi[k] + 1)] += 1
        k += 1
      # src/fusion/Expr.mbi(3287:11-79)
      k = 0

      while (k < m._dimi):
        ptrb[(k + 1)] = (ptrb[k] + ptrb[(k + 1)])
        k += 1
      # src/fusion/Expr.mbi(3288:11-95)
      k = 0

      while (k < nnz):
        subj[k] = long(((m._subj[k] * m._dimi) + m._subi[k]))
        k += 1
      return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
    else:
      m = _autovar_340
      raise mosek.fusion.MatrixError("Unknown matrix type used.")
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(3309:15-3371:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs_):
    if   (((lhs.shape.nd != 2) or (rhs_._dimj != ( lhs.shape._dim_I(0) ))) or (rhs_._dimi != ( lhs.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    d = long(rhs_._dimj)

    _autovar_344 = rhs_
    if   isinstance(_autovar_344,mosek.fusion.DenseMatrix):
      m = _autovar_344
      nnz = (d * m._dimi)

      ptrb = ( Utils.Tools._range_LLL (0l,(d * (1l + d)),d) )

      subj = ( Utils.Tools._range_LL (0l,nnz) )

      cof = ([ 0.0 for _autovar_345 in xrange(nnz) ])

      k = 0

      # src/fusion/Expr.mbi(3332:11-3339:11)
      i = 0l

      while (i < m._dimj):
        # src/fusion/Expr.mbi(3334:13-3338:13)
        j = 0l

        while (j < m._dimi):
          cof[k] = m._data[((j * d) + i)]
          k += 1
          j += 1
        i += 1
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,None,None,1)
    else:
      m = _autovar_344
      nnz = ( m._numNonzeros_() )

      ptrb = ([ 0l for _autovar_346 in xrange((d + 1)) ])

      subj = ([ 0l for _autovar_347 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_348 in xrange(nnz) ])

      msubi = ([ 0 for _autovar_349 in xrange(nnz) ])

      msubj = ([ 0 for _autovar_350 in xrange(nnz) ])

      mval = ([ 0.0 for _autovar_351 in xrange(nnz) ])

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      # src/fusion/Expr.mbi(3356:11-63)
      k = 0

      while (k < nnz):
        ptrb[(msubj[k] + 1)] += 1
        k += 1
      # src/fusion/Expr.mbi(3357:11-76)
      k = 0

      while (k < d):
        ptrb[(k + 1)] = (ptrb[k] + ptrb[(k + 1)])
        k += 1
      # src/fusion/Expr.mbi(3358:11-3364:11)
      k = 0

      while (k < nnz):
        idx = ptrb[msubj[k]]

        cof[idx] = mval[k]
        subj[idx] = long(((msubj[k] * m._dimi) + msubi[k]))
        ptrb[msubj[k]] += 1
        k += 1
      # src/fusion/Expr.mbi(3366:11-62)
      k = d

      while (k > 0):
        ptrb[k] = ptrb[(k - 1)]
        k -= 1
      ptrb[0] = 0l
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,None,None,1)
  @staticmethod
  def _matchargs_computeNz__3L_3I_3L_3III_3I_3L(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3381:17-3423:8)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("computeNz([int64],[int32],[int64],[int32],int,int,[int32],[int64])")
  def __computeNz__3L_3I_3L_3III_3I_3L(a_ptrb,a_subj,b_ptrb,b_subj,rows,cols,flag,c_ptrb):
    nz = 0l

    mark = 0

    # src/fusion/Expr.mbi(3393:10-3396:10)
    i = 0

    while (i < cols):
      flag[i] = 0
      i += 1
    # src/fusion/Expr.mbi(3398:10-3418:10)
    a_row = 0

    while (a_row < rows):
      mark += 1
      c_ptrb[a_row] = nz
      # src/fusion/Expr.mbi(3403:12-3417:12)
      idx = a_ptrb[a_row]

      while (idx < a_ptrb[(a_row + 1)]):
        b_row = a_subj[idx]

        # src/fusion/Expr.mbi(3407:14-3416:14)
        b_offset = b_ptrb[b_row]

        while (b_offset < b_ptrb[(b_row + 1)]):
          i = b_subj[b_offset]

          if   (flag[i] != mark):
            nz += 1
            flag[i] = mark
          b_offset += 1
        idx += 1
      a_row += 1
    c_ptrb[rows] = nz
    return nz
  @staticmethod
  def _matchargs_sparseMatmul__3L_3I_3F_3L_3I_3F_3L_3I_3FII_3I(args):
    if len(args) != 12:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[9],int): return False
    if not isinstance(args[10],int): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3427:16-3485:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseMatmul([int64],[int32],[double],[int64],[int32],[double],[int64],[int32],[double],int,int,[int32])")
  def __sparseMatmul__3L_3I_3F_3L_3I_3F_3L_3I_3FII_3I(c_ptrb,c_subj,c_cof,a_ptrb,a_subj,a_cof,b_ptrb,b_subj,b_cof,rows,cols,flag):
    nz = 0

    nz_start = 0

    val = ([ 0.0 for _autovar_352 in xrange(cols) ])

    # src/fusion/Expr.mbi(3444:10-3448:10)
    i = 0

    while (i < cols):
      flag[i] = (- 1)
      val[i] = 0.0
      i += 1
    # src/fusion/Expr.mbi(3451:10-3484:10)
    a_row = 0

    while (a_row < rows):
      nz_start = nz
      # src/fusion/Expr.mbi(3455:12-3476:12)
      idx = a_ptrb[a_row]

      while (idx < a_ptrb[(a_row + 1)]):
        b_row = a_subj[idx]

        a_val = a_cof[idx]

        # src/fusion/Expr.mbi(3460:14-3475:14)
        b_offset = b_ptrb[b_row]

        while (b_offset < b_ptrb[(b_row + 1)]):
          i = b_subj[b_offset]

          if   (flag[i] < nz_start):
            flag[i] = nz
            val[i] = (a_val * b_cof[b_offset])
            c_subj[nz] = i
            nz += 1
          else:
            val[i] = (val[i] + (a_val * b_cof[b_offset]))
          b_offset += 1
        idx += 1
      ( Utils.Tools._sort__3III (c_subj,nz_start,nz) )
      # src/fusion/Expr.mbi(3479:12-3483:12)
      i = nz_start

      while (i < nz):
        c_cof[i] = val[c_subj[i]]
        val[c_subj[i]] = 0.0
        i += 1
      a_row += 1
  @staticmethod
  def _matchargs_sparseMatrixVector__3L_3I_3F_3F_3FI(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[5],int): return False
    return True
  # origin: src/fusion/Expr.mbi(3488:16-3507:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseMatrixVector([int64],[int32],[double],[double],[double],int)")
  def __sparseMatrixVector__3L_3I_3F_3F_3FI(aPtrb,aSubj,aCof,b,w,numARows):
    # src/fusion/Expr.mbi(3494:9-3497:9)
    i = 0

    while (i < numARows):
      w[i] = 0.0
      i += 1
    # src/fusion/Expr.mbi(3499:9-3506:9)
    row = 0

    while (row < numARows):
      # src/fusion/Expr.mbi(3501:11-3505:11)
      p = aPtrb[row]

      while (p < aPtrb[(row + 1)]):
        index = aSubj[p]

        w[row] = (w[row] + (b[index] * aCof[index]))
        p += 1
      row += 1
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3519:15-3993:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs_):
    if   (rhs_._shape.nd > 2):
      raise mosek.fusion.DimensionError("Expression operand must have 1 or 2 dimensions")
    if   (( rhs_._shape._dim_I(0) ) != lhs._dimj):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    e = ( rhs_._eval_() )


    edi = ( e.shape._dim_I(0) )

    edj = 1

    nd = 1

    if   (e.shape.nd == 2):
      edj = ( e.shape._dim_I(1) )
      nd = 2
      shape = mosek.fusion.NDSet(lhs._dimi,edj)
    else:
      shape = mosek.fusion.IntSet(lhs._dimi)

    _autovar_353 = lhs
    if   isinstance(_autovar_353,mosek.fusion.DenseMatrix):
      m = _autovar_353
      if   (e.inst == None):
        numEntries = (m._dimi * edj)

        ptrb = ([ 0l for _autovar_354 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_355 in xrange((e.nnz * m._dimi)) ])

        cof = ([ 0.0 for _autovar_356 in xrange((e.nnz * m._dimi)) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_357 in xrange(numEntries) ])
        p = 1

        # src/fusion/Expr.mbi(3566:13-3590:13)
        i = 0

        while (i < m._dimi):
          # src/fusion/Expr.mbi(3568:15-3589:15)
          j = 0

          while (j < edj):
            ptrbase = ptrb[(p - 1)]

            # src/fusion/Expr.mbi(3571:17-3586:17)
            k = 0

            while (k < edi):
              idx = ((k * edj) + j)

              num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

              curcof = m._data[((i * m._dimj) + k)]

              # src/fusion/Expr.mbi(3576:19-3580:19)
              l = 0

              while (l < num):
                cof[(ptrbase + l)] = (e.cof[(e.ptrb[idx] + l)] * curcof)
                subj[(ptrbase + l)] = e.subj[(e.ptrb[idx] + l)]
                l += 1
              ptrbase = (ptrbase + num)
              if   (e.bfix != None):
                bfix[(p - 1)] = (bfix[(p - 1)] + (e.bfix[idx] * curcof))
              k += 1
            ptrb[p] = ptrbase
            p += 1
            j += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,None)
      else:
        nelm = int(len(e.inst))

        esubi = ([ 0 for _autovar_358 in xrange(nelm) ])

        esubj = ([ 0 for _autovar_359 in xrange(nelm) ])

        perm = ( Utils.Tools._range_L (long(len(e.inst))) )

        # src/fusion/Expr.mbi(3600:13-3604:13)
        k = 0

        while (k < nelm):
          esubi[k] = int((e.inst[k] / edj))
          esubj[k] = int((e.inst[k] - esubi[k]))
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numRhsCol = 0

        if   (int(len(esubj)) > 0):
          numRhsCol = 1
          # src/fusion/Expr.mbi(3610:15-104)
          k = 1

          while (k < nelm):
            if   (esubj[perm[k]] > esubj[perm[(k - 1)]]):
              numRhsCol += 1
            k += 1
        numEntries = (numRhsCol * m._dimi)

        ptrb = ([ 0l for _autovar_360 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_361 in xrange((e.nnz * m._dimi)) ])

        cof = ([ 0.0 for _autovar_362 in xrange((e.nnz * m._dimi)) ])

        bfix = None

        inst = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_363 in xrange(numEntries) ])
        if   (numRhsCol < edj):
          inst = ([ 0l for _autovar_364 in xrange(numEntries) ])
        ptridx = 0

        # src/fusion/Expr.mbi(3628:13-3684:13)
        i = 0

        while (i < m._dimi):
          mrowbase = long((m._dimj * i))

          # src/fusion/Expr.mbi(3637:15-3683:15)
          k = 0

          while (k < nelm):
            if   ((k == 0) or (esubj[perm[k]] > esubj[perm[(k - 1)]])):
              ptridx += 1
              ptrb[ptridx] = ptrb[(ptridx - 1)]
              if   (inst != None):
                inst[(ptridx - 1)] = ((long(i) * edj) + esubj[perm[k]])
            eptrbpk = e.ptrb[perm[k]]

            num = (e.ptrb[(perm[k] + 1)] - eptrbpk)

            lhscof = m._data[(mrowbase + esubi[perm[k]])]

            # src/fusion/Expr.mbi(3660:17-3664:17)
            l = 0

            while (l < num):
              subj[(ptrb[ptridx] + l)] = e.subj[(eptrbpk + l)]
              cof[(ptrb[ptridx] + l)] = (e.cof[(eptrbpk + l)] * lhscof)
              l += 1
            if   (bfix != None):
              bfix[(ptridx - 1)] = (bfix[(ptridx - 1)] + (e.bfix[perm[k]] * lhscof))
            if   (inst != None):
              inst[(ptridx - 1)] = long(esubj[perm[k]])
            ptrb[ptridx] = (ptrb[ptridx] + num)
            k += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    else:
      m = _autovar_353
      numMatNz = ( m._numNonzeros_() )

      msubi = ([ 0 for _autovar_365 in xrange(numMatNz) ])

      msubj = ([ 0 for _autovar_366 in xrange(numMatNz) ])

      mval = ([ 0.0 for _autovar_367 in xrange(numMatNz) ])

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      if   (e.inst == None):
        numLhsRow = 1l

        # src/fusion/Expr.mbi(3699:13-84)
        for i in xrange(1l,numMatNz):
          # { @ src/fusion/Expr.mbi(3699:42-84)
          if   (msubi[i] > msubi[(i - 1)]):
            numLhsRow += 1
          # } @ src/fusion/Expr.mbi(3699:42-84)
        numResElm = (numLhsRow * edj)

        ptrb = ([ 0l for _autovar_368 in xrange((numResElm + 1)) ])

        resNnz = 0l

        # { @ src/fusion/Expr.mbi(3704:13-3724:13)
        prevMsubi = msubi[0]

        resBase = 0l

        # src/fusion/Expr.mbi(3707:15-3723:15)
        for i in xrange(0l,numMatNz):
          # { @ src/fusion/Expr.mbi(3708:15-3723:15)
          if   (prevMsubi < msubi[i]):
            resBase = (resBase + edj)
            prevMsubi = msubi[i]
          # src/fusion/Expr.mbi(3715:17-3722:17)
          for j in xrange(0,edj):
            # { @ src/fusion/Expr.mbi(3716:17-3722:17)
            idx = ((msubj[i] * edj) + j)

            num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

            resNnz = (resNnz + num)
            ptrb[((resBase + j) + 1)] = (ptrb[((resBase + j) + 1)] + num)
            # } @ src/fusion/Expr.mbi(3716:17-3722:17)
          # } @ src/fusion/Expr.mbi(3708:15-3723:15)
        # } @ src/fusion/Expr.mbi(3704:13-3724:13)
        subj = ([ 0l for _autovar_369 in xrange(resNnz) ])

        cof = ([ 0.0 for _autovar_370 in xrange(resNnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_371 in xrange(numResElm) ])
        # src/fusion/Expr.mbi(3731:13-84)
        i = 0

        while (i < numResElm):
          ptrb[(i + 1)] = (ptrb[i] + ptrb[(i + 1)])
          i += 1
        inst = None

        if   (numLhsRow < m._dimi):
          inst = ([ 0l for _autovar_372 in xrange(numResElm) ])
        # { @ src/fusion/Expr.mbi(3745:13-3778:13)
        resBase = 0l

        prevMsubi = msubi[0]

        # src/fusion/Expr.mbi(3748:15-3777:15)
        i = 0

        while (i < numMatNz):
          mcof = mval[i]

          if   (prevMsubi < msubi[i]):
            resBase = (resBase + edj)
            prevMsubi = msubi[i]
          # src/fusion/Expr.mbi(3757:17-3774:17)
          j = 0

          while (j < edj):
            idx = ((msubj[i] * edj) + j)

            num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

            # src/fusion/Expr.mbi(3762:19-3766:19)
            k = 0

            while (k < num):
              cof[(ptrb[(resBase + j)] + k)] = (e.cof[(e.ptrb[idx] + k)] * mcof)
              subj[(ptrb[(resBase + j)] + k)] = e.subj[(e.ptrb[idx] + k)]
              k += 1
            if   (bfix != None):
              bfix[(resBase + j)] = (bfix[(resBase + j)] + (e.bfix[idx] * mcof))
            ptrb[(resBase + j)] = (ptrb[(resBase + j)] + num)
            if   (inst != None):
              inst[(resBase + j)] = long(((msubi[i] * edj) + j))
            j += 1
          i += 1
        # } @ src/fusion/Expr.mbi(3745:13-3778:13)
        # src/fusion/Expr.mbi(3779:13-3780:34)
        i = (int(len(ptrb)) - 1)

        while (i > 0):
          ptrb[i] = ptrb[(i - 1)]
          i -= 1
        ptrb[0] = 0l
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        lhsNumNz = ( lhs._numNonzeros_() )

        nelm = int(len(e.inst))

        esubi = ([ 0 for _autovar_373 in xrange(nelm) ])

        esubj = ([ 0 for _autovar_374 in xrange(nelm) ])

        perm = ( Utils.Tools._range_L (long(len(e.inst))) )

        # src/fusion/Expr.mbi(3794:13-3798:13)
        k = 0

        while (k < nelm):
          esubi[k] = int((e.inst[k] / edj))
          esubj[k] = int((e.inst[k] - esubi[k]))
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numResElm = 0l

        numResNz = 0l

        # { @ src/fusion/Expr.mbi(3804:13-3855:13)
        # src/fusion/Expr.mbi(3805:15-3854:15)
        lhs_row_start = 0

        while (lhs_row_start < lhsNumNz):
          lhs_row_end = lhs_row_start

          # src/fusion/Expr.mbi(3807:50-144)
          while ((lhs_row_end < lhsNumNz) and (msubi[lhs_row_end] == msubi[lhs_row_start])):
            pass
            lhs_row_end += 1
          matRowIdx = msubi[lhs_row_start]

          rhs_col_idx = esubj[perm[0]]

          # { @ src/fusion/Expr.mbi(3814:17-3851:17)
          # src/fusion/Expr.mbi(3815:19-3850:19)
          rhs_col_start = 0

          while (rhs_col_start < nelm):

            # src/fusion/Expr.mbi(3818:21-3821:22)
            rhs_col_end = (rhs_col_start + 1)
            while ((rhs_col_end < nelm) and (esubj[perm[rhs_col_end]] == esubj[perm[(rhs_col_end - 1)]])):
              pass
              rhs_col_end += 1
            i = lhs_row_start

            k = rhs_col_start

            old_nnz = numResNz

            # src/fusion/Expr.mbi(3829:21-3842:21)
            while ((i < lhs_row_end) and (k < rhs_col_end)):
              if   (msubj[i] < esubi[perm[k]]):
                i += 1
              elif (msubj[i] > esubi[perm[k]]):
                k += 1
              else:
                numResNz = (numResNz + (e.ptrb[(perm[k] + 1)] - e.ptrb[perm[k]]))
                k += 1
                i += 1
            if   (old_nnz < numResNz):
              numResElm += 1
            rhs_col_start = rhs_col_end
          # } @ src/fusion/Expr.mbi(3814:17-3851:17)
          lhs_row_start = lhs_row_end
        # } @ src/fusion/Expr.mbi(3804:13-3855:13)
        ptrb = ([ 0l for _autovar_375 in xrange((numResElm + 1)) ])

        subj = ([ 0l for _autovar_376 in xrange(numResNz) ])

        cof = ([ 0.0 for _autovar_377 in xrange(numResNz) ])

        inst = ([ 0l for _autovar_378 in xrange(numResElm) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_379 in xrange(numResElm) ])
        # { @ src/fusion/Expr.mbi(3879:13-3936:13)
        ptridx = 0

        resptr = 0l

        resptridx = 0

        # src/fusion/Expr.mbi(3883:15-3935:15)
        lhs_row_start = 0

        while (lhs_row_start < lhsNumNz):
          lhs_row_end = lhs_row_start

          # src/fusion/Expr.mbi(3885:50-144)
          while ((lhs_row_end < lhsNumNz) and (msubi[lhs_row_end] == msubi[lhs_row_start])):
            pass
            lhs_row_end += 1
          matRowIdx = msubi[lhs_row_start]

          rhs_col_idx = esubj[perm[0]]

          # { @ src/fusion/Expr.mbi(3889:17-3932:17)
          # src/fusion/Expr.mbi(3890:19-3931:19)
          rhs_col_start = 0

          while (rhs_col_start < nelm):

            # src/fusion/Expr.mbi(3893:21-3896:22)
            rhs_col_end = (rhs_col_start + 1)
            while ((rhs_col_end < nelm) and (esubj[perm[rhs_col_end]] == esubj[perm[(rhs_col_end - 1)]])):
              pass
              rhs_col_end += 1
            i = lhs_row_start

            k = rhs_col_start

            old_nnz = resptr

            # src/fusion/Expr.mbi(3901:21-3921:21)
            while ((i < lhs_row_end) and (k < rhs_col_end)):
              if   (msubj[i] < esubi[perm[k]]):
                i += 1
              elif (msubj[i] > esubi[perm[k]]):
                k += 1
              else:
                b = e.ptrb[perm[k]]

                num = (e.ptrb[(perm[k] + 1)] - b)

                ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[perm[k]],subj,resptr,num) )
                # src/fusion/Expr.mbi(3911:25-95)
                l = 0

                while (l < num):
                  cof[(resptr + l)] = (e.cof[(b + l)] * mval[i])
                  l += 1
                if   (bfix != None):
                  bfix[resptridx] = (bfix[resptridx] + (e.bfix[perm[k]] * mval[i]))
                resptr = (resptr + num)
                k += 1
                i += 1
            if   (old_nnz < resptr):
              inst[resptridx] = (long((msubi[lhs_row_start] * edj)) + esubj[perm[rhs_col_start]])
              resptridx += 1
              ptrb[resptridx] = resptr
            rhs_col_start = rhs_col_end
          # } @ src/fusion/Expr.mbi(3889:17-3932:17)
          lhs_row_start = lhs_row_end
        # } @ src/fusion/Expr.mbi(3879:13-3936:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_mul_1_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3997:16-4103:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def __mul_1_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs_):
    rhs = ( rhs_._eval_() )



    if   (rhs.shape != None):
      nd = 0
      # src/fusion/Expr.mbi(4009:11-88)
      i = 0

      while (i < rhs.shape.nd):
        if   (( rhs.shape._dim_I(i) ) > 1):
          nd += 1
        i += 1
      if   (nd == 0):
        nd = 1
    else:
      nd = 1
    if   (rhs.inst == None):
      if   (nd == 1):
        cRows = ( lhs._numRows_() )

        cCols = int(rhs.x.shape._size)

        if   (lhs._dimj != ( rhs._size_() )):
          raise mosek.fusion.LengthError("Dimensions of operands do not match")
        _autovar_380 = lhs
        if   isinstance(_autovar_380,mosek.fusion.SparseMatrix):
          m = _autovar_380
          cPtrb = ([ 0l for _autovar_381 in xrange((cRows + 1)) ])

          flag = ([ 0 for _autovar_382 in xrange(cCols) ])

          aPtrb = ( m._formPtrb_() )

          aSubj = m._subj

          aCof = m._val

          bPtrb = rhs.ptrb

          bSubj = ([ 0 for _autovar_383 in xrange(long(len(rhs.subj))) ])

          # src/fusion/Expr.mbi(4040:15-93)
          i = 0l

          while (i < long(len(rhs.subj))):
            bSubj[i] = int(rhs.subj[i])
            i += 1
          bCof = rhs.cof

          nz = ( Expr.__computeNz__3L_3I_3L_3III_3I_3L (aPtrb,aSubj,bPtrb,bSubj,cRows,cCols,flag,cPtrb) )
          cCof = ([ 0.0 for _autovar_384 in xrange(nz) ])

          cSubj = ([ 0 for _autovar_385 in xrange(nz) ])

          ( Expr.__sparseMatmul__3L_3I_3F_3L_3I_3F_3L_3I_3FII_3I (cPtrb,cSubj,cCof,aPtrb,aSubj,aCof,bPtrb,bSubj,bCof,cRows,cCols,flag) )
          newBFixed = None

          if   (rhs.bfix != None):
            newBFixed = ([ 0.0 for _autovar_386 in xrange(( lhs._numRows_() )) ])
            ( Expr.__sparseMatrixVector__3L_3I_3F_3F_3FI (aPtrb,aSubj,aCof,rhs.bfix,newBFixed,( lhs._numRows_() )) )
          csubjl = ([ 0l for _autovar_387 in xrange(nz) ])

          # src/fusion/Expr.mbi(4082:15-75)
          i = 0

          while (i < nz):
            csubjl[i] = long(cSubj[i])
            i += 1
          return mosek.fusion.Expr(cPtrb,rhs.x,csubjl,cCof,newBFixed,None,None,1)
        elif isinstance(_autovar_380,mosek.fusion.DenseMatrix):
          m = _autovar_380
          return ( Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2 (( Matrix._sparse_Omosek_fusion_Matrix_2 (m) ),rhs_) )
        else:
          m = _autovar_380
          raise mosek.fusion.MatrixError("Unknown matrix type used.")
      else:
        raise mosek.fusion.UnimplementedError("Multiplication with multidimensional expression")
    else:
      raise mosek.fusion.UnimplementedError("Multiplication with sparse expression")
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4118:15-4230:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs,rhs):



    if   (rhs.shape.nd == 1):
      if   (lhs._dimj != rhs.shape._size):
        raise mosek.fusion.LengthError("Operand shapes do not match.")
      vdimi = ( rhs.shape._dim_I(0) )
      vdimj = 1
      shape = mosek.fusion.IntSet(lhs._dimi)
    elif (rhs.shape.nd == 2):
      if   (lhs._dimj != ( rhs.shape._dim_I(0) )):
        raise mosek.fusion.LengthError("Operand shapes do not match.")
      vdimi = ( rhs.shape._dim_I(0) )
      vdimj = ( rhs.shape._dim_I(1) )
      shape = mosek.fusion.NDSet(lhs._dimi,vdimj)
    else:
      raise mosek.fusion.LengthError("Variable must be one- or two-dimensional.")
    # { @ src/fusion/Expr.mbi(4148:9-4229:9)
    _autovar_388 = lhs
    if   isinstance(_autovar_388,mosek.fusion.DenseMatrix):
      m = _autovar_388
      nelm = shape._size

      rnnz = (shape._size * m._dimj)

      ptrb = ( Utils.Tools._range_LLL (0l,(rnnz + vdimi),long(vdimi)) )

      subj = ([ 0l for _autovar_389 in xrange(rnnz) ])

      cof = ([ 0.0 for _autovar_390 in xrange(rnnz) ])

      # { @ src/fusion/Expr.mbi(4157:13-4172:13)
      p = 0l

      # src/fusion/Expr.mbi(4159:15-4171:15)
      i = 0l

      while (i < m._dimi):
        b = (i * m._dimj)

        # src/fusion/Expr.mbi(4162:17-4170:17)
        j = 0l

        while (j < vdimj):
          # src/fusion/Expr.mbi(4164:19-4167:19)
          k = 0l

          while (k < vdimi):
            subj[(p + k)] = ((k * vdimj) + j)
            k += 1
          ( Utils.Tools._arraycopy__3FL_3FLL (m._data,b,cof,p,long(vdimi)) )
          p = (p + vdimi)
          j += 1
        i += 1
      # } @ src/fusion/Expr.mbi(4157:13-4172:13)
      return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,shape,None)
    else:
      m = _autovar_388
      mnnz = ( m._numNonzeros_() )

      if   (mnnz > 0):
        msubi = ([ 0 for _autovar_391 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_392 in xrange(mnnz) ])

        mval = ([ 0.0 for _autovar_393 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
        rnnz = (mnnz * vdimj)

        rnrow = 0l

        if   (mnnz > 0):
          rnrow = 1l
          # src/fusion/Expr.mbi(4189:17-4190:59)
          for k in xrange(1l,mnnz):
            # { @ src/fusion/Expr.mbi(4190:17-59)
            if   (msubi[k] > msubi[(k - 1)]):
              rnrow += 1
            # } @ src/fusion/Expr.mbi(4190:17-59)
        rnelm = (rnrow * vdimj)

        ptrb = ([ 0l for _autovar_394 in xrange((rnelm + 1)) ])

        inst = None

        if   (rnrow < m._dimi):
          inst = ([ 0l for _autovar_395 in xrange(rnelm) ])
        subj = ([ 0l for _autovar_396 in xrange(rnnz) ])

        cof = ([ 0.0 for _autovar_397 in xrange(rnnz) ])

        # { @ src/fusion/Expr.mbi(4197:15-4221:15)
        mrowstart = 0l

        p = 0l

        ptrbase = 1l

        # src/fusion/Expr.mbi(4201:17-4220:17)
        while (mrowstart < mnnz):
          mrowend = (mrowstart + 1)

          # src/fusion/Expr.mbi(4203:46-117)
          while ((mrowend < mnnz) and (msubi[mrowend] == msubi[mrowstart])):
            mrowend += 1
          n = (mrowend - mrowstart)

          # src/fusion/Expr.mbi(4206:19-4218:19)
          k = 0

          while (k < vdimj):
            # src/fusion/Expr.mbi(4208:21-4212:21)
            l = 0

            while (l < n):
              subj[(p + l)] = ((long(msubj[(mrowstart + l)]) * long(vdimj)) + k)
              cof[(p + l)] = mval[(mrowstart + l)]
              l += 1
            p = (p + n)
            ptrb[ptrbase] = p
            if   (inst != None):
              inst[(ptrbase - 1)] = ((long(msubi[mrowstart]) * long(vdimj)) + k)
            ptrbase += 1
            k += 1
          mrowstart = mrowend
        # } @ src/fusion/Expr.mbi(4197:15-4221:15)
        return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,shape,inst)
      else:
        return mosek.fusion.Expr(([ 0l]),rhs,([ 0l for _autovar_398 in xrange(0) ]),([ 0.0 for _autovar_399 in xrange(0) ]),None,shape,([ 0l for _autovar_400 in xrange(0) ]))
    # } @ src/fusion/Expr.mbi(4148:9-4229:9)
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4243:15-4362:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs):



    if   (lhs.shape.nd == 1):
      if   (rhs._dimi != lhs.shape._size):
        raise mosek.fusion.LengthError("Operand shapes do not match.")
      vdimi = 1
      vdimj = ( lhs.shape._dim_I(0) )
      shape = mosek.fusion.IntSet(rhs._dimj)
    elif (lhs.shape.nd == 2):
      if   (rhs._dimi != ( lhs.shape._dim_I(1) )):
        raise mosek.fusion.LengthError("Operand shapes do not match.")
      vdimi = ( lhs.shape._dim_I(0) )
      vdimj = ( lhs.shape._dim_I(1) )
      shape = mosek.fusion.NDSet(vdimi,rhs._dimj)
    else:
      raise mosek.fusion.LengthError("Variable must be one- or two-dimensional.")
    _autovar_401 = rhs
    if   isinstance(_autovar_401,mosek.fusion.DenseMatrix):
      m = _autovar_401
      rnelm = (long(vdimi) * long(m._dimj))

      ptrb = ( Utils.Tools._range_LLL (0l,((rnelm + 1) * long(vdimj)),long(vdimj)) )

      subj = ([ 0l for _autovar_402 in xrange((rnelm * long(m._dimi))) ])

      cof = ([ 0.0 for _autovar_403 in xrange((rnelm * long(m._dimi))) ])

      # { @ src/fusion/Expr.mbi(4286:11-4304:11)
      ptridx = 0l

      vidx = 0l

      # src/fusion/Expr.mbi(4289:13-4303:13)
      for i in xrange(0,vdimi):
        # { @ src/fusion/Expr.mbi(4290:13-4303:13)
        # src/fusion/Expr.mbi(4291:15-4301:15)
        for j in xrange(0,m._dimj):
          # { @ src/fusion/Expr.mbi(4292:15-4301:15)
          midx = long(j)

          # src/fusion/Expr.mbi(4294:17-4299:17)
          for k in xrange(0,vdimj):
            # { @ src/fusion/Expr.mbi(4295:17-4299:17)
            subj[(ptrb[ptridx] + k)] = (vidx + k)
            cof[(ptrb[ptridx] + k)] = m._data[midx]
            midx = (midx + m._dimj)
            # } @ src/fusion/Expr.mbi(4295:17-4299:17)
          ptridx += 1
          # } @ src/fusion/Expr.mbi(4292:15-4301:15)
        vidx = (vidx + vdimj)
        # } @ src/fusion/Expr.mbi(4290:13-4303:13)
      # } @ src/fusion/Expr.mbi(4286:11-4304:11)
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,shape,None)
    else:
      m = _autovar_401
      mnnz = ( m._numNonzeros_() )

      msubi = ([ 0 for _autovar_404 in xrange(mnnz) ])

      msubj = ([ 0 for _autovar_405 in xrange(mnnz) ])

      mval = ([ 0.0 for _autovar_406 in xrange(mnnz) ])

      perm = ( Utils.Tools._range_L (mnnz) )

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      ( Sort._argsort__3L_3I_3I (perm,msubj,msubi) )
      mncol = 0l

      if   (mnnz > 0):
        mncol = 1l
        # src/fusion/Expr.mbi(4322:13-4324:14)
        i = 1l

        while (i < mnnz):
          if   (msubj[perm[i]] > msubj[perm[(i - 1)]]):
            mncol += 1
          i += 1
      ptrb = ([ 0l for _autovar_407 in xrange(((mncol * long(vdimi)) + 1)) ])

      subj = ([ 0l for _autovar_408 in xrange((mnnz * vdimi)) ])

      cof = ([ 0.0 for _autovar_409 in xrange((mnnz * vdimi)) ])

      inst = None

      if   (mncol < m._dimj):
        inst = ([ 0l for _autovar_410 in xrange((int(len(ptrb)) - 1)) ])
      # { @ src/fusion/Expr.mbi(4333:11-4355:11)
      ptridx = 0l

      b = 0l

      # src/fusion/Expr.mbi(4337:13-4353:13)
      i = 0

      while (i < vdimi):
        # src/fusion/Expr.mbi(4339:15-4352:15)
        k = 0l

        while (k < mnnz):
          if   ((k == 0) or (msubj[perm[k]] > msubj[perm[(k - 1)]])):
            if   (inst != None):
              inst[ptridx] = ((long(i) * m._dimj) + msubj[perm[k]])
            ptrb[ptridx] = b
            ptridx += 1
          subj[b] = ((long(i) * long(vdimj)) + msubi[perm[k]])
          cof[b] = mval[perm[k]]
          b += 1
          k += 1
        i += 1
      ptrb[ptridx] = b
      # } @ src/fusion/Expr.mbi(4333:11-4355:11)
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,shape,inst)
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4372:15-4508:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   (((lhs._shape.nd != 2) or (( lhs._shape._dim_I(0) ) != rhs._dimi)) or (( lhs._shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    lfe = ( lhs._eval_() )

    if   (lfe.inst == None):

      if   (lfe.bfix == None):
        bfix = ([ 0.0 for _autovar_411 in xrange((rhs._dimi * rhs._dimj)) ])
      else:
        bfix = lfe.bfix
      _autovar_412 = rhs
      if   isinstance(_autovar_412,mosek.fusion.DenseMatrix):
        m = _autovar_412
        # src/fusion/Expr.mbi(4395:13-4396:44)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (bfix[i] - m._data[i])
      else:
        m = _autovar_412
        subi_ = ([ 0 for _autovar_413 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_414 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_415 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(4407:13-4411:13)
        for i in xrange(0l,( m._numNonzeros_() )):
          # { @ src/fusion/Expr.mbi(4408:13-4411:13)
          idx = ((subi_[i] * m._dimj) + subj_[i])

          bfix[idx] = (bfix[idx] - val_[i])
          # } @ src/fusion/Expr.mbi(4408:13-4411:13)
      return mosek.fusion.Expr(lfe.ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
    else:
      _autovar_416 = rhs
      if   isinstance(_autovar_416,mosek.fusion.DenseMatrix):
        m = _autovar_416
        rnnz = ( m._numNonzeros_() )

        ptrb = ([ 0l for _autovar_417 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_418 in xrange(rnnz) ])

        # src/fusion/Expr.mbi(4425:13-62)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (- m._data[i])
        if   (lfe.bfix == None):
          # src/fusion/Expr.mbi(4427:15-4428:68)
          for i in xrange(0,int(len(lfe.bfix))):
            bfix[lfe.inst[i]] = (bfix[lfe.inst[i]] + lfe.bfix[i])
        # src/fusion/Expr.mbi(4430:13-81)
        for i in xrange(0,int(len(lfe.inst))):
          ptrb[(lfe.inst[i] + 1)] = lfe.ptrb[(i + 1)]
        # src/fusion/Expr.mbi(4431:13-4434:21)
        for i in xrange(1,int(len(ptrb))):
          if   (ptrb[i] == 0):
            ptrb[i] = ptrb[(i - 1)]
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
      else:
        m = _autovar_416
        subi_ = ([ 0 for _autovar_419 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_420 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_421 in xrange(( m._numNonzeros_() )) ])

        lidx = ([ 0l for _autovar_422 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(4443:13-92)
        for i in xrange(0l,( m._numNonzeros_() )):
          lidx[i] = long(((subi_[i] * m._dimj) + subj_[i]))
        rnnz = 0

        # { @ src/fusion/Expr.mbi(4447:13-4456:13)
        i = 0

        j = 0

        # src/fusion/Expr.mbi(4449:15-4453:44)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            i += 1
            rnnz += 1
          elif (lfe.inst[i] > lidx[j]):
            j += 1
            rnnz += 1
          else:
            i += 1
            j += 1
            rnnz += 1
        if   (i < int(len(lfe.inst))):
          rnnz = ((rnnz + int(len(lfe.inst))) - i)
        if   (j < int(len(lidx))):
          rnnz = ((rnnz + int(len(lidx))) - j)
        # } @ src/fusion/Expr.mbi(4447:13-4456:13)
        ptrb = ([ 0l for _autovar_423 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_424 in xrange(rnnz) ])

        inst = ([ 0l for _autovar_425 in xrange(rnnz) ])

        # { @ src/fusion/Expr.mbi(4462:13-4503:13)
        i = 0

        j = 0

        k = 0

        # src/fusion/Expr.mbi(4464:15-4488:15)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            if   (lfe.bfix != None):
              bfix[k] = lfe.bfix[i]
            inst[k] = lfe.inst[i]
            i += 1
          elif (lfe.inst[i] > lidx[j]):
            bfix[k] = (- val_[j])
            inst[k] = lidx[j]
            j += 1
          else:
            if   (lfe.bfix != None):
              bfix[k] = (lfe.bfix[i] - val_[j])
            else:
              bfix[k] = (- val_[j])
            inst[k] = lidx[j]
            i += 1
            j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(4489:15-4495:15)
        while (i < int(len(lfe.inst))):
          if   (lfe.bfix != None):
            bfix[k] = lfe.bfix[i]
          inst[k] = lfe.inst[i]
          i += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(4496:15-4502:15)
        while (j < int(len(lidx))):
          bfix[k] = (- val_[j])
          inst[k] = lidx[j]
          j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # } @ src/fusion/Expr.mbi(4462:13-4503:13)
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4522:15-4657:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   (((lhs._shape.nd != 2) or (( lhs._shape._dim_I(0) ) != rhs._dimi)) or (( lhs._shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    lfe = ( lhs._eval_() )

    if   (lfe.inst == None):

      if   (lfe.bfix == None):
        bfix = ([ 0.0 for _autovar_426 in xrange((rhs._dimi * rhs._dimj)) ])
      else:
        bfix = lfe.bfix
      _autovar_427 = rhs
      if   isinstance(_autovar_427,mosek.fusion.DenseMatrix):
        m = _autovar_427
        # src/fusion/Expr.mbi(4545:13-4546:44)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (bfix[i] + m._data[i])
      else:
        m = _autovar_427
        subi_ = ([ 0 for _autovar_428 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_429 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_430 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(4557:13-4561:13)
        for i in xrange(0l,( m._numNonzeros_() )):
          # { @ src/fusion/Expr.mbi(4558:13-4561:13)
          idx = ((subi_[i] * m._dimj) + subj_[i])

          bfix[idx] = (bfix[idx] + val_[i])
          # } @ src/fusion/Expr.mbi(4558:13-4561:13)
      return mosek.fusion.Expr(lfe.ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
    else:
      _autovar_431 = rhs
      if   isinstance(_autovar_431,mosek.fusion.DenseMatrix):
        m = _autovar_431
        rnnz = ( m._numNonzeros_() )

        ptrb = ([ 0l for _autovar_432 in xrange((rnnz + 1)) ])

        bfix = ( Utils.Tools._arraycopy__3F (m._data) )

        if   (lfe.bfix == None):
          # src/fusion/Expr.mbi(4576:15-4577:68)
          for i in xrange(0,int(len(lfe.bfix))):
            bfix[lfe.inst[i]] = (bfix[lfe.inst[i]] + lfe.bfix[i])
        # src/fusion/Expr.mbi(4579:13-81)
        for i in xrange(0,int(len(lfe.inst))):
          ptrb[(lfe.inst[i] + 1)] = lfe.ptrb[(i + 1)]
        # src/fusion/Expr.mbi(4580:13-4583:21)
        for i in xrange(1,int(len(ptrb))):
          if   (ptrb[i] == 0):
            ptrb[i] = ptrb[(i - 1)]
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
      else:
        m = _autovar_431
        subi_ = ([ 0 for _autovar_433 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_434 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_435 in xrange(( m._numNonzeros_() )) ])

        lidx = ([ 0l for _autovar_436 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(4592:13-92)
        for i in xrange(0l,( m._numNonzeros_() )):
          lidx[i] = long(((subi_[i] * m._dimj) + subj_[i]))
        rnnz = 0

        # { @ src/fusion/Expr.mbi(4596:13-4605:13)
        i = 0

        j = 0

        # src/fusion/Expr.mbi(4598:15-4602:44)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            i += 1
            rnnz += 1
          elif (lfe.inst[i] > lidx[j]):
            j += 1
            rnnz += 1
          else:
            i += 1
            j += 1
            rnnz += 1
        if   (i < int(len(lfe.inst))):
          rnnz = ((rnnz + int(len(lfe.inst))) - i)
        if   (j < int(len(lidx))):
          rnnz = ((rnnz + int(len(lidx))) - j)
        # } @ src/fusion/Expr.mbi(4596:13-4605:13)
        ptrb = ([ 0l for _autovar_437 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_438 in xrange(rnnz) ])

        inst = ([ 0l for _autovar_439 in xrange(rnnz) ])

        # { @ src/fusion/Expr.mbi(4611:13-4652:13)
        i = 0

        j = 0

        k = 0

        # src/fusion/Expr.mbi(4613:15-4637:15)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            if   (lfe.bfix != None):
              bfix[k] = lfe.bfix[i]
            inst[k] = lfe.inst[i]
            i += 1
          elif (lfe.inst[i] > lidx[j]):
            bfix[k] = val_[j]
            inst[k] = lidx[j]
            j += 1
          else:
            if   (lfe.bfix != None):
              bfix[k] = (lfe.bfix[i] + val_[j])
            else:
              bfix[k] = val_[j]
            inst[k] = lidx[j]
            i += 1
            j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(4638:15-4644:15)
        while (i < int(len(lfe.inst))):
          if   (lfe.bfix != None):
            bfix[k] = lfe.bfix[i]
          inst[k] = lfe.inst[i]
          i += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(4645:15-4651:15)
        while (j < int(len(lidx))):
          bfix[k] = val_[j]
          inst[k] = lidx[j]
          j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # } @ src/fusion/Expr.mbi(4611:13-4652:13)
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4665:15-4670:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4679:15-4684:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( ( Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2 (rhs,lhs) )._neg_() )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4692:15-4731:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   (((lhs.shape.nd != 2) or (( lhs.shape._dim_I(0) ) != rhs._dimi)) or (( lhs.shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    size = (rhs._dimi * rhs._dimj)

    bfix = ([ 0.0 for _autovar_440 in xrange(size) ])

    _autovar_441 = rhs
    if   isinstance(_autovar_441,mosek.fusion.DenseMatrix):
      m = _autovar_441
      # src/fusion/Expr.mbi(4707:11-4708:34)
      for i in xrange(0,int(len(bfix))):
        bfix[i] = (- m._data[i])
    else:
      m = _autovar_441
      subi_ = ([ 0 for _autovar_442 in xrange(( m._numNonzeros_() )) ])

      subj_ = ([ 0 for _autovar_443 in xrange(( m._numNonzeros_() )) ])

      val_ = ([ 0.0 for _autovar_444 in xrange(( m._numNonzeros_() )) ])

      ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
      # src/fusion/Expr.mbi(4717:11-4721:11)
      for i in xrange(0l,( m._numNonzeros_() )):
        # { @ src/fusion/Expr.mbi(4718:11-4721:11)
        idx = ((subi_[i] * m._dimj) + subj_[i])

        bfix[idx] = (- val_[i])
        # } @ src/fusion/Expr.mbi(4718:11-4721:11)
    cof = ( Utils.Tools._ones_I (size) )

    subj = ( Utils.Tools._range_LL (0l,long(size)) )

    ptrb = ( Utils.Tools._range_LL (0l,long((size + 1))) )

    return mosek.fusion.Expr(ptrb,lhs,subj,cof,bfix,lhs.shape,None,1)
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4739:15-4744:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs,rhs):
    return ( ( Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2 (rhs,lhs) )._neg_() )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4753:15-4758:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,rhs,False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4765:15-4770:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( rhs._asExpr_() ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4777:15-4782:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),rhs,False) )
  @staticmethod
  def _matchargs_sub__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4791:15-4796:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([double],mosek.fusion.Variable)")
  def _sub__3FOmosek_fusion_Variable_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),( rhs._asExpr_() ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(4804:15-4809:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,[double])")
  def _sub_Omosek_fusion_Variable_2_3F(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4817:15-4822:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([double],mosek.fusion.Expression)")
  def _sub__3FOmosek_fusion_Expression_2(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),rhs,False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(4830:15-4835:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,[double])")
  def _sub_Omosek_fusion_Expression_2_3F(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(4844:15-4861:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,float)")
  def _sub_Omosek_fusion_Expression_2F(lhs,rhs):
    fe = ( lhs._eval_() )

    bfix = None

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI ((- rhs),(int(len(fe.ptrb)) - 1)) )
    else:
      bfix = ( Utils.Tools._arraycopy__3F (fe.bfix) )
      # src/fusion/Expr.mbi(4857:11-70)
      i = 0

      while (i < int(len(bfix))):
        bfix[i] = (bfix[i] - rhs)
        i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_sub_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4869:15-4890:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(float,mosek.fusion.Expression)")
  def _sub_FOmosek_fusion_Expression_2(lhs,rhs):
    fe = ( rhs._eval_() )

    bfix = None

    n = (int(len(fe.ptrb)) - 1)

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI (lhs,n) )
    else:
      bfix = ([ 0.0 for _autovar_445 in xrange(n) ])
      # src/fusion/Expr.mbi(4883:11-65)
      i = 0

      while (i < n):
        bfix[i] = (lhs - fe.bfix[i])
        i += 1
    cof = ([ 0.0 for _autovar_446 in xrange(int(len(fe.cof))) ])

    # src/fusion/Expr.mbi(4887:9-63)
    i = 0

    while (i < int(len(cof))):
      cof[i] = (- fe.cof[i])
      i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(4898:15-4902:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,float)")
  def _sub_Omosek_fusion_Variable_2F(lhs,rhs):
    return ( Expr._sub_Omosek_fusion_Expression_2F (( lhs._asExpr_() ),rhs) )
  @staticmethod
  def _matchargs_sub_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4911:15-4921:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(float,mosek.fusion.Variable)")
  def _sub_FOmosek_fusion_Variable_2(lhs,rhs):
    n = rhs.shape._size

    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(n + 1)) ),rhs,( Utils.Tools._range_LL (0l,n) ),( Utils.Tools._makevector_FI ((- 1.0),int(n)) ),( Utils.Tools._makevector_FI (lhs,int(n)) ),rhs.shape,None,1)
  @staticmethod
  def _matchargs_sub__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(4929:15-4934:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([double],[double])")
  def _sub__3F_3F(lhs,rhs):
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4944:15-4952:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(lhs,rhs):
    if   ( lhs.shape._compare_Omosek_fusion_Set_2(rhs.shape) ):
      return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( rhs._asExpr_() ),False) )
    else:
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
  @staticmethod
  def _matchargs_neg_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(4956:15-4966:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("neg()")
  def _neg_(self):
    fe = ( self._eval_() )

    newcof = ([ 0.0 for _autovar_447 in xrange(int(len(fe.cof))) ])

    newbfix = None

    if   (fe.bfix != None):
      newbfix = ([ 0.0 for _autovar_448 in xrange(int(len(fe.bfix))) ])
    # src/fusion/Expr.mbi(4961:9-62)
    for i in xrange(0,int(len(newcof))):
      newcof[i] = (- fe.cof[i])
    if   (self.__bfix != None):
      # src/fusion/Expr.mbi(4963:11-64)
      for i in xrange(0,int(len(self.__bfix))):
        newbfix[i] = (- fe.bfix[i])
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,newcof,newbfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_sum_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4977:15-5003:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sum(mosek.fusion.Expression)")
  def _sum_Omosek_fusion_Expression_2(rhs_):
    rhs = ( rhs_._eval_() )

    ptrb = ([ 0l,long(len(rhs.cof))])

    subj = ( Utils.Tools._arraycopy__3L (rhs.subj) )

    cof = ( Utils.Tools._arraycopy__3F (rhs.cof) )


    if   (rhs.bfix != None):
      bfix = 0.0

      # src/fusion/Expr.mbi(4990:11-4993:11)
      i = 0

      while (i < int(len(rhs.bfix))):
        bfix = (bfix + rhs.bfix[i])
        i += 1
      bfixarr = ([ 0.0 for _autovar_449 in xrange(1) ])
      bfixarr[0] = bfix
    else:
      bfixarr = None
    return mosek.fusion.Expr(ptrb,rhs.x,subj,cof,bfixarr,None,None,1)
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(5007:15-5010:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return long(len(self.__cof_v))
  @staticmethod
  def _matchargs_sum_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(5021:15-5025:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sum(mosek.fusion.Variable)")
  def _sum_Omosek_fusion_Variable_2(rhs):
    return ( Expr._sum_Omosek_fusion_Expression_2 (( rhs._asExpr_() )) )
  @staticmethod
  def _matchargs_ones_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Expr.mbi(5032:15-5042:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("ones(int)")
  def _ones_I(num):
    ptrb = ( Utils.Tools._makevector_LI (0l,(1 + num)) )

    v = None

    subj = ([ 0l for _autovar_450 in xrange(0) ])

    cof = ([ 0.0 for _autovar_451 in xrange(0) ])

    bfix = ( Utils.Tools._ones_I (num) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_constTerm__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(5049:15-5059:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("constTerm([double])")
  def _constTerm__3F(vals):
    ptrb = ( Utils.Tools._makevector_LI (0l,(int(len(vals)) + 1)) )

    v = None

    subj = ([ 0l for _autovar_452 in xrange(0) ])

    cof = ([ 0.0 for _autovar_453 in xrange(0) ])

    bfix = ( Utils.Tools._arraycopy__3F (vals) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_constTerm_IF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(5067:15-5077:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constTerm(int,float)")
  def _constTerm_IF(size,val):
    ptrb = ( Utils.Tools._makevector_LI (0l,(size + 1)) )

    v = None

    subj = ([ 0l for _autovar_454 in xrange(0) ])

    cof = ([ 0.0 for _autovar_455 in xrange(0) ])

    bfix = ( Utils.Tools._makevector_FI (val,size) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_zeros_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Expr.mbi(5085:15-5095:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("zeros(int)")
  def _zeros_I(num):
    ptrb = ( Utils.Tools._makevector_LI (0l,(1 + num)) )

    v = None

    subj = ([ 0l for _autovar_456 in xrange(0) ])

    cof = ([ 0.0 for _autovar_457 in xrange(0) ])

    bfix = ( Utils.Tools._zeros_I (num) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_eval_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(5099:15-5101:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("eval()")
  def _eval_(self):
    return mosek.fusion.FlatExpr(self.__bfix,self.__ptrb,self.__subj,self.__x,self.__cof_v,self._shape,self.__inst)
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(5105:15-5107:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return (long(len(self.__ptrb)) - 1)
  @staticmethod
  def _matchargs_inplaceMul_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/Expr.mbi(5115:15-5121:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceMul(float)")
  def _inplaceMul_F(self,c):
    # src/fusion/Expr.mbi(5116:9-5119:9)
    i = 0l

    while (i < long(len(self.__cof_v))):
      self.__cof_v[i] = (self.__cof_v[i] * c)
      i += 1
    return self
  @staticmethod
  def _matchargs_inplaceElmMul__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(5125:15-5136:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceElmMul([double])")
  def _inplaceElmMul__3F(self,c):
    if   (int(len(self.__cof_v)) != int(len(c))):
      raise mosek.fusion.LengthError("Length of multiplication operands do not match")
    # src/fusion/Expr.mbi(5131:9-5134:9)
    i = 0l

    while (i < long(len(self.__cof_v))):
      self.__cof_v[i] = (self.__cof_v[i] * c[i])
      i += 1
    return self
  @staticmethod
  def _matchargs_inplaceNeg_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(5139:15-5145:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inplaceNeg()")
  def _inplaceNeg_(self):
    # src/fusion/Expr.mbi(5140:9-5143:9)
    i = 0l

    while (i < long(len(self.__cof_v))):
      self.__cof_v[i] = (0.0 - self.__cof_v[i])
      i += 1
    return self
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Expr.mbi(5151:15-5174:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,mosek.fusion.Set)")
  def _reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(e,shape_):
    if   (shape_._size != e._shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    strides = ([ 0l for _autovar_458 in xrange(shape_.nd) ])

    strides[(shape_.nd - 1)] = 1l
    _autovar_459 = e
    if   isinstance(_autovar_459,mosek.fusion.Expr):
      e_ = _autovar_459
      return mosek.fusion.Expr(e_.__ptrb,e_.__x,e_.__subj,e_.__cof_v,e_.__bfix,shape_,e_.__inst,1)
    else:
      e_ = _autovar_459
      ef = ( e._eval_() )

      return mosek.fusion.Expr(ef.ptrb,ef.x,ef.subj,ef.cof,ef.bfix,shape_,ef.inst,1)
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Expr.mbi(5177:15-5179:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,int)")
  def _reshape_Omosek_fusion_Expression_2I(e,size):
    return ( Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2 (e,mosek.fusion.IntSet(size)) )
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2II(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Expr.mbi(5181:15-5183:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,int,int)")
  def _reshape_Omosek_fusion_Expression_2II(e,dimi,dimj):
    return ( Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2 (e,mosek.fusion.NDSet(dimi,dimj)) )
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack__3Omosek_fusion_Expression_2(args):
      return Expr._hstack__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)"),(1,"\thstack([mosek.fusion.Expression])"),(2,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def mulDiag(*args):
    if   Expr._matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "mulDiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tmulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Expr._matchargs_vstack__3Omosek_fusion_Expression_2(args):
      return Expr._vstack__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tvstack([mosek.fusion.Expression])"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)"),(2,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def ones(*args):
    if   Expr._matchargs_ones_I(args):
      return Expr._ones_I(*args)
    else:
      argtypestr = "ones(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tones(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def eval(self,*args):
    if   Expr._matchargs_eval_(args):
      return Expr._eval_(self,*args)
    else:
      argtypestr = "eval(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\teval()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def mul(*args):
    if   Expr._matchargs_mul_Omosek_fusion_Expression_2F(args):
      return Expr._mul_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_mul_FOmosek_fusion_Variable_2(args):
      return Expr._mul_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2_3F(args):
      return Expr._mul_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_mul__3FOmosek_fusion_Variable_2(args):
      return Expr._mul__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2F(args):
      return Expr._mul_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_mul__3FOmosek_fusion_Expression_2(args):
      return Expr._mul__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_FOmosek_fusion_Expression_2(args):
      return Expr._mul_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Expression_2_3F(args):
      return Expr._mul_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "mul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmul(mosek.fusion.Expression,float)"),(2,"\tmul(float,mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Variable,[double])"),(2,"\tmul([double],mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Variable,float)"),(2,"\tmul([double],mosek.fusion.Expression)"),(2,"\tmul(float,mosek.fusion.Expression)"),(2,"\tmul(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmul(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Expression,[double])"),(2,"\tmul(mosek.fusion.Variable,mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Expr._matchargs_numNonzeros_(args):
      return Expr._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   Expr._matchargs_size_(args):
      return Expr._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inplaceMul(self,*args):
    if   Expr._matchargs_inplaceMul_F(args):
      return Expr._inplaceMul_F(self,*args)
    else:
      argtypestr = "inplaceMul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinplaceMul(float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def sub(*args):
    if   Expr._matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_sub_FOmosek_fusion_Expression_2(args):
      return Expr._sub_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_FOmosek_fusion_Variable_2(args):
      return Expr._sub_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2_3F(args):
      return Expr._sub_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2F(args):
      return Expr._sub_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2_3F(args):
      return Expr._sub_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_sub__3FOmosek_fusion_Expression_2(args):
      return Expr._sub__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub__3FOmosek_fusion_Variable_2(args):
      return Expr._sub__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub__3F_3F(args):
      return Expr._sub__3F_3F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2F(args):
      return Expr._sub_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "sub(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tsub(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tsub(float,mosek.fusion.Expression)"),(2,"\tsub(float,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Expression)"),(2,"\tsub(mosek.fusion.Expression,[double])"),(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tsub(mosek.fusion.Variable,float)"),(2,"\tsub(mosek.fusion.Variable,[double])"),(2,"\tsub([double],mosek.fusion.Expression)"),(2,"\tsub([double],mosek.fusion.Variable)"),(2,"\tsub([double],[double])"),(2,"\tsub(mosek.fusion.Expression,float)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Expr._matchargs_reshape_Omosek_fusion_Expression_2II(args):
      return Expr._reshape_Omosek_fusion_Expression_2II(*args)
    elif Expr._matchargs_reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(args):
      return Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(*args)
    elif Expr._matchargs_reshape_Omosek_fusion_Expression_2I(args):
      return Expr._reshape_Omosek_fusion_Expression_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\treshape(mosek.fusion.Expression,int,int)"),(2,"\treshape(mosek.fusion.Expression,mosek.fusion.Set)"),(2,"\treshape(mosek.fusion.Expression,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def sum(*args):
    if   Expr._matchargs_sum_Omosek_fusion_Variable_2(args):
      return Expr._sum_Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sum_Omosek_fusion_Expression_2(args):
      return Expr._sum_Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "sum(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsum(mosek.fusion.Variable)"),(1,"\tsum(mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getModel(self,*args):
    if   Expression._matchargs_getModel_(args):
      return Expression._getModel_(self,*args)
    else:
      argtypestr = "getModel(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetModel()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def mulElm(*args):
    if   Expr._matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "mulElm(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmulElm(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmulElm(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmulElm(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tmulElm(mosek.fusion.Variable,mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inplaceNeg(self,*args):
    if   Expr._matchargs_inplaceNeg_(args):
      return Expr._inplaceNeg_(self,*args)
    else:
      argtypestr = "inplaceNeg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinplaceNeg()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Expr._matchargs_stack__3_3Omosek_fusion_Expression_2(args):
      return Expr._stack__3_3Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Expression]])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def add(*args):
    if   Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2F(args):
      return Expr._add_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add__3FOmosek_fusion_Variable_2(args):
      return Expr._add__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add__3F_3F(args):
      return Expr._add__3F_3F(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add__3Omosek_fusion_Variable_2(args):
      return Expr._add__3Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2F(args):
      return Expr._add_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_add__3FOmosek_fusion_Expression_2(args):
      return Expr._add__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2_3F(args):
      return Expr._add_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_add__3Omosek_fusion_Expression_2(args):
      return Expr._add__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2_3F(args):
      return Expr._add_Omosek_fusion_Variable_2_3F(*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Variable,mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Variable,float)"),(2,"\tadd(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tadd([double],mosek.fusion.Variable)"),(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\tadd([double],[double])"),(2,"\tadd(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tadd([mosek.fusion.Variable])"),(2,"\tadd(mosek.fusion.Expression,float)"),(2,"\tadd([double],mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Expression,[double])"),(1,"\tadd([mosek.fusion.Expression])"),(2,"\tadd(mosek.fusion.Variable,[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getShape(self,*args):
    if   Expression._matchargs_getShape_(args):
      return Expression._getShape_(self,*args)
    else:
      argtypestr = "getShape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetShape()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Expression._matchargs_toString_(args):
      return Expression._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inplaceElmMul(self,*args):
    if   Expr._matchargs_inplaceElmMul__3F(args):
      return Expr._inplaceElmMul__3F(self,*args)
    else:
      argtypestr = "inplaceElmMul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinplaceElmMul([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def neg(self,*args):
    if   Expr._matchargs_neg_(args):
      return Expr._neg_(self,*args)
    else:
      argtypestr = "neg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tneg()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def zeros(*args):
    if   Expr._matchargs_zeros_I(args):
      return Expr._zeros_I(*args)
    else:
      argtypestr = "zeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tzeros(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def constTerm(*args):
    if   Expr._matchargs_constTerm_IF(args):
      return Expr._constTerm_IF(*args)
    elif Expr._matchargs_constTerm__3F(args):
      return Expr._constTerm__3F(*args)
    else:
      argtypestr = "constTerm(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tconstTerm(int,float)"),(1,"\tconstTerm([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def dot(*args):
    if   Expr._matchargs_dot__3FOmosek_fusion_Variable_2(args):
      return Expr._dot__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Expression_2_3F(args):
      return Expr._dot_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Variable_2_3F(args):
      return Expr._dot_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_dot__3FOmosek_fusion_Expression_2(args):
      return Expr._dot__3FOmosek_fusion_Expression_2(*args)
    else:
      argtypestr = "dot(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdot([double],mosek.fusion.Variable)"),(2,"\tdot(mosek.fusion.Expression,[double])"),(2,"\tdot(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tdot(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tdot(mosek.fusion.Variable,[double])"),(2,"\tdot([double],mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Matrix.mbi(13:12-481:5)
class Matrix:
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int)")
  def __constructor_II(self,di,dj):
    self._dimi = di
    self._dimj = dj
  def __init__(self,*args):
    #self._protected_dimi = None

    #self._protected_dimj = None

    self.__constructor_II(*args)
  @staticmethod
  def _matchargs_numRows_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(29:15-28:51)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numRows()")
  def _numRows_(self):
    return self._dimi
  @staticmethod
  def _matchargs_numColumns_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(34:15-33:54)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numColumns()")
  def _numColumns_(self):
    return self._dimj
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(39:15-38:52)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    pass
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(41:15-40:51)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    pass
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(56:15-60:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int32],[int32],[double])")
  def _getDataAsTriplets__3I_3I_3F(self,subi,subj,val):
    pass
  @staticmethod
  def _matchargs_sparse_II_3I_3I_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(72:15-92:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int,[int32],[int32],[double])")
  def _sparse_II_3I_3I_3F(nrow,ncol,subi,subj,val):



    if   (subi == None):
      si = ([ 0 for _autovar_460 in xrange(0) ])
    else:
      si = subi
    if   (subj == None):
      sj = ([ 0 for _autovar_461 in xrange(0) ])
    else:
      sj = subj
    if   (val == None):
      vl = ([ 0.0 for _autovar_462 in xrange(0) ])
    else:
      vl = val
    nnz = long(len(si))

    if   ((long(len(sj)) != nnz) or (long(len(vl)) != nnz)):
      raise mosek.fusion.SparseFormatError("Arrays defining sparse data have different lengths")
    return mosek.fusion.SparseMatrix(nrow,ncol,si,sj,vl,nnz)
  @staticmethod
  def _matchargs_sparse_II_3I_3IF(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],float): return False
    return True
  # origin: src/fusion/Matrix.mbi(103:15-113:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int,[int32],[int32],float)")
  def _sparse_II_3I_3IF(nrow,ncol,subi,subj,val):
    sz = 0

    if   (subi != None):
      sz = int(len(subi))
    elif (subj != None):
      sz = int(len(subj))
    return ( Matrix._sparse_II_3I_3I_3F (nrow,ncol,subi,subj,( Utils.Tools._makevector_FI (val,sz) )) )
  @staticmethod
  def _matchargs_sparse_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(122:15-124:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int)")
  def _sparse_II(nrow,ncol):
    return mosek.fusion.SparseMatrix(nrow,ncol,None,None,None,0l)
  @staticmethod
  def _matchargs_sparse__3_3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(131:15-154:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([[double]])")
  def _sparse__3_3F(data):
    dimi = ( Utils.Tools._matrixheight__3_3F (data) )

    dimj = ( Utils.Tools._matrixwidth__3_3F (data) )

    nelem = long((dimi * dimj))

    subi = ([ 0 for _autovar_463 in xrange(nelem) ])

    subj = ([ 0 for _autovar_464 in xrange(nelem) ])

    val = ([ 0.0 for _autovar_465 in xrange(nelem) ])

    k = 0

    # src/fusion/Matrix.mbi(141:9-152:9)
    i = 0

    while (i < dimi):
      ( Utils.Tools._arraycopy__3FI_3FII (data[i],0,val,k,dimj) )
      # src/fusion/Matrix.mbi(145:11-149:11)
      j = 0

      while (j < dimj):
        subi[(k + j)] = i
        subj[(k + j)] = j
        j += 1
      k = (k + dimj)
      i += 1
    return mosek.fusion.SparseMatrix(dimi,dimj,subi,subj,val)
  @staticmethod
  def _matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(174:15-314:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([[mosek.fusion.Matrix]])")
  def _sparse__3_3Omosek_fusion_Matrix_2(blocks):
    maxi = ( Utils.Tools._matrixheight__3_3Omosek_fusion_Matrix_2 (blocks) )

    maxj = ( Utils.Tools._matrixwidth__3_3Omosek_fusion_Matrix_2 (blocks) )

    idims = ([ 0 for _autovar_466 in xrange(maxi) ])

    jdims = ([ 0 for _autovar_467 in xrange(maxj) ])

    nelm = 0l

    k = 0

    # src/fusion/Matrix.mbi(184:9-213:9)
    i = 0

    while (i < maxi):
      # src/fusion/Matrix.mbi(186:11-212:11)
      j = 0

      while (j < maxj):
        m = blocks[i][j]

        if   (m != None):
          if   (jdims[j] == 0):
            jdims[j] = m._dimj
          elif (jdims[j] != m._dimj):
            raise mosek.fusion.SparseFormatError("Sparse matrix construction blocks are not aligned")
          if   (idims[i] == 0):
            idims[i] = m._dimi
          elif (idims[i] != m._dimi):
            raise mosek.fusion.SparseFormatError("Sparse matrix construction blocks are not aligned")
          nelm = (nelm + ( m._numNonzeros_() ))
        k += 1
        j += 1
      i += 1

    cof = ([ 0.0 for _autovar_468 in xrange(nelm) ])
    subi = ([ 0 for _autovar_469 in xrange(nelm) ])

    subj = ([ 0 for _autovar_470 in xrange(nelm) ])

    dstp = 0

    offseti = 0

    # src/fusion/Matrix.mbi(247:9-301:9)
    i = 0

    while (i < maxi):
      lidxs = ([ 0 for _autovar_471 in xrange(maxj) ])

      # src/fusion/Matrix.mbi(251:11-299:11)
      ii = 0

      while (ii < idims[i]):
        offsetj = 0

        # src/fusion/Matrix.mbi(255:13-297:13)
        j = 0

        while (j < maxj):
          m_ = blocks[i][j]

          if   (m_ != None):
            _autovar_472 = m_
            if   isinstance(_autovar_472,mosek.fusion.DenseMatrix):
              m = _autovar_472
              kk = lidxs[j]

              # src/fusion/Matrix.mbi(264:19-272:19)
              jj = 0

              while (jj < m._dimj):
                cof[dstp] = m._data[kk]
                subi[dstp] = (offseti + ii)
                subj[dstp] = (offsetj + jj)
                kk += 1
                dstp += 1
                jj += 1
              lidxs[j] = kk
            elif isinstance(_autovar_472,mosek.fusion.SparseMatrix):
              m = _autovar_472

              # src/fusion/Matrix.mbi(279:19-288:19)
              kk = lidxs[j]
              while ((kk < m._nnz) and (m._subi[kk] == ii)):
                cof[dstp] = m._val[kk]
                subj[dstp] = (m._subj[kk] + offsetj)
                subi[dstp] = (offseti + ii)
                dstp += 1
                kk += 1
              lidxs[j] = kk
            else:
              m = _autovar_472
              raise mosek.fusion.MatrixError("Unknown matrix type.")
          offsetj = (offsetj + jdims[j])
          j += 1
        ii += 1
      offseti = (offseti + idims[i])
      i += 1
    dimi = 0

    dimj = 0

    # src/fusion/Matrix.mbi(304:9-307:9)
    i = 0

    while (i < maxi):
      dimi = (dimi + idims[i])
      i += 1
    # src/fusion/Matrix.mbi(308:9-311:9)
    j = 0

    while (j < maxj):
      dimj = (dimj + jdims[j])
      j += 1
    return mosek.fusion.SparseMatrix(dimi,dimj,subi,subj,cof)
  @staticmethod
  def _matchargs_sparse_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(324:15-364:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(mosek.fusion.Matrix)")
  def _sparse_Omosek_fusion_Matrix_2(v_):
    _autovar_473 = v_
    if   isinstance(_autovar_473,mosek.fusion.DenseMatrix):
      v = _autovar_473
      p = 0

      nelem = (v._dimi * v._dimj)

      subi = ([ 0 for _autovar_474 in xrange(nelem) ])

      subj = ([ 0 for _autovar_475 in xrange(nelem) ])

      # src/fusion/Matrix.mbi(333:11-341:11)
      i = 0

      while (i < v._dimi):
        # src/fusion/Matrix.mbi(335:13-340:13)
        j = 0

        while (j < v._dimj):
          subi[p] = i
          subj[p] = j
          p += 1
          j += 1
        i += 1
      val = ( Utils.Tools._arraycopy__3F (v._data) )

      return mosek.fusion.SparseMatrix(v._dimi,v._dimj,subi,subj,val)
    elif isinstance(_autovar_473,mosek.fusion.SparseMatrix):
      v = _autovar_473
      if   (v._nnz > 0):
        subi = ( Utils.Tools._arraycopy__3I (v._subi) )

        subj = ( Utils.Tools._arraycopy__3I (v._subj) )

        val = ( Utils.Tools._arraycopy__3F (v._val) )

        return mosek.fusion.SparseMatrix(v._dimi,v._dimj,subi,subj,val)
      else:
        return mosek.fusion.SparseMatrix(v._dimi,v._dimj,None,None,None)
    else:
      m = _autovar_473
      raise mosek.fusion.MatrixError("Unknown matrix type.")
  @staticmethod
  def _matchargs_diag__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(374:15-380:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag([double])")
  def _diag__3F(d):
    subi = ( Utils.Tools._range_II (0,int(len(d))) )

    subj = ( Utils.Tools._range_II (0,int(len(d))) )

    val = ( Utils.Tools._arraycopy__3F (d) )

    return mosek.fusion.SparseMatrix(int(len(d)),int(len(d)),subi,subj,d)
  @staticmethod
  def _matchargs_diag__3Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(395:15-468:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag([mosek.fusion.Matrix])")
  def _diag__3Omosek_fusion_Matrix_2(d):
    numelm = 0l

    dim = 0

    # { @ src/fusion/Matrix.mbi(401:9-413:9)
    # src/fusion/Matrix.mbi(402:11-412:11)
    i = 0

    while (i < int(len(d))):

      m = d[i]
      if   (m._dimi != m._dimj):
        raise mosek.fusion.SparseFormatError("Diagonal blocks must be square")
      dim = (dim + m._dimi)
      numelm = (numelm + ( m._numNonzeros_() ))
      i += 1
    # } @ src/fusion/Matrix.mbi(401:9-413:9)
    subi = ([ 0 for _autovar_476 in xrange(numelm) ])

    subj = ([ 0 for _autovar_477 in xrange(numelm) ])

    val = ([ 0.0 for _autovar_478 in xrange(numelm) ])

    # { @ src/fusion/Matrix.mbi(419:9-465:9)

    offset = 0
    k = 0l

    # src/fusion/Matrix.mbi(423:11-464:11)
    i = 0

    while (i < int(len(d))):

      m_ = d[i]
      _autovar_479 = m_
      if   isinstance(_autovar_479,mosek.fusion.DenseMatrix):
        m = _autovar_479
        ( Utils.Tools._arraycopy__3FL_3FLL (m._data,0l,val,k,( m_._numNonzeros_() )) )
        # src/fusion/Matrix.mbi(432:15-441:15)
        ii = 0

        while (ii < m._dimi):
          # src/fusion/Matrix.mbi(434:17-440:17)
          jj = 0

          while (jj < m._dimj):
            subi[k] = (ii + offset)
            subj[k] = (jj + offset)
            k += 1
            jj += 1
          ii += 1
      elif isinstance(_autovar_479,mosek.fusion.SparseMatrix):
        m = _autovar_479
        if   (m._nnz > 0):
          ( Utils.Tools._arraycopy__3FL_3FLL (m._val,0l,val,k,m._nnz) )
          # src/fusion/Matrix.mbi(449:17-455:17)
          jj = 0

          while (jj < m._nnz):
            subi[k] = (m._subi[jj] + offset)
            subj[k] = (m._subj[jj] + offset)
            k += 1
            jj += 1
      else:
        m = _autovar_479
        raise mosek.fusion.MatrixError("Unknown matrix type.")
      offset = (offset + m_._dimi)
      i += 1
    # } @ src/fusion/Matrix.mbi(419:9-465:9)
    return mosek.fusion.SparseMatrix(dim,dim,subi,subj,val)
  @staticmethod
  def _matchargs_switchDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(472:18-475:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("switchDims()")
  def _switchDims_(self):
    tmp = self._dimi

    self._dimi = self._dimj
    self._dimj = tmp
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(481:15-480:50)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    pass
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Matrix._matchargs_toString_(args):
      return Matrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse([[double]])"),(1,"\tsparse([[mosek.fusion.Matrix]])"),(1,"\tsparse(mosek.fusion.Matrix)"),(5,"\tsparse(int,int,[int32],[int32],[double])"),(2,"\tsparse(int,int)"),(5,"\tsparse(int,int,[int32],[int32],float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdiag([mosek.fusion.Matrix])"),(1,"\tdiag([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   Matrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return Matrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int32],[int32],[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   Matrix._matchargs_transpose_(args):
      return Matrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Matrix._matchargs_numNonzeros_(args):
      return Matrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Matrix.mbi(485:12-642:5)
class SparseMatrix(Matrix):
  @staticmethod
  def _matchargs_constructor_II_3I_3I_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[int32],[int32],[double])")
  def __constructor_II_3I_3I_3F(self,dimi_,dimj_,subi_,subj_,val_):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if   (subi_ == None):
      self._nnz = 0l
    else:
      self._nnz = long(len(self._subi))
  @staticmethod
  def _matchargs_constructor_II_3I_3I_3FL(args):
    if len(args) != 6:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[int32],[int32],[double],long)")
  def __constructor_II_3I_3I_3FL(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    if   (nelm > 0):
      if   (((int(len(subi_)) < nelm) or (int(len(subj_)) < nelm)) or (int(len(val_)) < nelm)):
        raise mosek.fusion.SparseFormatError("Mismatching arrays in sparse data.")
      # src/fusion/Matrix.mbi(557:11-563:16)
      for i in xrange(0l,nelm):
        if   ((((subi_[i] < 0) or (subi_[i] >= self._dimi)) or (subj_[i] < 0)) or (subj_[i] >= self._dimj)):
          raise mosek.fusion.SparseFormatError("Subscript out of bounds.")
      ressubi = ([ 0 for _autovar_480 in xrange(1) ])

      ressubj = ([ 0 for _autovar_481 in xrange(1) ])

      resval = ([ 0.0 for _autovar_482 in xrange(1) ])

      ( CommonTools._tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII (subi_,subj_,val_,ressubi,ressubj,resval,nelm,self._dimi,self._dimj) )
      self._subi = ressubi[0]
      self._subj = ressubj[0]
      self._val = resval[0]
      self._nnz = long(len(self._val))
    else:
      self._subi = None
      self._subj = None
      self._val = None
      self._nnz = 0l
  def __init__(self,*args):
    #self._protected_subi = None

    #self._protected_subj = None

    #self._protected_val = None

    #self._protected_nnz = None

    if   self._matchargs_constructor_II_3I_3I_3F(args):
      self.__constructor_II_3I_3I_3F(*args)
    elif self._matchargs_constructor_II_3I_3I_3FL(args):
      self.__constructor_II_3I_3I_3FL(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(583:15-597:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int32],[int32],[double])")
  def _getDataAsTriplets__3I_3I_3F(self,subi_,subj_,cof_):
    if   (((long(len(subi_)) < self._nnz) or (long(len(subj_)) < self._nnz)) or (long(len(cof_)) < self._nnz)):
      raise mosek.fusion.LengthError("Output arrays are not long enough.")
    ( Utils.Tools._arraycopy__3IL_3ILL (self._subi,0l,subi_,0l,self._nnz) )
    ( Utils.Tools._arraycopy__3IL_3ILL (self._subj,0l,subj_,0l,self._nnz) )
    ( Utils.Tools._arraycopy__3FL_3FLL (self._val,0l,cof_,0l,self._nnz) )
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(600:15-603:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    return ( Matrix._sparse_II_3I_3I_3F (self._dimj,self._dimi,self._subj,self._subi,self._val) )
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(607:15-609:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return self._nnz
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(612:15-623:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( ( ( sb._a_S("SparseMatrix(") )._a_I(self._dimi) )._a_S(",") )._a_I(self._dimj) )._a_S(", ") )
    if   (int(len(self._subi)) > 0):
      ( ( ( ( ( ( ( sb._a_S("[") )._a_I(self._subi[0]) )._a_S(",") )._a_I(self._subj[0]) )._a_S(",") )._a_F(self._val[0]) )._a_S(")") )
      # src/fusion/Matrix.mbi(618:11-619:76)
      for i in xrange(1,int(len(self._subi))):
        ( ( ( ( ( ( ( sb._a_S(",[") )._a_I(self._subi[i]) )._a_S(",") )._a_I(self._subj[i]) )._a_S(",") )._a_F(self._val[i]) )._a_S("]") )
    ( sb._a_S(" ]") )
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_formPtrb_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(627:18-641:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("formPtrb()")
  def _formPtrb_(self):
    ptrb = ([ 0l for _autovar_483 in xrange((self._dimi + 1)) ])

    pos = 0l

    # src/fusion/Matrix.mbi(631:9-637:9)
    row = 0

    while (row < self._dimi):
      ptrb[row] = pos
      # src/fusion/Matrix.mbi(634:11-636:11)
      while ((pos < self._nnz) and (self._subi[pos] == row)):
        pass
        pos += 1
      row += 1
    ptrb[self._dimi] = pos
    return ptrb
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   SparseMatrix._matchargs_toString_(args):
      return SparseMatrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse([[double]])"),(1,"\tsparse([[mosek.fusion.Matrix]])"),(2,"\tsparse(int,int)"),(1,"\tsparse(mosek.fusion.Matrix)"),(5,"\tsparse(int,int,[int32],[int32],[double])"),(5,"\tsparse(int,int,[int32],[int32],float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdiag([mosek.fusion.Matrix])"),(1,"\tdiag([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   SparseMatrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return SparseMatrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int32],[int32],[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   SparseMatrix._matchargs_transpose_(args):
      return SparseMatrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numNonzeros(self,*args):
    if   SparseMatrix._matchargs_numNonzeros_(args):
      return SparseMatrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Matrix.mbi(648:12-797:5)
class DenseMatrix(Matrix):
  @staticmethod
  def _matchargs_constructor__3_3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([[double]])")
  def __constructor__3_3F(self,d):
    mosek.fusion.Matrix._Matrix__constructor_II(self,( Utils.Tools._matrixheight__3_3F (d) ),( Utils.Tools._matrixwidth__3_3F (d) ))
    self._data = ([ 0.0 for _autovar_484 in xrange((self._dimi * self._dimj)) ])
    k = 0

    # src/fusion/Matrix.mbi(699:9-703:9)
    i = 0

    while (i < ( Utils.Tools._matrixheight__3_3F (d) )):
      ( Utils.Tools._arraycopy__3FI_3FII (d[i],0,self._data,k,self._dimj) )
      k = (k + self._dimj)
      i += 1
    self._nnz = long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Matrix)")
  def __constructor_Omosek_fusion_Matrix_2(self,m_):
    mosek.fusion.Matrix._Matrix__constructor_II(self,m_._dimi,m_._dimj)
    _autovar_485 = m_
    if   isinstance(_autovar_485,mosek.fusion.DenseMatrix):
      m = _autovar_485
      self._data = ( Utils.Tools._arraycopy__3F (m._data) )
    elif isinstance(_autovar_485,mosek.fusion.SparseMatrix):
      m = _autovar_485
      self._data = ( Utils.Tools._zeros_I ((m._dimi * m._dimj)) )
      # src/fusion/Matrix.mbi(723:11-726:11)
      for i in xrange(0l,m._nnz):
        # { @ src/fusion/Matrix.mbi(724:11-726:11)
        self._data[((m._subi[i] * self._dimj) + m._subj[i])] = m._val[i]
        # } @ src/fusion/Matrix.mbi(724:11-726:11)
    else:
      m = _autovar_485
      raise mosek.fusion.MatrixError("Unknown matrix type.")
    self._nnz = long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_constructor_II_3F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[double])")
  def __constructor_II_3F(self,dimi_,dimj_,cof):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    self._nnz = long((dimi_ * dimj_))
    self._data = ([ 0.0 for _autovar_486 in xrange((dimi_ * dimj_)) ])
    ( Utils.Tools._arraycopy__3FI_3FII (cof,0,self._data,0,(dimi_ * dimj_)) )
  def __init__(self,*args):
    #self._protected_data = None

    #self._protected_nnz = None

    if   self._matchargs_constructor__3_3F(args):
      self.__constructor__3_3F(*args)
    elif self._matchargs_constructor_Omosek_fusion_Matrix_2(args):
      self.__constructor_Omosek_fusion_Matrix_2(*args)
    elif self._matchargs_constructor_II_3F(args):
      self.__constructor_II_3F(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(658:15-660:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(664:15-686:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int32],[int32],[double])")
  def _getDataAsTriplets__3I_3I_3F(self,subi,subj,cof):
    if   (((int(len(subi)) < self._nnz) or (int(len(subj)) < self._nnz)) or (int(len(cof)) < self._nnz)):
      raise mosek.fusion.LengthError("Output arrays are not long enough.")
    ( Utils.Tools._arraycopy__3FI_3FII (self._data,0,cof,0,int(len(self._data))) )
    k = 0

    # src/fusion/Matrix.mbi(677:9-685:9)
    for i in xrange(0,self._dimi):
      # { @ src/fusion/Matrix.mbi(678:9-685:9)
      # src/fusion/Matrix.mbi(679:11-684:11)
      for j in xrange(0,self._dimj):
        # { @ src/fusion/Matrix.mbi(680:11-684:11)
        subi[k] = i
        subj[k] = j
        k += 1
        # } @ src/fusion/Matrix.mbi(680:11-684:11)
      # } @ src/fusion/Matrix.mbi(678:9-685:9)
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(758:15-776:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    newdata = ([ 0.0 for _autovar_487 in xrange((self._dimi * self._dimj)) ])

    srci = 0

    step = self._dimi

    # src/fusion/Matrix.mbi(764:9-774:9)
    for i in xrange(0,self._dimi):
      # { @ src/fusion/Matrix.mbi(765:9-774:9)
      dsti = i

      # src/fusion/Matrix.mbi(767:11-773:11)
      for j in xrange(0,self._dimj):
        # { @ src/fusion/Matrix.mbi(768:11-773:11)
        newdata[dsti] = self._data[srci]
        dsti = (dsti + step)
        srci += 1
        # } @ src/fusion/Matrix.mbi(768:11-773:11)
      # } @ src/fusion/Matrix.mbi(765:9-774:9)
    return mosek.fusion.DenseMatrix(self._dimj,self._dimi,newdata)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(779:15-796:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("DenseMatrix(") )
    ( sb._a_I(self._dimi) )
    ( sb._a_S(",") )
    ( sb._a_I(self._dimj) )
    ( sb._a_S(": ") )
    k = 0

    # src/fusion/Matrix.mbi(783:9-793:9)
    i = 0

    while (i < self._dimi):
      if   (i > 0):
        ( sb._a_S(",") )
      ( sb._a_S("[ ") )
      ( sb._a_F(self._data[k]) )
      k += 1
      # src/fusion/Matrix.mbi(787:11-791:11)
      j = 1

      while (j < self._dimj):
        ( sb._a_S(",") )
        ( sb._a_F(self._data[k]) )
        k += 1
        j += 1
      ( sb._a_S(" ]") )
      i += 1
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   DenseMatrix._matchargs_toString_(args):
      return DenseMatrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse([[double]])"),(1,"\tsparse([[mosek.fusion.Matrix]])"),(2,"\tsparse(int,int)"),(1,"\tsparse(mosek.fusion.Matrix)"),(5,"\tsparse(int,int,[int32],[int32],[double])"),(5,"\tsparse(int,int,[int32],[int32],float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdiag([mosek.fusion.Matrix])"),(1,"\tdiag([double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   DenseMatrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return DenseMatrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int32],[int32],[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def transpose(self,*args):
    if   DenseMatrix._matchargs_transpose_(args):
      return DenseMatrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numNonzeros(self,*args):
    if   DenseMatrix._matchargs_numNonzeros_(args):
      return DenseMatrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(4:12-4769:4)
class Parameters:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_string_1to_1solveform_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(7:10-13:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solveform_value(basestring)")
  def __string_1to_1solveform_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primal"):
      return 1
    elif (v == "dual"):
      return 2
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1problemitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(15:10-21:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_problemitem_value(basestring)")
  def __string_1to_1problemitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "var"):
      return 0
    elif (v == "cone"):
      return 2
    elif (v == "con"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1accmode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(23:10-28:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_accmode_value(basestring)")
  def __string_1to_1accmode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "var"):
      return 0
    elif (v == "con"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1sensitivitytype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(30:10-35:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_sensitivitytype_value(basestring)")
  def __string_1to_1sensitivitytype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "optimalPartition"):
      return 1
    elif (v == "basis"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1intpnthotstart_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(37:10-44:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_intpnthotstart_value(basestring)")
  def __string_1to_1intpnthotstart_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primal"):
      return 1
    elif (v == "none"):
      return 0
    elif (v == "dual"):
      return 2
    elif (v == "primalDual"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1sparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(46:10-75:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_sparam_value(basestring)")
  def __string_1to_1sparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "paramCommentSign"):
      return 9
    elif (v == "mioDebugString"):
      return 8
    elif (v == "feasrepairNamePrefix"):
      return 3
    elif (v == "basSolFileName"):
      return 0
    elif (v == "readMpsObjName"):
      return 13
    elif (v == "feasrepairNameWsumviol"):
      return 5
    elif (v == "feasrepairNameSeparator"):
      return 4
    elif (v == "paramWriteFileName"):
      return 11
    elif (v == "intSolFileName"):
      return 6
    elif (v == "readMpsRhsName"):
      return 15
    elif (v == "statFileName"):
      return 22
    elif (v == "writeLpGenVarName"):
      return 25
    elif (v == "dataFileName"):
      return 1
    elif (v == "readMpsRanName"):
      return 14
    elif (v == "solFilterXcLow"):
      return 18
    elif (v == "solFilterXcUpr"):
      return 19
    elif (v == "readMpsBouName"):
      return 12
    elif (v == "solFilterXxUpr"):
      return 21
    elif (v == "statName"):
      return 24
    elif (v == "paramReadFileName"):
      return 10
    elif (v == "itrSolFileName"):
      return 7
    elif (v == "sensitivityFileName"):
      return 16
    elif (v == "debugFileName"):
      return 2
    elif (v == "statKey"):
      return 23
    elif (v == "sensitivityResFileName"):
      return 17
    elif (v == "solFilterXxLow"):
      return 20
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(77:10-283:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iparam_value(basestring)")
  def __string_1to_1iparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "simStabilityPriority"):
      return 165
    elif (v == "simPrimalPhaseoneMethod"):
      return 156
    elif (v == "infeasReportAuto"):
      return 21
    elif (v == "mioNodeOptimizer"):
      return 88
    elif (v == "writeIgnoreIncompatiblePsdItems"):
      return 186
    elif (v == "presolveLevel"):
      return 115
    elif (v == "logNonconvex"):
      return 58
    elif (v == "mioMtUserCb"):
      return 87
    elif (v == "presolveUse"):
      return 120
    elif (v == "logSensitivityOpt"):
      return 65
    elif (v == "opfWriteSolItg"):
      return 106
    elif (v == "writeBasHead"):
      return 175
    elif (v == "mioBranchPrioritiesUse"):
      return 73
    elif (v == "mioCutLevelTree"):
      return 77
    elif (v == "feasrepairOptimize"):
      return 18
    elif (v == "readMpsRelax"):
      return 134
    elif (v == "opfWriteParameters"):
      return 103
    elif (v == "readCon"):
      return 124
    elif (v == "writeIntVariables"):
      return 189
    elif (v == "logConcurrent"):
      return 47
    elif (v == "intpntOrderMethod"):
      return 32
    elif (v == "opfWriteSolItr"):
      return 107
    elif (v == "logSensitivity"):
      return 64
    elif (v == "readQnz"):
      return 136
    elif (v == "logInfeasAna"):
      return 54
    elif (v == "simPrimalSelection"):
      return 158
    elif (v == "writeIntConstraints"):
      return 187
    elif (v == "sensitivityType"):
      return 141
    elif (v == "simDualRestrictSelection"):
      return 146
    elif (v == "logMioFreq"):
      return 57
    elif (v == "opfWriteSolBas"):
      return 105
    elif (v == "mioRootOptimizer"):
      return 94
    elif (v == "writeFreeCon"):
      return 180
    elif (v == "presolveElimFill"):
      return 112
    elif (v == "nonconvexMaxIterations"):
      return 98
    elif (v == "mioLocalBranchNumber"):
      return 82
    elif (v == "writeGenericNames"):
      return 181
    elif (v == "warningLevel"):
      return 173
    elif (v == "logBiFreq"):
      return 45
    elif (v == "concurrentPriorityDualSimplex"):
      return 14
    elif (v == "logPresolve"):
      return 62
    elif (v == "writeLpStrictFormat"):
      return 192
    elif (v == "writeSolConstraints"):
      return 197
    elif (v == "intpntOffColTrh"):
      return 31
    elif (v == "readAnz"):
      return 123
    elif (v == "mioMode"):
      return 86
    elif (v == "primalRepairOptimizer"):
      return 121
    elif (v == "readLpDropNewVarsInBou"):
      return 129
    elif (v == "logSim"):
      return 66
    elif (v == "mtSpincount"):
      return 97
    elif (v == "solutionCallback"):
      return 171
    elif (v == "simScalingMethod"):
      return 163
    elif (v == "logSimFreq"):
      return 67
    elif (v == "presolveMaxNumReductions"):
      return 119
    elif (v == "writeLpQuotedNames"):
      return 191
    elif (v == "logFactor"):
      return 50
    elif (v == "autoUpdateSolInfo"):
      return 4
    elif (v == "readMpsWidth"):
      return 135
    elif (v == "timingLevel"):
      return 172
    elif (v == "logOrder"):
      return 60
    elif (v == "mioCutLevelRoot"):
      return 76
    elif (v == "paramReadIgnError"):
      return 111
    elif (v == "basisSolveUsePlusOne"):
      return 5
    elif (v == "biIgnoreNumError"):
      return 8
    elif (v == "mioNodeSelection"):
      return 89
    elif (v == "anaSolPrintViolated"):
      return 2
    elif (v == "solReadWidth"):
      return 170
    elif (v == "intpntMaxNumRefinementSteps"):
      return 30
    elif (v == "logSimMinor"):
      return 68
    elif (v == "simMaxIterations"):
      return 152
    elif (v == "intpntMaxIterations"):
      return 28
    elif (v == "cacheLicense"):
      return 10
    elif (v == "logBi"):
      return 44
    elif (v == "intpntMaxNumCor"):
      return 29
    elif (v == "writeLpLineWidth"):
      return 190
    elif (v == "compressStatfile"):
      return 12
    elif (v == "solReadNameWidth"):
      return 169
    elif (v == "licenseDebug"):
      return 39
    elif (v == "licTrhExpiryWrn"):
      return 37
    elif (v == "anaSolBasis"):
      return 1
    elif (v == "presolveEliminatorMaxNumTries"):
      return 113
    elif (v == "writeGenericNamesIo"):
      return 182
    elif (v == "concurrentNumOptimizers"):
      return 13
    elif (v == "simRefactorFreq"):
      return 159
    elif (v == "simDualSelection"):
      return 147
    elif (v == "simSolveForm"):
      return 164
    elif (v == "checkConvexity"):
      return 11
    elif (v == "qoSeparableReformulation"):
      return 122
    elif (v == "writeIgnoreIncompatibleItems"):
      return 184
    elif (v == "readTaskIgnoreParam"):
      return 137
    elif (v == "mioOptimizerMode"):
      return 90
    elif (v == "logIntpnt"):
      return 55
    elif (v == "logMio"):
      return 56
    elif (v == "simHotstart"):
      return 149
    elif (v == "logParam"):
      return 61
    elif (v == "writeDataFormat"):
      return 178
    elif (v == "simExploitDupvec"):
      return 148
    elif (v == "mioBranchDir"):
      return 72
    elif (v == "intpntFactorDebugLvl"):
      return 25
    elif (v == "licensePauseTime"):
      return 40
    elif (v == "mioPresolveAggregate"):
      return 91
    elif (v == "writeTaskIncSol"):
      return 201
    elif (v == "biMaxIterations"):
      return 9
    elif (v == "simHotstartLu"):
      return 150
    elif (v == "presolveLindepRelWorkTrh"):
      return 117
    elif (v == "opfWriteSolutions"):
      return 108
    elif (v == "logFeasRepair"):
      return 51
    elif (v == "presolveLindepUse"):
      return 118
    elif (v == "intpntHotstart"):
      return 27
    elif (v == "opfWriteHeader"):
      return 101
    elif (v == "mioContSol"):
      return 75
    elif (v == "writeIntHead"):
      return 188
    elif (v == "intpntStartingPoint"):
      return 36
    elif (v == "writeSolBarvariables"):
      return 196
    elif (v == "simMaxNumSetbacks"):
      return 153
    elif (v == "concurrentPriorityPrimalSimplex"):
      return 17
    elif (v == "readMpsObjSense"):
      return 133
    elif (v == "logSimNetworkFreq"):
      return 69
    elif (v == "intpntDiffStep"):
      return 24
    elif (v == "simScaling"):
      return 162
    elif (v == "writeLpTermsPerLine"):
      return 193
    elif (v == "sensitivityAll"):
      return 139
    elif (v == "writeIgnoreIncompatibleConicItems"):
      return 183
    elif (v == "biIgnoreMaxIter"):
      return 7
    elif (v == "presolveLindepAbsWorkTrh"):
      return 116
    elif (v == "intpntSolveForm"):
      return 35
    elif (v == "opfMaxTermsPerLine"):
      return 100
    elif (v == "writePrecision"):
      return 195
    elif (v == "simBasisFactorUse"):
      return 142
    elif (v == "writeXmlMode"):
      return 202
    elif (v == "intpntRegularizationUse"):
      return 33
    elif (v == "biCleanOptimizer"):
      return 6
    elif (v == "mioPresolveProbing"):
      return 92
    elif (v == "licenseAllowOveruse"):
      return 38
    elif (v == "infeasPreferPrimal"):
      return 20
    elif (v == "writeIgnoreIncompatibleNlItems"):
      return 185
    elif (v == "writeBasVariables"):
      return 176
    elif (v == "logStorage"):
      return 70
    elif (v == "mioPresolveUse"):
      return 93
    elif (v == "readLpQuotedNames"):
      return 130
    elif (v == "intpntBasis"):
      return 23
    elif (v == "logCutSecondOpt"):
      return 48
    elif (v == "readMpsKeepInt"):
      return 132
    elif (v == "mioMaxNumSolutions"):
      return 85
    elif (v == "writeSolVariables"):
      return 200
    elif (v == "sensitivityOptimizer"):
      return 140
    elif (v == "writeMpsInt"):
      return 194
    elif (v == "licenseWait"):
      return 42
    elif (v == "concurrentPriorityFreeSimplex"):
      return 15
    elif (v == "readKeepFreeCon"):
      return 128
    elif (v == "logFile"):
      return 52
    elif (v == "concurrentPriorityIntpnt"):
      return 16
    elif (v == "simNonSingular"):
      return 154
    elif (v == "writeDataParam"):
      return 179
    elif (v == "simDegen"):
      return 143
    elif (v == "opfWriteHints"):
      return 102
    elif (v == "presolveEliminatorUse"):
      return 114
    elif (v == "allocAddQnz"):
      return 0
    elif (v == "mioHotstart"):
      return 80
    elif (v == "readMpsFormat"):
      return 131
    elif (v == "paramReadCaseName"):
      return 110
    elif (v == "logOptimizer"):
      return 59
    elif (v == "mioMaxNumBranches"):
      return 83
    elif (v == "simPrimalCrash"):
      return 155
    elif (v == "mioConstructSol"):
      return 74
    elif (v == "autoSortABeforeOpt"):
      return 3
    elif (v == "mioStrongBranch"):
      return 95
    elif (v == "simDualPhaseoneMethod"):
      return 145
    elif (v == "simInteger"):
      return 151
    elif (v == "mioUseMultithreadedOptimizer"):
      return 96
    elif (v == "simPrimalRestrictSelection"):
      return 157
    elif (v == "readCone"):
      return 125
    elif (v == "optimizer"):
      return 109
    elif (v == "maxNumWarnings"):
      return 71
    elif (v == "licenseSuppressExpireWrns"):
      return 41
    elif (v == "writeSolIgnoreInvalidNames"):
      return 199
    elif (v == "writeSolHead"):
      return 198
    elif (v == "writeBasConstraints"):
      return 174
    elif (v == "logExpand"):
      return 49
    elif (v == "mioFeaspumpLevel"):
      return 78
    elif (v == "infeasGenericNames"):
      return 19
    elif (v == "logResponse"):
      return 63
    elif (v == "log"):
      return 43
    elif (v == "infeasReportLevel"):
      return 22
    elif (v == "writeDataCompressed"):
      return 177
    elif (v == "simSwitchOptimizer"):
      return 166
    elif (v == "readDataCompressed"):
      return 126
    elif (v == "solFilterKeepRanged"):
      return 168
    elif (v == "opfWriteProblem"):
      return 104
    elif (v == "numThreads"):
      return 99
    elif (v == "logCheckConvexity"):
      return 46
    elif (v == "readDataFormat"):
      return 127
    elif (v == "simDualCrash"):
      return 144
    elif (v == "readVar"):
      return 138
    elif (v == "logHead"):
      return 53
    elif (v == "simReformulation"):
      return 160
    elif (v == "simSaveLu"):
      return 161
    elif (v == "intpntFactorMethod"):
      return 26
    elif (v == "mioMaxNumRelaxs"):
      return 84
    elif (v == "solFilterKeepBasic"):
      return 167
    elif (v == "mioHeuristicLevel"):
      return 79
    elif (v == "mioKeepBasis"):
      return 81
    elif (v == "intpntScaling"):
      return 34
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1solsta_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(285:10-303:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solsta_value(basestring)")
  def __string_1to_1solsta_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "dualInfeasCer"):
      return 6
    elif (v == "primInfeasCer"):
      return 5
    elif (v == "unknown"):
      return 0
    elif (v == "nearOptimal"):
      return 8
    elif (v == "nearPrimInfeasCer"):
      return 12
    elif (v == "primFeas"):
      return 2
    elif (v == "nearIntegerOptimal"):
      return 15
    elif (v == "nearDualFeas"):
      return 10
    elif (v == "integerOptimal"):
      return 14
    elif (v == "nearDualInfeasCer"):
      return 13
    elif (v == "nearPrimAndDualFeas"):
      return 11
    elif (v == "optimal"):
      return 1
    elif (v == "primAndDualFeas"):
      return 4
    elif (v == "nearPrimFeas"):
      return 9
    elif (v == "dualFeas"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1objsense_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(305:10-310:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_objsense_value(basestring)")
  def __string_1to_1objsense_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "minimize"):
      return 0
    elif (v == "maximize"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1solitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(312:10-323:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solitem_value(basestring)")
  def __string_1to_1solitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "suc"):
      return 4
    elif (v == "xc"):
      return 0
    elif (v == "xx"):
      return 1
    elif (v == "y"):
      return 2
    elif (v == "slx"):
      return 5
    elif (v == "sux"):
      return 6
    elif (v == "snx"):
      return 7
    elif (v == "slc"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1boundkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(325:10-333:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_boundkey_value(basestring)")
  def __string_1to_1boundkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "fx"):
      return 2
    elif (v == "lo"):
      return 0
    elif (v == "fr"):
      return 3
    elif (v == "up"):
      return 1
    elif (v == "ra"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1iinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(335:10-445:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_iinf_value(basestring)")
  def __string_1to_1internal_1iinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "presolveNumvar"):
      return 75
    elif (v == "presolveNumnza"):
      return 74
    elif (v == "presolveFnumnza"):
      return 47
    elif (v == "presolveForceConNum"):
      return 55
    elif (v == "intpntFactorNum"):
      return 11
    elif (v == "presolveForceVarNumCon"):
      return 58
    elif (v == "presolveFnumvlo"):
      return 51
    elif (v == "simNetworkDualHotstartBasisRank"):
      return 88
    elif (v == "simNumNetworkVar"):
      return 96
    elif (v == "simNumDualIntegerPivots"):
      return 93
    elif (v == "presolveEliminatorSkippedSpace"):
      return 39
    elif (v == "presolveFnumcup"):
      return 46
    elif (v == "intpntNumqcones"):
      return 28
    elif (v == "presolveLindepWork"):
      return 64
    elif (v == "presolveOutofspace"):
      return 82
    elif (v == "intpntFactorDim"):
      return 10
    elif (v == "presolveLindepPivots"):
      return 62
    elif (v == "presolveNumvra"):
      return 80
    elif (v == "simNumDualBoundswaps"):
      return 92
    elif (v == "presolveNumclo"):
      return 69
    elif (v == "simPrimalTrust"):
      return 106
    elif (v == "presolveNumDouChains"):
      return 66
    elif (v == "intpntNumvar"):
      return 30
    elif (v == "presolveForceVarNum"):
      return 57
    elif (v == "simNumPrimalBoundswaps"):
      return 97
    elif (v == "simPrimalDualHotstartNumBasics"):
      return 100
    elif (v == "concurrentNumThreads"):
      return 3
    elif (v == "presolveFnumcon"):
      return 44
    elif (v == "presolveLindepNum"):
      return 59
    elif (v == "simPrimalHotstartBasisRank"):
      return 103
    elif (v == "presolveNumcra"):
      return 72
    elif (v == "numLuFactorizations"):
      return 32
    elif (v == "intpntNumbndconevar"):
      return 23
    elif (v == "concurrentOptimizerThread5"):
      return 9
    elif (v == "concurrentOptimizerThread2"):
      return 6
    elif (v == "concurrentOptimizerThread3"):
      return 7
    elif (v == "concurrentOptimizerThread0"):
      return 4
    elif (v == "concurrentOptimizerThread1"):
      return 5
    elif (v == "simPrimalHotstartNumBasics"):
      return 104
    elif (v == "simDualHotstartBasisRank"):
      return 84
    elif (v == "intpntNumcon"):
      return 25
    elif (v == "presolveFnumcfx"):
      return 41
    elif (v == "simDualTrust"):
      return 87
    elif (v == "presolveFnumcfr"):
      return 40
    elif (v == "presolveFnumvra"):
      return 53
    elif (v == "presolveNumcfr"):
      return 67
    elif (v == "presolveNumcnl"):
      return 70
    elif (v == "presolveNumcfx"):
      return 68
    elif (v == "intpntMaxbarvardim"):
      return 15
    elif (v == "simNetworkPrimalHotstartNumBasics"):
      return 91
    elif (v == "simNetworkPrimalHotstartBasisRank"):
      return 90
    elif (v == "presolveNumcup"):
      return 73
    elif (v == "simPrimalDualDoPrimalLog"):
      return 98
    elif (v == "presolvePivOnConNum"):
      return 83
    elif (v == "concurrentOptimizerThread4"):
      return 8
    elif (v == "concurrentNumOptimizers"):
      return 2
    elif (v == "intpntFactorNumSolve"):
      return 12
    elif (v == "intpntMinconedim"):
      return 17
    elif (v == "presolveNumvup"):
      return 81
    elif (v == "intpntNumblo"):
      return 22
    elif (v == "presolveFnumcra"):
      return 45
    elif (v == "intpntMaxconedim"):
      return 16
    elif (v == "presolveLindepSkipped"):
      return 63
    elif (v == "optObjectiveSense"):
      return 33
    elif (v == "presolveNumvnl"):
      return 79
    elif (v == "presolveNumvfr"):
      return 76
    elif (v == "presolveNumvfx"):
      return 77
    elif (v == "intpntNumcone"):
      return 26
    elif (v == "simDualHotstartNumBasics"):
      return 85
    elif (v == "presolveFnumvar"):
      return 48
    elif (v == "intpntNumbarvar"):
      return 19
    elif (v == "simNumDupvec"):
      return 94
    elif (v == "intpntFirRefIter"):
      return 13
    elif (v == "presolveFnumclo"):
      return 42
    elif (v == "simNetworkDualHotstartNumBasics"):
      return 89
    elif (v == "biDualInfo"):
      return 0
    elif (v == "presolveForceConNumVar"):
      return 56
    elif (v == "intpntNumbfr"):
      return 20
    elif (v == "nonconvexIter"):
      return 31
    elif (v == "intpntNumrqcones"):
      return 29
    elif (v == "intpntNumbfx"):
      return 21
    elif (v == "presolveFnumvup"):
      return 54
    elif (v == "intpntNumbup"):
      return 24
    elif (v == "simPrimalDualTrust"):
      return 102
    elif (v == "presolveFnumvnl"):
      return 52
    elif (v == "presolveLindepNumTries"):
      return 60
    elif (v == "biPrimalInfo"):
      return 1
    elif (v == "presolveNumvlo"):
      return 78
    elif (v == "optimizer"):
      return 34
    elif (v == "simNumNetworkCon"):
      return 95
    elif (v == "presolveNumcon"):
      return 71
    elif (v == "simDualNumSetbacks"):
      return 86
    elif (v == "presolveFnumvfr"):
      return 49
    elif (v == "simPrimalNumSetbacks"):
      return 105
    elif (v == "simPrimalDualHotstartBasisRank"):
      return 99
    elif (v == "presolveFnumvfx"):
      return 50
    elif (v == "simPrimalDualNumSetbacks"):
      return 101
    elif (v == "intpntGpOrderEmployed"):
      return 14
    elif (v == "presolveLindepNumTruncTries"):
      return 61
    elif (v == "presolveNumConsInDouChains"):
      return 65
    elif (v == "intpntNumRefSteps"):
      return 18
    elif (v == "presolveFnumcnl"):
      return 43
    elif (v == "intpntNumconevar"):
      return 27
    elif (v == "presolveEliNumTries"):
      return 38
    elif (v == "presolveEliNum"):
      return 37
    elif (v == "presolveCompressedStackSize"):
      return 36
    elif (v == "presolveBadPrecision"):
      return 35
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1basindtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(447:10-455:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_basindtype_value(basestring)")
  def __string_1to_1basindtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "always"):
      return 1
    elif (v == "noError"):
      return 2
    elif (v == "never"):
      return 0
    elif (v == "ifFeasible"):
      return 3
    elif (v == "reservered"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1branchdir_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(457:10-463:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_branchdir_value(basestring)")
  def __string_1to_1branchdir_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "down"):
      return 2
    elif (v == "up"):
      return 1
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1liinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(465:10-482:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_liinfitem_value(basestring)")
  def __string_1to_1liinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "biCleanPrimalIter"):
      return 6
    elif (v == "intpntFactorNumNz"):
      return 9
    elif (v == "mioIntpntIter"):
      return 10
    elif (v == "biCleanPrimalDualIter"):
      return 4
    elif (v == "biCleanPrimalDualDegIter"):
      return 3
    elif (v == "biCleanPrimalDegIter"):
      return 2
    elif (v == "biCleanDualIter"):
      return 1
    elif (v == "rdNumqnz"):
      return 13
    elif (v == "rdNumanz"):
      return 12
    elif (v == "biPrimalIter"):
      return 8
    elif (v == "biDualIter"):
      return 7
    elif (v == "biCleanDualDegIter"):
      return 0
    elif (v == "mioSimplexIter"):
      return 11
    elif (v == "biCleanPrimalDualSubIter"):
      return 5
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1streamtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(484:10-491:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_streamtype_value(basestring)")
  def __string_1to_1streamtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "msg"):
      return 1
    elif (v == "wrn"):
      return 3
    elif (v == "log"):
      return 0
    elif (v == "err"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simhotstart_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(493:10-499:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simhotstart_value(basestring)")
  def __string_1to_1simhotstart_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 0
    elif (v == "statusKeys"):
      return 2
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1callbackcode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(501:10-618:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_callbackcode_value(basestring)")
  def __string_1to_1callbackcode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "endIntpnt"):
      return 45
    elif (v == "beginPrimalDualSimplexBi"):
      return 21
    elif (v == "endNetworkPrimalSimplex"):
      return 49
    elif (v == "updatePrimalSimplexBi"):
      return 112
    elif (v == "endMio"):
      return 47
    elif (v == "beginNetworkDualSimplex"):
      return 13
    elif (v == "endPrimalRepair"):
      return 57
    elif (v == "endConcurrent"):
      return 36
    elif (v == "newIntMio"):
      return 96
    elif (v == "imPrimalSimplex"):
      return 90
    elif (v == "endSimplexNetworkDetect"):
      return 66
    elif (v == "endNetworkDualSimplex"):
      return 48
    elif (v == "imIntpnt"):
      return 74
    elif (v == "imDualBi"):
      return 70
    elif (v == "beginFullConvexityCheck"):
      return 8
    elif (v == "beginDualBi"):
      return 3
    elif (v == "beginDualSensitivity"):
      return 4
    elif (v == "imMioPrimalSimplex"):
      return 81
    elif (v == "beginPrimalBi"):
      return 19
    elif (v == "beginConcurrent"):
      return 1
    elif (v == "updateDualBi"):
      return 101
    elif (v == "imDualSimplex"):
      return 72
    elif (v == "beginPrimalRepair"):
      return 22
    elif (v == "beginLicenseWait"):
      return 11
    elif (v == "imNetworkPrimalSimplex"):
      return 83
    elif (v == "endNetworkSimplex"):
      return 50
    elif (v == "conic"):
      return 33
    elif (v == "imQoReformulate"):
      return 91
    elif (v == "beginConic"):
      return 2
    elif (v == "updateDualSimplexBi"):
      return 103
    elif (v == "endOptimizer"):
      return 52
    elif (v == "updatePresolve"):
      return 107
    elif (v == "imSimplex"):
      return 93
    elif (v == "readOpf"):
      return 99
    elif (v == "imLicenseWait"):
      return 75
    elif (v == "beginNetworkSimplex"):
      return 15
    elif (v == "endConic"):
      return 37
    elif (v == "updateNetworkDualSimplex"):
      return 104
    elif (v == "beginQcqoReformulate"):
      return 27
    elif (v == "endDualSensitivity"):
      return 39
    elif (v == "endPrimalSimplexBi"):
      return 61
    elif (v == "readOpfSection"):
      return 100
    elif (v == "imLu"):
      return 76
    elif (v == "endDualSimplexBi"):
      return 42
    elif (v == "endLicenseWait"):
      return 46
    elif (v == "imPresolve"):
      return 86
    elif (v == "beginDualSetupBi"):
      return 5
    elif (v == "endInfeasAna"):
      return 44
    elif (v == "intpnt"):
      return 95
    elif (v == "updatePrimalBi"):
      return 108
    elif (v == "noncovex"):
      return 97
    elif (v == "updatePrimalDualSimplexBi"):
      return 110
    elif (v == "updateNonconvex"):
      return 106
    elif (v == "endDualBi"):
      return 38
    elif (v == "endRead"):
      return 63
    elif (v == "beginPrimalSimplexBi"):
      return 26
    elif (v == "beginSimplexNetworkDetect"):
      return 31
    elif (v == "imPrimalDualSimplex"):
      return 88
    elif (v == "updatePrimalSimplex"):
      return 111
    elif (v == "dualSimplex"):
      return 34
    elif (v == "imFullConvexityCheck"):
      return 73
    elif (v == "primalSimplex"):
      return 98
    elif (v == "beginNonconvex"):
      return 16
    elif (v == "imSimplexBi"):
      return 94
    elif (v == "beginDualSimplex"):
      return 6
    elif (v == "beginPrimalSimplex"):
      return 25
    elif (v == "endNonconvex"):
      return 51
    elif (v == "beginPrimalSetupBi"):
      return 24
    elif (v == "imRead"):
      return 92
    elif (v == "beginOptimizer"):
      return 17
    elif (v == "beginRead"):
      return 28
    elif (v == "imNonconvex"):
      return 84
    elif (v == "endPrimalSimplex"):
      return 60
    elif (v == "endPrimalDualSimplexBi"):
      return 56
    elif (v == "imBi"):
      return 68
    elif (v == "imNetworkDualSimplex"):
      return 82
    elif (v == "endDualSetupBi"):
      return 40
    elif (v == "endBi"):
      return 35
    elif (v == "endPrimalSetupBi"):
      return 59
    elif (v == "beginWrite"):
      return 32
    elif (v == "endSimplexBi"):
      return 65
    elif (v == "endPrimalSensitivity"):
      return 58
    elif (v == "beginSimplex"):
      return 29
    elif (v == "endPresolve"):
      return 53
    elif (v == "beginInfeasAna"):
      return 9
    elif (v == "beginPrimalDualSimplex"):
      return 20
    elif (v == "beginPrimalSensitivity"):
      return 23
    elif (v == "beginDualSimplexBi"):
      return 7
    elif (v == "endQcqoReformulate"):
      return 62
    elif (v == "imPrimalSensivity"):
      return 89
    elif (v == "endWrite"):
      return 67
    elif (v == "endDualSimplex"):
      return 41
    elif (v == "updatePrimalDualSimplex"):
      return 109
    elif (v == "beginSimplexBi"):
      return 30
    elif (v == "beginIntpnt"):
      return 10
    elif (v == "imDualSensivity"):
      return 71
    elif (v == "endSimplex"):
      return 64
    elif (v == "endPrimalBi"):
      return 54
    elif (v == "imMio"):
      return 77
    elif (v == "updateDualSimplex"):
      return 102
    elif (v == "imMioIntpnt"):
      return 79
    elif (v == "endPrimalDualSimplex"):
      return 55
    elif (v == "imConic"):
      return 69
    elif (v == "imMioPresolve"):
      return 80
    elif (v == "beginBi"):
      return 0
    elif (v == "imMioDualSimplex"):
      return 78
    elif (v == "writeOpf"):
      return 113
    elif (v == "updateNetworkPrimalSimplex"):
      return 105
    elif (v == "endFullConvexityCheck"):
      return 43
    elif (v == "imOrder"):
      return 85
    elif (v == "imPrimalBi"):
      return 87
    elif (v == "beginPresolve"):
      return 18
    elif (v == "beginMio"):
      return 12
    elif (v == "beginNetworkPrimalSimplex"):
      return 14
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1symmattype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(620:10-624:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_symmattype_value(basestring)")
  def __string_1to_1symmattype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "sparse"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1feature_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(626:10-633:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_feature_value(basestring)")
  def __string_1to_1feature_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "ptom"):
      return 2
    elif (v == "pton"):
      return 1
    elif (v == "pts"):
      return 0
    elif (v == "ptox"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mark_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(635:10-640:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mark_value(basestring)")
  def __string_1to_1mark_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "lo"):
      return 0
    elif (v == "up"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1conetype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(642:10-647:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_conetype_value(basestring)")
  def __string_1to_1conetype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "quad"):
      return 0
    elif (v == "rquad"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1feasrepairtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(649:10-655:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_feasrepairtype_value(basestring)")
  def __string_1to_1feasrepairtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "optimizeNone"):
      return 0
    elif (v == "optimizeCombined"):
      return 2
    elif (v == "optimizePenalty"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iomode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(657:10-663:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iomode_value(basestring)")
  def __string_1to_1iomode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "read"):
      return 0
    elif (v == "write"):
      return 1
    elif (v == "readwrite"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1liinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(665:10-675:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_liinf_value(basestring)")
  def __string_1to_1internal_1liinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "intpntLenbarvar"):
      return 5
    elif (v == "intpntFactorNumNzBefore"):
      return 2
    elif (v == "intpntFactorGpOrderSparseLNz"):
      return 0
    elif (v == "intpntFactorMlOrderSparseLNz"):
      return 1
    elif (v == "intpntFactorUpdatedVNz"):
      return 3
    elif (v == "intpntFactorVNz"):
      return 4
    elif (v == "presolveStackSize"):
      return 6
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simseltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(677:10-686:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simseltype_value(basestring)")
  def __string_1to_1simseltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "full"):
      return 1
    elif (v == "partial"):
      return 5
    elif (v == "free"):
      return 0
    elif (v == "ase"):
      return 2
    elif (v == "devex"):
      return 3
    elif (v == "se"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1msgkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(688:10-694:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_msgkey_value(basestring)")
  def __string_1to_1msgkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "readingFile"):
      return 1000
    elif (v == "writingFile"):
      return 1001
    elif (v == "mpsSelected"):
      return 1100
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1miomode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(696:10-702:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_miomode_value(basestring)")
  def __string_1to_1miomode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "ignored"):
      return 0
    elif (v == "lazy"):
      return 2
    elif (v == "satisfied"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(704:10-772:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dinfitem_value(basestring)")
  def __string_1to_1dinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "solItgPviolcones"):
      return 52
    elif (v == "intpntPrimalFeas"):
      return 13
    elif (v == "solItrDviolbarvar"):
      return 56
    elif (v == "solBasDviolvar"):
      return 45
    elif (v == "presolveEliTime"):
      return 28
    elif (v == "mioOptimizerTime"):
      return 22
    elif (v == "intpntFactorNumFlops"):
      return 10
    elif (v == "mioTime"):
      return 25
    elif (v == "biDualTime"):
      return 4
    elif (v == "simNetworkTime"):
      return 38
    elif (v == "presolveTime"):
      return 30
    elif (v == "presolveLindepTime"):
      return 29
    elif (v == "simDualTime"):
      return 34
    elif (v == "simObj"):
      return 39
    elif (v == "mioObjRelGap"):
      return 21
    elif (v == "solBasPrimalObj"):
      return 46
    elif (v == "mioHeuristicTime"):
      return 17
    elif (v == "solItrPviolcon"):
      return 62
    elif (v == "solItgPviolbarvar"):
      return 50
    elif (v == "optimizerTime"):
      return 27
    elif (v == "mioRootPresolveTime"):
      return 24
    elif (v == "solItgPviolcon"):
      return 51
    elif (v == "intpntDualObj"):
      return 9
    elif (v == "intpntTime"):
      return 15
    elif (v == "mioConstructSolutionObj"):
      return 16
    elif (v == "simFeas"):
      return 35
    elif (v == "simPrimalTime"):
      return 41
    elif (v == "simTime"):
      return 42
    elif (v == "simNetworkPrimalTime"):
      return 37
    elif (v == "concurrentTime"):
      return 7
    elif (v == "biCleanTime"):
      return 3
    elif (v == "qcqoReformulateTime"):
      return 32
    elif (v == "solItrDualObj"):
      return 55
    elif (v == "solItrPviolcones"):
      return 63
    elif (v == "intpntDualFeas"):
      return 8
    elif (v == "solItrPviolbarvar"):
      return 61
    elif (v == "rdTime"):
      return 33
    elif (v == "solBasDviolcon"):
      return 44
    elif (v == "solItrPrimalObj"):
      return 60
    elif (v == "solItrPviolvar"):
      return 64
    elif (v == "solItrDviolcon"):
      return 57
    elif (v == "simNetworkDualTime"):
      return 36
    elif (v == "solItgPrimalObj"):
      return 49
    elif (v == "mioObjInt"):
      return 20
    elif (v == "mioUserObjCut"):
      return 26
    elif (v == "solItgPviolitg"):
      return 53
    elif (v == "intpntOptStatus"):
      return 11
    elif (v == "primalRepairPenaltyObj"):
      return 31
    elif (v == "mioObjBound"):
      return 19
    elif (v == "biCleanDualTime"):
      return 0
    elif (v == "biTime"):
      return 6
    elif (v == "solBasDualObj"):
      return 43
    elif (v == "biCleanPrimalDualTime"):
      return 1
    elif (v == "solItgPviolvar"):
      return 54
    elif (v == "intpntPrimalObj"):
      return 14
    elif (v == "intpntOrderTime"):
      return 12
    elif (v == "biPrimalTime"):
      return 5
    elif (v == "solBasPviolcon"):
      return 47
    elif (v == "mioObjAbsGap"):
      return 18
    elif (v == "solItrDviolvar"):
      return 59
    elif (v == "solItrDviolcones"):
      return 58
    elif (v == "solBasPviolvar"):
      return 48
    elif (v == "simPrimalDualTime"):
      return 40
    elif (v == "biCleanPrimalTime"):
      return 2
    elif (v == "mioRootOptimizerTime"):
      return 23
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1parametertype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(774:10-781:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_parametertype_value(basestring)")
  def __string_1to_1parametertype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "invalidType"):
      return 0
    elif (v == "strType"):
      return 3
    elif (v == "douType"):
      return 1
    elif (v == "intType"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1rescodetype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(783:10-791:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_rescodetype_value(basestring)")
  def __string_1to_1rescodetype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "wrn"):
      return 1
    elif (v == "trm"):
      return 2
    elif (v == "unk"):
      return 4
    elif (v == "ok"):
      return 0
    elif (v == "err"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1prosta_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(793:10-808:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_prosta_value(basestring)")
  def __string_1to_1prosta_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primAndDualInfeas"):
      return 6
    elif (v == "primInfeas"):
      return 4
    elif (v == "illPosed"):
      return 7
    elif (v == "unknown"):
      return 0
    elif (v == "primFeas"):
      return 2
    elif (v == "nearPrimAndDualFeas"):
      return 8
    elif (v == "nearDualFeas"):
      return 10
    elif (v == "primInfeasOrUnbounded"):
      return 11
    elif (v == "primAndDualFeas"):
      return 1
    elif (v == "dualInfeas"):
      return 5
    elif (v == "nearPrimFeas"):
      return 9
    elif (v == "dualFeas"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1scalingtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(810:10-817:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_scalingtype_value(basestring)")
  def __string_1to_1scalingtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 1
    elif (v == "moderate"):
      return 2
    elif (v == "aggressive"):
      return 3
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1rescode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(819:10-1224:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_rescode_value(basestring)")
  def __string_1to_1rescode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "errParamType"):
      return 1218
    elif (v == "errInvSkx"):
      return 1268
    elif (v == "errMulAElement"):
      return 1254
    elif (v == "errInvalidNameInSolFile"):
      return 1170
    elif (v == "errInvalidNetworkProblem"):
      return 1504
    elif (v == "errMpsMulQsec"):
      return 1113
    elif (v == "errSenIndexInvalid"):
      return 3055
    elif (v == "errInvSkn"):
      return 1274
    elif (v == "errInvSkc"):
      return 1267
    elif (v == "errIndexIsTooLarge"):
      return 1204
    elif (v == "errFeasrepairCannotRelax"):
      return 1700
    elif (v == "errInvConeTypeStr"):
      return 1271
    elif (v == "wrnLicenseFeatureExpire"):
      return 505
    elif (v == "errInvalidCompression"):
      return 1800
    elif (v == "wrnZerosInSparseRow"):
      return 705
    elif (v == "wrnSolFileIgnoredCon"):
      return 351
    elif (v == "errArgIsTooLarge"):
      return 1227
    elif (v == "errUserNloFunc"):
      return 1432
    elif (v == "wrnZeroAij"):
      return 63
    elif (v == "errLpWriteConicProblem"):
      return 1163
    elif (v == "errUpperBoundIsANan"):
      return 1391
    elif (v == "errSymMatDuplicate"):
      return 3944
    elif (v == "errIndexArrIsTooSmall"):
      return 1221
    elif (v == "errLicenseMax"):
      return 1016
    elif (v == "wrnDuplicateConstraintNames"):
      return 850
    elif (v == "errInvalidFormatType"):
      return 1283
    elif (v == "errNoPrimalInfeasCer"):
      return 2000
    elif (v == "errTooManyConcurrentTasks"):
      return 3090
    elif (v == "trmStall"):
      return 10006
    elif (v == "errOpfPrematureEof"):
      return 1172
    elif (v == "errLivingTasks"):
      return 1066
    elif (v == "errMaxnumcone"):
      return 1304
    elif (v == "errNumvarlim"):
      return 1251
    elif (v == "wrnUsingGenericNames"):
      return 503
    elif (v == "errRepairInvalidProblem"):
      return 1710
    elif (v == "errParamValueStr"):
      return 1217
    elif (v == "errQobjUpperTriangle"):
      return 1415
    elif (v == "errLowerBoundIsANan"):
      return 1390
    elif (v == "errNullPointer"):
      return 1065
    elif (v == "errParamNameStr"):
      return 1208
    elif (v == "errParamIsTooSmall"):
      return 1216
    elif (v == "errSolverProbtype"):
      return 1259
    elif (v == "errInfIntIndex"):
      return 1220
    elif (v == "errUserNloEvalHessubi"):
      return 1440
    elif (v == "errUserNloEvalHessubj"):
      return 1441
    elif (v == "errOpenDl"):
      return 1030
    elif (v == "errLast"):
      return 1262
    elif (v == "errLpEmpty"):
      return 1151
    elif (v == "errLicenseServerVersion"):
      return 1026
    elif (v == "errThreadMutexInit"):
      return 1045
    elif (v == "errInvNameItem"):
      return 1280
    elif (v == "wrnLargeLoBound"):
      return 52
    elif (v == "errSenBoundInvalidUp"):
      return 3053
    elif (v == "errDuplicateBarvariableNames"):
      return 4502
    elif (v == "errConeType"):
      return 1305
    elif (v == "wrnAnaAlmostIntBounds"):
      return 904
    elif (v == "wrnConstructInvalidSolItg"):
      return 807
    elif (v == "errNullTask"):
      return 1061
    elif (v == "wrnLicenseExpire"):
      return 500
    elif (v == "errSpace"):
      return 1051
    elif (v == "errNullEnv"):
      return 1060
    elif (v == "errNumconlim"):
      return 1250
    elif (v == "errRepairOptimizationFailed"):
      return 1711
    elif (v == "errUnhandledSolutionStatus"):
      return 6010
    elif (v == "wrnOpenParamFile"):
      return 50
    elif (v == "errInvalidVarName"):
      return 1077
    elif (v == "ok"):
      return 0
    elif (v == "errSenSolutionStatus"):
      return 3057
    elif (v == "errSizeLicenseCon"):
      return 1010
    elif (v == "errReadFormat"):
      return 1090
    elif (v == "wrnLargeCj"):
      return 57
    elif (v == "errLicenseExpired"):
      return 1001
    elif (v == "errArgumentDimension"):
      return 1201
    elif (v == "errNanInBlc"):
      return 1461
    elif (v == "errNanInBlx"):
      return 1471
    elif (v == "errSymMatInvalidRowIndex"):
      return 3940
    elif (v == "errNonUniqueArray"):
      return 5000
    elif (v == "errInvalidFileFormatForSymMat"):
      return 4000
    elif (v == "errMpsMulConName"):
      return 1112
    elif (v == "errLicenseServer"):
      return 1015
    elif (v == "wrnTooFewBasisVars"):
      return 400
    elif (v == "errMpsInvBoundKey"):
      return 1108
    elif (v == "errThreadCreate"):
      return 1048
    elif (v == "errInvalidMaxNum"):
      return 1247
    elif (v == "errInvalidIomode"):
      return 1801
    elif (v == "errApiArrayTooSmall"):
      return 3001
    elif (v == "errConeSize"):
      return 1301
    elif (v == "errUserFuncRet"):
      return 1430
    elif (v == "errNanInAij"):
      return 1473
    elif (v == "errMpsConeType"):
      return 1117
    elif (v == "errParamIsTooLarge"):
      return 1215
    elif (v == "wrnPresolveOutofspace"):
      return 802
    elif (v == "errSizeLicenseIntvar"):
      return 1012
    elif (v == "errNoOptimizerVarType"):
      return 1552
    elif (v == "errGlobalInvConicProblem"):
      return 1503
    elif (v == "errMioNoOptimizer"):
      return 1551
    elif (v == "errArgumentPermArray"):
      return 1299
    elif (v == "errInvalidFileFormatForCones"):
      return 4005
    elif (v == "errObjQNotPsd"):
      return 1295
    elif (v == "errInternal"):
      return 3000
    elif (v == "errLpInvalidVarName"):
      return 1154
    elif (v == "errLpIncompatible"):
      return 1150
    elif (v == "errNoSolutionInCallback"):
      return 2500
    elif (v == "errInfLintIndex"):
      return 1225
    elif (v == "wrnTooManyBasisVars"):
      return 405
    elif (v == "errSpaceNoInfo"):
      return 1081
    elif (v == "wrnNzInUprTri"):
      return 200
    elif (v == "errInvQconSubi"):
      return 1405
    elif (v == "errInvQconSubk"):
      return 1404
    elif (v == "errInvQconSubj"):
      return 1406
    elif (v == "errArgumentType"):
      return 1198
    elif (v == "errEndOfFile"):
      return 1059
    elif (v == "errNonlinearEquality"):
      return 1290
    elif (v == "errNrArguments"):
      return 1199
    elif (v == "errConQNotPsd"):
      return 1293
    elif (v == "errInvalidConeName"):
      return 1078
    elif (v == "errInvalidConName"):
      return 1076
    elif (v == "errNonlinearRanged"):
      return 1292
    elif (v == "errWriteOpfInvalidVarName"):
      return 1156
    elif (v == "errSenFormat"):
      return 3050
    elif (v == "errNonconvex"):
      return 1291
    elif (v == "errUnbStepSize"):
      return 3100
    elif (v == "errMpsUndefVarName"):
      return 1106
    elif (v == "errInvalidFileName"):
      return 1056
    elif (v == "errFileWrite"):
      return 1054
    elif (v == "errMbtIncompatible"):
      return 2550
    elif (v == "errCannotHandleNl"):
      return 2506
    elif (v == "errNoBasisSol"):
      return 1600
    elif (v == "errOrdInvalid"):
      return 1131
    elif (v == "errApiCbConnect"):
      return 3002
    elif (v == "errObjQNotNsd"):
      return 1296
    elif (v == "errUnknown"):
      return 1050
    elif (v == "errInfType"):
      return 1232
    elif (v == "errLinkFileDll"):
      return 1040
    elif (v == "wrnDuplicateVariableNames"):
      return 851
    elif (v == "errParamNameDou"):
      return 1206
    elif (v == "wrnDuplicateBarvariableNames"):
      return 852
    elif (v == "errNoBarsForSolution"):
      return 3916
    elif (v == "errThreadMutexLock"):
      return 1046
    elif (v == "errNonlinearFunctionsNotAllowed"):
      return 1428
    elif (v == "errLpFreeConstraint"):
      return 1155
    elif (v == "errLicenseInvalidHostid"):
      return 1025
    elif (v == "errInvConeType"):
      return 1272
    elif (v == "errInfIntName"):
      return 1231
    elif (v == "errApiInternal"):
      return 3999
    elif (v == "errSenIndexRange"):
      return 3052
    elif (v == "wrnParamNameDou"):
      return 510
    elif (v == "errInvQobjSubi"):
      return 1401
    elif (v == "errInvQobjSubj"):
      return 1402
    elif (v == "trmUserCallback"):
      return 10007
    elif (v == "errArgumentLenneq"):
      return 1197
    elif (v == "errInArgument"):
      return 1200
    elif (v == "errMaxnumvar"):
      return 1241
    elif (v == "errMpsInvField"):
      return 1101
    elif (v == "errAdInvalidOperand"):
      return 3104
    elif (v == "errOpfFormat"):
      return 1168
    elif (v == "wrnAnaLargeBounds"):
      return 900
    elif (v == "errCannotCloneNl"):
      return 2505
    elif (v == "errSymMatNotLowerTringular"):
      return 3942
    elif (v == "errMpsMulCsec"):
      return 1116
    elif (v == "errUserFuncRetData"):
      return 1431
    elif (v == "errInvConicProblem"):
      return 1502
    elif (v == "errInvAptre"):
      return 1253
    elif (v == "errBasisFactor"):
      return 1610
    elif (v == "errInvalidWchar"):
      return 2901
    elif (v == "wrnRquadConesWithRootFixedAtZero"):
      return 931
    elif (v == "errSizeLicense"):
      return 1005
    elif (v == "errNanInC"):
      return 1470
    elif (v == "errLpInvalidConName"):
      return 1171
    elif (v == "errHugeAij"):
      return 1380
    elif (v == "errAdMissingOperand"):
      return 3105
    elif (v == "errDuplicateConeNames"):
      return 4503
    elif (v == "errMbtInvalid"):
      return 2551
    elif (v == "wrnConstructNoSolItg"):
      return 810
    elif (v == "errObjectiveRange"):
      return 1260
    elif (v == "errMpsTabInField3"):
      return 1126
    elif (v == "errInfDouName"):
      return 1230
    elif (v == "errNegativeAppend"):
      return 1264
    elif (v == "errInvSk"):
      return 1270
    elif (v == "errParamNameInt"):
      return 1207
    elif (v == "errBasis"):
      return 1266
    elif (v == "errMaxnumbarvar"):
      return 1242
    elif (v == "wrnAnaEmptyCols"):
      return 902
    elif (v == "trmInternal"):
      return 10030
    elif (v == "errInvVarType"):
      return 1258
    elif (v == "errOpfNewVariable"):
      return 1169
    elif (v == "errFlexlm"):
      return 1014
    elif (v == "errLpWriteGecoProblem"):
      return 1164
    elif (v == "trmInternalStop"):
      return 10031
    elif (v == "wrnParamNameInt"):
      return 511
    elif (v == "errConeRepVar"):
      return 1303
    elif (v == "errInvProblem"):
      return 1500
    elif (v == "wrnNoDualizer"):
      return 950
    elif (v == "errMpsMulQobj"):
      return 1114
    elif (v == "wrnParamIgnoredCmio"):
      return 516
    elif (v == "errThreadMutexUnlock"):
      return 1047
    elif (v == "errInvQconVal"):
      return 1407
    elif (v == "errLuMaxNumTries"):
      return 2800
    elif (v == "wrnDroppedNzQobj"):
      return 201
    elif (v == "errBarVarDim"):
      return 3920
    elif (v == "trmMioNearRelGap"):
      return 10003
    elif (v == "errSenInvalidRegexp"):
      return 3056
    elif (v == "errLicenseVersion"):
      return 1002
    elif (v == "errSymMatInvalidValue"):
      return 3943
    elif (v == "errDataFileExt"):
      return 1055
    elif (v == "wrnLpDropVariable"):
      return 85
    elif (v == "errInfDouIndex"):
      return 1219
    elif (v == "errFactor"):
      return 1650
    elif (v == "errInvalidBranchPriority"):
      return 3201
    elif (v == "wrnParamNameStr"):
      return 512
    elif (v == "errMaxnumcon"):
      return 1240
    elif (v == "errLicenseFeature"):
      return 1018
    elif (v == "errReadLpNonexistingName"):
      return 1162
    elif (v == "errMpsNullVarName"):
      return 1104
    elif (v == "errMioInternal"):
      return 5010
    elif (v == "errLicenseNoServerSupport"):
      return 1027
    elif (v == "wrnSparMaxLen"):
      return 66
    elif (v == "errLicenseNoServerLine"):
      return 1028
    elif (v == "errConeIndex"):
      return 1300
    elif (v == "errProItem"):
      return 1281
    elif (v == "errQconSubiTooSmall"):
      return 1408
    elif (v == "trmNumMaxNumIntSolutions"):
      return 10015
    elif (v == "errMpsTabInField2"):
      return 1125
    elif (v == "wrnMioInfeasibleFinal"):
      return 270
    elif (v == "errNoSnxForBasSol"):
      return 2953
    elif (v == "errMpsTabInField5"):
      return 1127
    elif (v == "wrnWriteDiscardedCfix"):
      return 804
    elif (v == "errInternalTestFailed"):
      return 3500
    elif (v == "errFileOpen"):
      return 1052
    elif (v == "wrnIgnoreInteger"):
      return 250
    elif (v == "errInvalidTask"):
      return 1064
    elif (v == "errDuplicateConstraintNames"):
      return 4500
    elif (v == "trmNumericalProblem"):
      return 10025
    elif (v == "errApiFatalError"):
      return 3005
    elif (v == "errInvOptimizer"):
      return 1550
    elif (v == "errRemoveConeVariable"):
      return 1310
    elif (v == "errSolFileInvalidNumber"):
      return 1350
    elif (v == "errFileRead"):
      return 1053
    elif (v == "wrnSolFilter"):
      return 300
    elif (v == "errMpsNoObjective"):
      return 1110
    elif (v == "errConeOverlap"):
      return 1302
    elif (v == "errInvalidStream"):
      return 1062
    elif (v == "errInvalidAmplStub"):
      return 3700
    elif (v == "wrnLargeConFx"):
      return 54
    elif (v == "wrnAnaCZero"):
      return 901
    elif (v == "errTaskInvalid"):
      return 2561
    elif (v == "errMpsInvConKey"):
      return 1107
    elif (v == "errNoDualInfeasCer"):
      return 2001
    elif (v == "errFeasrepairInconsistentBound"):
      return 1702
    elif (v == "errInvalidBranchDirection"):
      return 3200
    elif (v == "errInfiniteBound"):
      return 1400
    elif (v == "errInvalidIdx"):
      return 1246
    elif (v == "errIdenticalTasks"):
      return 3101
    elif (v == "errWriteMpsInvalidName"):
      return 1153
    elif (v == "errInvalidWhichsol"):
      return 1228
    elif (v == "wrnLicenseServer"):
      return 501
    elif (v == "errMpsInvalidObjsense"):
      return 1122
    elif (v == "errInvSkStr"):
      return 1269
    elif (v == "errDupName"):
      return 1071
    elif (v == "wrnLargeBound"):
      return 51
    elif (v == "errOptimizerLicense"):
      return 1013
    elif (v == "errFileLicense"):
      return 1007
    elif (v == "errSolitem"):
      return 1237
    elif (v == "errPostsolve"):
      return 1580
    elif (v == "errPlatformNotLicensed"):
      return 1019
    elif (v == "errSenBoundInvalidLo"):
      return 3054
    elif (v == "errMpsSplittedVar"):
      return 1111
    elif (v == "errThreadCondInit"):
      return 1049
    elif (v == "errInvalidProblemType"):
      return 6000
    elif (v == "errWhichitemNotAllowed"):
      return 1238
    elif (v == "errNewerDll"):
      return 1036
    elif (v == "errMaxLenIsTooSmall"):
      return 1289
    elif (v == "wrnEmptyName"):
      return 502
    elif (v == "errProbLicense"):
      return 1006
    elif (v == "wrnAnaCloseBounds"):
      return 903
    elif (v == "errArgIsTooSmall"):
      return 1226
    elif (v == "errWriteLpNonUniqueName"):
      return 1161
    elif (v == "errMpsInvSecName"):
      return 1109
    elif (v == "errLpFileFormat"):
      return 1157
    elif (v == "errLicenseCannotConnect"):
      return 1021
    elif (v == "errDuplicateVariableNames"):
      return 4501
    elif (v == "errInvBk"):
      return 1255
    elif (v == "errNanInDoubleData"):
      return 1450
    elif (v == "errNameMaxLen"):
      return 1750
    elif (v == "errOrdInvalidBranchDir"):
      return 1130
    elif (v == "errWritingFile"):
      return 1166
    elif (v == "errMpsUndefConName"):
      return 1105
    elif (v == "errArgumentIsTooLarge"):
      return 5005
    elif (v == "trmMaxIterations"):
      return 10000
    elif (v == "wrnSolFileIgnoredVar"):
      return 352
    elif (v == "errIndexIsTooSmall"):
      return 1203
    elif (v == "trmMioNearAbsGap"):
      return 10004
    elif (v == "errInvalidAccmode"):
      return 2520
    elif (v == "errLasti"):
      return 1286
    elif (v == "errNoInitEnv"):
      return 1063
    elif (v == "errUndefSolution"):
      return 1265
    elif (v == "errLastj"):
      return 1288
    elif (v == "wrnParamStrValue"):
      return 515
    elif (v == "errInfLintName"):
      return 1234
    elif (v == "errMissingLicenseFile"):
      return 1008
    elif (v == "errSenNumerical"):
      return 3058
    elif (v == "errNoDualForItgSol"):
      return 2950
    elif (v == "errOverflow"):
      return 1590
    elif (v == "errFirsti"):
      return 1285
    elif (v == "errMixedProblem"):
      return 1501
    elif (v == "errSymMatInvalidColIndex"):
      return 3941
    elif (v == "errNanInBux"):
      return 1472
    elif (v == "errLicenseMoseklmDaemon"):
      return 1017
    elif (v == "errConeTypeStr"):
      return 1306
    elif (v == "errNanInBuc"):
      return 1462
    elif (v == "errParamIndex"):
      return 1210
    elif (v == "errLicense"):
      return 1000
    elif (v == "errInvalidBarvarName"):
      return 1079
    elif (v == "errIndex"):
      return 1235
    elif (v == "errFirstj"):
      return 1287
    elif (v == "errSenUnhandledProblemType"):
      return 3080
    elif (v == "errSizeLicenseNumcores"):
      return 3900
    elif (v == "errNoBarxForSolution"):
      return 3915
    elif (v == "errInvNumi"):
      return 2503
    elif (v == "errInvNumj"):
      return 2504
    elif (v == "errAdInvalidOperator"):
      return 3103
    elif (v == "trmMioNumBranches"):
      return 10009
    elif (v == "errLpDupSlackName"):
      return 1152
    elif (v == "errWriteLpFormat"):
      return 1158
    elif (v == "errMpsNullConName"):
      return 1103
    elif (v == "wrnEliminatorSpace"):
      return 801
    elif (v == "wrnZerosInSparseCol"):
      return 710
    elif (v == "wrnIncompleteLinearDependencyCheck"):
      return 800
    elif (v == "errInvalidSymMatDim"):
      return 3950
    elif (v == "errInvalidSurplus"):
      return 1275
    elif (v == "errMaxnumqnz"):
      return 1243
    elif (v == "errInvalidUtf8"):
      return 2900
    elif (v == "errInvalidObjName"):
      return 1075
    elif (v == "errParamName"):
      return 1205
    elif (v == "errAdInvalidCodelist"):
      return 3102
    elif (v == "errConcurrentOptimizer"):
      return 3059
    elif (v == "wrnLargeAij"):
      return 62
    elif (v == "errMpsFile"):
      return 1100
    elif (v == "wrnNoGlobalOptimizer"):
      return 251
    elif (v == "errFeasrepairSolvingRelaxed"):
      return 1701
    elif (v == "trmMaxNumSetbacks"):
      return 10020
    elif (v == "errSizeLicenseVar"):
      return 1011
    elif (v == "wrnMpsSplitBouVector"):
      return 72
    elif (v == "errInt64ToInt32Cast"):
      return 3800
    elif (v == "errAdMissingReturn"):
      return 3106
    elif (v == "wrnLargeUpBound"):
      return 53
    elif (v == "errInfeasUndefined"):
      return 3910
    elif (v == "wrnNoNonlinearFunctionWrite"):
      return 450
    elif (v == "errQconUpperTriangle"):
      return 1417
    elif (v == "errMpsInvSecOrder"):
      return 1115
    elif (v == "wrnConstructSolutionInfeas"):
      return 805
    elif (v == "errConQNotNsd"):
      return 1294
    elif (v == "errFixedBoundValues"):
      return 1425
    elif (v == "wrnMpsSplitRhsVector"):
      return 70
    elif (v == "errYIsUndefined"):
      return 1449
    elif (v == "errLicenseCannotAllocate"):
      return 1020
    elif (v == "errMioNotLoaded"):
      return 1553
    elif (v == "errTooSmallMaxnumanz"):
      return 1252
    elif (v == "errTaskIncompatible"):
      return 2560
    elif (v == "errInvalidObjectiveSense"):
      return 1445
    elif (v == "wrnDuplicateConeNames"):
      return 853
    elif (v == "wrnNameMaxLen"):
      return 65
    elif (v == "wrnWriteChangedNames"):
      return 803
    elif (v == "errLpFormat"):
      return 1160
    elif (v == "errInvalidFileFormatForGeneralNl"):
      return 4010
    elif (v == "errMpsConeOverlap"):
      return 1118
    elif (v == "trmMioNumRelaxs"):
      return 10008
    elif (v == "errInvalidSolFileName"):
      return 1057
    elif (v == "errUserNloEval"):
      return 1433
    elif (v == "errOlderDll"):
      return 1035
    elif (v == "errMpsConeRepeat"):
      return 1119
    elif (v == "errInvQobjVal"):
      return 1403
    elif (v == "wrnMpsSplitRanVector"):
      return 71
    elif (v == "errSpaceLeaking"):
      return 1080
    elif (v == "errXmlInvalidProblemType"):
      return 3600
    elif (v == "errReadLpMissingEndTag"):
      return 1159
    elif (v == "trmMaxTime"):
      return 10001
    elif (v == "wrnQuadConesWithRootFixedAtZero"):
      return 930
    elif (v == "errWhichsol"):
      return 1236
    elif (v == "errConeOverlapAppend"):
      return 1307
    elif (v == "errBasisSingular"):
      return 1615
    elif (v == "wrnTooManyThreadsConcurrent"):
      return 750
    elif (v == "errQconSubiTooLarge"):
      return 1409
    elif (v == "errSenUndefName"):
      return 3051
    elif (v == "wrnLpOldQuadFormat"):
      return 80
    elif (v == "errMpsInvMarker"):
      return 1102
    elif (v == "errNegativeSurplus"):
      return 1263
    elif (v == "errInvBkx"):
      return 1257
    elif (v == "errMpsInvalidObjName"):
      return 1128
    elif (v == "errIndexArrIsTooLarge"):
      return 1222
    elif (v == "errNoDualInfoForItgSol"):
      return 3300
    elif (v == "trmObjectiveRange"):
      return 10002
    elif (v == "wrnUndefSolFileName"):
      return 350
    elif (v == "errInvBkc"):
      return 1256
    elif (v == "errBlankName"):
      return 1070
    elif (v == "errFirst"):
      return 1261
    elif (v == "errHugeC"):
      return 1375
    elif (v == "errUndefinedObjectiveSense"):
      return 1446
    elif (v == "errTooSmallMaxNumNz"):
      return 1245
    elif (v == "errInvMarki"):
      return 2501
    elif (v == "errInvMarkj"):
      return 2502
    elif (v == "errNameIsNull"):
      return 1760
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mionodeseltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1226:10-1235:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mionodeseltype_value(basestring)")
  def __string_1to_1mionodeseltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "pseudo"):
      return 5
    elif (v == "hybrid"):
      return 4
    elif (v == "free"):
      return 0
    elif (v == "worst"):
      return 3
    elif (v == "best"):
      return 2
    elif (v == "first"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1onoffkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1237:10-1242:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_onoffkey_value(basestring)")
  def __string_1to_1onoffkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simdegen_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1244:10-1252:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simdegen_value(basestring)")
  def __string_1to_1simdegen_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 0
    elif (v == "moderate"):
      return 3
    elif (v == "minimum"):
      return 4
    elif (v == "aggressive"):
      return 2
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dataformat_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1254:10-1264:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dataformat_value(basestring)")
  def __string_1to_1dataformat_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "xml"):
      return 4
    elif (v == "task"):
      return 6
    elif (v == "extension"):
      return 0
    elif (v == "freeMps"):
      return 5
    elif (v == "lp"):
      return 2
    elif (v == "op"):
      return 3
    elif (v == "mps"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1orderingtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1266:10-1275:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_orderingtype_value(basestring)")
  def __string_1to_1orderingtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 5
    elif (v == "forceGraphpar"):
      return 4
    elif (v == "appminloc"):
      return 1
    elif (v == "tryGraphpar"):
      return 3
    elif (v == "free"):
      return 0
    elif (v == "experimental"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1problemtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1277:10-1286:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_problemtype_value(basestring)")
  def __string_1to_1problemtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "qcqo"):
      return 2
    elif (v == "lo"):
      return 0
    elif (v == "conic"):
      return 4
    elif (v == "geco"):
      return 3
    elif (v == "mixed"):
      return 5
    elif (v == "qo"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1inftype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1288:10-1294:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_inftype_value(basestring)")
  def __string_1to_1inftype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "douType"):
      return 0
    elif (v == "lintType"):
      return 2
    elif (v == "intType"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1296:10-1366:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dparam_value(basestring)")
  def __string_1to_1dparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "lowerObjCutFiniteTrh"):
      return 39
    elif (v == "mioMaxTime"):
      return 42
    elif (v == "basisTolS"):
      return 2
    elif (v == "presolveTolS"):
      return 60
    elif (v == "upperObjCut"):
      return 65
    elif (v == "intpntCoTolDfeas"):
      return 15
    elif (v == "dataTolAijLarge"):
      return 7
    elif (v == "mioTolAbsGap"):
      return 48
    elif (v == "upperObjCutFiniteTrh"):
      return 66
    elif (v == "mioTolAbsRelaxInt"):
      return 49
    elif (v == "nonconvexTolOpt"):
      return 55
    elif (v == "nonconvexTolFeas"):
      return 54
    elif (v == "simplexAbsTolPiv"):
      return 64
    elif (v == "mioHeuristicTime"):
      return 41
    elif (v == "checkConvexityRelTol"):
      return 4
    elif (v == "presolveTolX"):
      return 61
    elif (v == "intpntNlTolMuRed"):
      return 23
    elif (v == "mioNearTolRelGap"):
      return 45
    elif (v == "presolveTolRelLindep"):
      return 59
    elif (v == "dataTolAij"):
      return 5
    elif (v == "feasrepairTol"):
      return 14
    elif (v == "intpntTolDsafe"):
      return 29
    elif (v == "mioTolFeas"):
      return 50
    elif (v == "intpntTolInfeas"):
      return 30
    elif (v == "intpntNlTolNearRel"):
      return 24
    elif (v == "optimizerMaxTime"):
      return 56
    elif (v == "dataTolX"):
      return 13
    elif (v == "anaSolInfeasTol"):
      return 0
    elif (v == "mioRelAddCutLimited"):
      return 46
    elif (v == "intpntTolMuRed"):
      return 31
    elif (v == "intpntCoTolMuRed"):
      return 17
    elif (v == "intpntCoTolRelGap"):
      return 20
    elif (v == "lowerObjCut"):
      return 38
    elif (v == "mioDisableTermTime"):
      return 40
    elif (v == "intpntTolRelStep"):
      return 36
    elif (v == "mioTolX"):
      return 53
    elif (v == "dataTolCHuge"):
      return 10
    elif (v == "simLuTolRelPiv"):
      return 63
    elif (v == "dataTolCjLarge"):
      return 11
    elif (v == "intpntNlTolRelStep"):
      return 27
    elif (v == "intpntTolStepSize"):
      return 37
    elif (v == "intpntTolPfeas"):
      return 33
    elif (v == "basisRelTolS"):
      return 1
    elif (v == "presolveTolAbsLindep"):
      return 57
    elif (v == "intpntCoTolInfeas"):
      return 16
    elif (v == "mioRelGapConst"):
      return 47
    elif (v == "presolveTolAij"):
      return 58
    elif (v == "mioMaxTimeAprxOpt"):
      return 43
    elif (v == "intpntTolPath"):
      return 32
    elif (v == "intpntNlMeritBal"):
      return 21
    elif (v == "basisTolX"):
      return 3
    elif (v == "intpntTolRelGap"):
      return 35
    elif (v == "dataTolAijHuge"):
      return 6
    elif (v == "dataTolBoundWrn"):
      return 9
    elif (v == "dataTolBoundInf"):
      return 8
    elif (v == "intpntTolPsafe"):
      return 34
    elif (v == "intpntCoTolNearRel"):
      return 18
    elif (v == "intpntNlTolPfeas"):
      return 25
    elif (v == "intpntNlTolDfeas"):
      return 22
    elif (v == "mioTolRelGap"):
      return 51
    elif (v == "intpntTolDfeas"):
      return 28
    elif (v == "mioNearTolAbsGap"):
      return 44
    elif (v == "mioTolRelRelaxInt"):
      return 52
    elif (v == "qcqoReformulateRelDropTol"):
      return 62
    elif (v == "dataTolQij"):
      return 12
    elif (v == "intpntNlTolRelGap"):
      return 26
    elif (v == "intpntCoTolPfeas"):
      return 19
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simdupvec_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1368:10-1374:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simdupvec_value(basestring)")
  def __string_1to_1simdupvec_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1compresstype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1376:10-1382:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_compresstype_value(basestring)")
  def __string_1to_1compresstype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "gzip"):
      return 2
    elif (v == "none"):
      return 0
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1nametype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1384:10-1390:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_nametype_value(basestring)")
  def __string_1to_1nametype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "gen"):
      return 0
    elif (v == "lp"):
      return 2
    elif (v == "mps"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mpsformat_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1392:10-1398:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mpsformat_value(basestring)")
  def __string_1to_1mpsformat_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "strict"):
      return 0
    elif (v == "relaxed"):
      return 1
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1variabletype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1400:10-1405:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_variabletype_value(basestring)")
  def __string_1to_1variabletype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "typeInt"):
      return 1
    elif (v == "typeCont"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1checkconvexitytype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1407:10-1413:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_checkconvexitytype_value(basestring)")
  def __string_1to_1checkconvexitytype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "simple"):
      return 1
    elif (v == "none"):
      return 0
    elif (v == "full"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1language_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1415:10-1420:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_language_value(basestring)")
  def __string_1to_1language_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "dan"):
      return 1
    elif (v == "eng"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1startpointtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1422:10-1429:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_startpointtype_value(basestring)")
  def __string_1to_1startpointtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "guess"):
      return 1
    elif (v == "satisfyBounds"):
      return 3
    elif (v == "constant"):
      return 2
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1soltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1431:10-1437:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_soltype_value(basestring)")
  def __string_1to_1soltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "itg"):
      return 2
    elif (v == "itr"):
      return 0
    elif (v == "bas"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1scalingmethod_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1439:10-1444:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_scalingmethod_value(basestring)")
  def __string_1to_1scalingmethod_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "pow2"):
      return 0
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1value_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1446:10-1451:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_value_value(basestring)")
  def __string_1to_1value_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "maxStrLen"):
      return 1024
    elif (v == "licenseBufferLength"):
      return 20
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1stakey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1453:10-1463:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_stakey_value(basestring)")
  def __string_1to_1stakey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "supbas"):
      return 2
    elif (v == "bas"):
      return 1
    elif (v == "fix"):
      return 5
    elif (v == "low"):
      return 3
    elif (v == "inf"):
      return 6
    elif (v == "unk"):
      return 0
    elif (v == "upr"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simreform_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1465:10-1472:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simreform_value(basestring)")
  def __string_1to_1simreform_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "aggressive"):
      return 3
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1474:10-1574:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iinfitem_value(basestring)")
  def __string_1to_1iinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "rdNumintvar"):
      return 54
    elif (v == "mioNumGcdCuts"):
      return 32
    elif (v == "rdNumbarvar"):
      return 51
    elif (v == "mioNumDisaggCuts"):
      return 30
    elif (v == "solBasSolsta"):
      return 87
    elif (v == "stoNumATransposes"):
      return 96
    elif (v == "simSolveDual"):
      return 85
    elif (v == "mioNumcon"):
      return 42
    elif (v == "optNumvar"):
      return 49
    elif (v == "simNumvar"):
      return 74
    elif (v == "stoNumARealloc"):
      return 95
    elif (v == "mioNumLatticeCuts"):
      return 37
    elif (v == "simNetworkPrimalDegIter"):
      return 68
    elif (v == "rdNumq"):
      return 55
    elif (v == "mioNumFlowCoverCuts"):
      return 31
    elif (v == "mioNumBasisCuts"):
      return 24
    elif (v == "anaProNumCon"):
      return 0
    elif (v == "anaProNumVarInt"):
      return 11
    elif (v == "simNetworkDualInfIter"):
      return 66
    elif (v == "anaProNumVarCont"):
      return 8
    elif (v == "simDualIter"):
      return 62
    elif (v == "simDualDegIter"):
      return 58
    elif (v == "intpntIter"):
      return 17
    elif (v == "simNumcon"):
      return 73
    elif (v == "simPrimalDualIter"):
      return 80
    elif (v == "anaProNumConUp"):
      return 5
    elif (v == "mioNumKnapsurCoverCuts"):
      return 36
    elif (v == "simPrimalDualHotstart"):
      return 77
    elif (v == "intpntSolveDual"):
      return 19
    elif (v == "simNetworkDualHotstart"):
      return 64
    elif (v == "optimizeResponse"):
      return 50
    elif (v == "mioNumGomoryCuts"):
      return 33
    elif (v == "solItrProsta"):
      return 92
    elif (v == "mioNumCoefRedcCuts"):
      return 28
    elif (v == "rdProtype"):
      return 57
    elif (v == "mioNumCardgubCuts"):
      return 26
    elif (v == "solItrSolsta"):
      return 93
    elif (v == "mioNumLiftCuts"):
      return 38
    elif (v == "anaProNumConFr"):
      return 2
    elif (v == "simPrimalDualHotstartLu"):
      return 78
    elif (v == "mioNumint"):
      return 43
    elif (v == "solItgSolsta"):
      return 91
    elif (v == "simDualInfIter"):
      return 61
    elif (v == "mioNumvar"):
      return 44
    elif (v == "mioConstructSolution"):
      return 21
    elif (v == "anaProNumVar"):
      return 6
    elif (v == "stoNumACacheFlushes"):
      return 94
    elif (v == "solIntProsta"):
      return 88
    elif (v == "simNetworkDualDegIter"):
      return 63
    elif (v == "solIntSolsta"):
      return 89
    elif (v == "rdNumvar"):
      return 56
    elif (v == "simPrimalDualDegIter"):
      return 76
    elif (v == "anaProNumVarLo"):
      return 12
    elif (v == "solBasProsta"):
      return 86
    elif (v == "simNetworkPrimalIter"):
      return 72
    elif (v == "anaProNumConLo"):
      return 3
    elif (v == "mioNumContraCuts"):
      return 29
    elif (v == "simNetworkDualHotstartLu"):
      return 65
    elif (v == "simNetworkPrimalInfIter"):
      return 71
    elif (v == "simPrimalHotstart"):
      return 81
    elif (v == "mioNumBranch"):
      return 25
    elif (v == "mioNumGubCoverCuts"):
      return 34
    elif (v == "mioNumRelax"):
      return 41
    elif (v == "mioNumObjCuts"):
      return 39
    elif (v == "mioNumIntSolutions"):
      return 35
    elif (v == "simPrimalHotstartLu"):
      return 82
    elif (v == "mioConstructNumRoundings"):
      return 20
    elif (v == "anaProNumConEq"):
      return 1
    elif (v == "anaProNumVarRa"):
      return 13
    elif (v == "mioObjBoundDefined"):
      return 45
    elif (v == "simPrimalInfIter"):
      return 83
    elif (v == "rdNumcon"):
      return 52
    elif (v == "rdNumcone"):
      return 53
    elif (v == "anaProNumVarFr"):
      return 10
    elif (v == "mioNumActiveNodes"):
      return 23
    elif (v == "anaProNumVarBin"):
      return 7
    elif (v == "simNetworkPrimalHotstartLu"):
      return 70
    elif (v == "simPrimalIter"):
      return 84
    elif (v == "simDualHotstart"):
      return 59
    elif (v == "mioInitialSolution"):
      return 22
    elif (v == "intpntNumThreads"):
      return 18
    elif (v == "simDualHotstartLu"):
      return 60
    elif (v == "anaProNumVarUp"):
      return 14
    elif (v == "simNetworkDualIter"):
      return 67
    elif (v == "mioNumCliqueCuts"):
      return 27
    elif (v == "anaProNumVarEq"):
      return 9
    elif (v == "intpntFactorDimDense"):
      return 16
    elif (v == "concurrentFastestOptimizer"):
      return 15
    elif (v == "mioUserObjCut"):
      return 47
    elif (v == "simNetworkPrimalHotstart"):
      return 69
    elif (v == "simPrimalDualInfIter"):
      return 79
    elif (v == "anaProNumConRa"):
      return 4
    elif (v == "mioNumPlanLocCuts"):
      return 40
    elif (v == "mioTotalNumCuts"):
      return 46
    elif (v == "optNumcon"):
      return 48
    elif (v == "solItgProsta"):
      return 90
    elif (v == "simPrimalDegIter"):
      return 75
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1xmlwriteroutputtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1576:10-1581:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_xmlwriteroutputtype_value(basestring)")
  def __string_1to_1xmlwriteroutputtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "col"):
      return 1
    elif (v == "row"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1optimizertype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1583:10-1597:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_optimizertype_value(basestring)")
  def __string_1to_1optimizertype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "intpnt"):
      return 1
    elif (v == "concurrent"):
      return 10
    elif (v == "mixedIntConic"):
      return 8
    elif (v == "mixedInt"):
      return 9
    elif (v == "dualSimplex"):
      return 4
    elif (v == "free"):
      return 0
    elif (v == "primalDualSimplex"):
      return 5
    elif (v == "conic"):
      return 2
    elif (v == "primalSimplex"):
      return 3
    elif (v == "networkPrimalSimplex"):
      return 7
    elif (v == "freeSimplex"):
      return 6
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1presolvemode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1599:10-1605:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_presolvemode_value(basestring)")
  def __string_1to_1presolvemode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1dinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1607:10-1684:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_dinf_value(basestring)")
  def __string_1to_1internal_1dinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "biPrimalFeas"):
      return 8
    elif (v == "presolveDupvarTime"):
      return 58
    elif (v == "intpntFactorBvTime"):
      return 18
    elif (v == "biPrimalObj"):
      return 9
    elif (v == "biDualDone"):
      return 2
    elif (v == "intpntFactorBvtbvTime"):
      return 20
    elif (v == "presolveSubDomvarTime"):
      return 61
    elif (v == "intpntFactorMlOrderSparseLFlops"):
      return 30
    elif (v == "presolveSetupTime"):
      return 60
    elif (v == "biFactorWork"):
      return 6
    elif (v == "intpntFactorHatSchurFlops"):
      return 24
    elif (v == "intpntGfeas"):
      return 41
    elif (v == "intpntFactorHatSchurPushTime"):
      return 28
    elif (v == "biPrimalDone"):
      return 7
    elif (v == "intpntFactorDenseLFlops"):
      return 21
    elif (v == "simPrimalObj"):
      return 73
    elif (v == "nonconvexPinfe"):
      return 52
    elif (v == "intpntFactorSparseLTime"):
      return 38
    elif (v == "intpntCompGap"):
      return 12
    elif (v == "nonconvexDobj"):
      return 51
    elif (v == "simNetworkDualObj"):
      return 69
    elif (v == "simNetworkPrimalObj"):
      return 71
    elif (v == "presolveSubRelaxTime"):
      return 62
    elif (v == "sensitivityDualTime"):
      return 64
    elif (v == "biCrashTime"):
      return 1
    elif (v == "intpntFactorHatSchurPushFlops"):
      return 27
    elif (v == "sensitivityPrimalTime"):
      return 65
    elif (v == "intpntFactorBarSchurFlops"):
      return 14
    elif (v == "presolveAcoltTime"):
      return 55
    elif (v == "intpntFactorSetupDetectDenseTime"):
      return 33
    elif (v == "biDualFeas"):
      return 3
    elif (v == "presolveDupconTime"):
      return 57
    elif (v == "intpntFactorHatSchurPullTime"):
      return 26
    elif (v == "concurrentWinningTime"):
      return 10
    elif (v == "intpntInitIterTime"):
      return 43
    elif (v == "intpntFactorSchurFlops"):
      return 31
    elif (v == "nonconvexDinfe"):
      return 50
    elif (v == "primalSimplexInftime"):
      return 63
    elif (v == "intpntInitSearchTime"):
      return 44
    elif (v == "intpntFactorSchurTime"):
      return 32
    elif (v == "intpntFactorBarSchurTime"):
      return 16
    elif (v == "intpntFactorBarSchurDeTabTime"):
      return 13
    elif (v == "intpntFactorBvFlops"):
      return 17
    elif (v == "intpntFactorBvtbvFlops"):
      return 19
    elif (v == "intpntGpOrderSavedFlops"):
      return 42
    elif (v == "intpntFactorTime"):
      return 39
    elif (v == "intpntMu"):
      return 45
    elif (v == "intpntFormSearchTime"):
      return 40
    elif (v == "simDualFeas"):
      return 66
    elif (v == "presolveCheckproTime"):
      return 56
    elif (v == "simPrimalFeas"):
      return 72
    elif (v == "biFactorTime"):
      return 5
    elif (v == "intpntFactorSparseLFlops"):
      return 37
    elif (v == "intpntSolveTime"):
      return 48
    elif (v == "intpntFactorHatSchurPullFlops"):
      return 25
    elif (v == "intpntFactorSetupMlOrderTime"):
      return 35
    elif (v == "biCrashLuTime"):
      return 0
    elif (v == "intpntUpdateTime"):
      return 49
    elif (v == "intpntSolveSparseLTime"):
      return 47
    elif (v == "intpntFactorDenseLTime"):
      return 22
    elif (v == "dualSimplexInftime"):
      return 11
    elif (v == "biDualObj"):
      return 4
    elif (v == "intpntFactorSetupGpOrderTime"):
      return 34
    elif (v == "simNetworkDualFeas"):
      return 68
    elif (v == "intpntFactorSetupTime"):
      return 36
    elif (v == "presolveFinalTime"):
      return 59
    elif (v == "simNetworkPrimalFeas"):
      return 70
    elif (v == "intpntFactorBarSchurSpTabTime"):
      return 15
    elif (v == "intpntSolveDenseLTime"):
      return 46
    elif (v == "simDualObj"):
      return 67
    elif (v == "intpntFactorHatSchurTime"):
      return 29
    elif (v == "nonconvexPobj"):
      return 53
    elif (v == "nonconvexTime"):
      return 54
    elif (v == "intpntFactorGpOrderSparseLFlops"):
      return 23
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1miocontsoltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1686:10-1693:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_miocontsoltype_value(basestring)")
  def __string_1to_1miocontsoltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "itg"):
      return 2
    elif (v == "none"):
      return 0
    elif (v == "root"):
      return 1
    elif (v == "itgRel"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SS(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(1696:9-3428:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,basestring)")
  def _setParameter_Omosek_fusion_Model_2SS(M,name,value):
    if   False:
      pass
    elif (name == "simStabilityPriority"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_STABILITY_PRIORITY",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_stability_priority)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_stability_priority)")
    elif (name == "simPrimalPhaseoneMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_phaseone_method)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_phaseone_method)")
    elif (name == "mioNodeOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_node_optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",v) )
    elif (name == "presolveLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_level)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_level)")
    elif (name == "logNonconvex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_NONCONVEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_nonconvex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_nonconvex)")
    elif (name == "mioMtUserCb"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_mt_user_cb)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_MT_USER_CB",v) )
    elif (name == "presolveUse"):
      v = ( Parameters.__string_1to_1presolvemode_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",v) )
    elif (name == "mioBranchPrioritiesUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_branch_priorities_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_PRIORITIES_USE",v) )
    elif (name == "mioCutLevelTree"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_TREE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_tree)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_tree)")
    elif (name == "logConcurrent"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CONCURRENT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_concurrent)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_concurrent)")
    elif (name == "intpntOrderMethod"):
      v = ( Parameters.__string_1to_1orderingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_order_method)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",v) )
    elif (name == "logInfeasAna"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_infeas_ana)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_infeas_ana)")
    elif (name == "simPrimalSelection"):
      v = ( Parameters.__string_1to_1simseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_selection)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",v) )
    elif (name == "simDualRestrictSelection"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_restrict_selection)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_restrict_selection)")
    elif (name == "logMioFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio_freq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio_freq)")
    elif (name == "mioRootOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_root_optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",v) )
    elif (name == "presolveElimFill"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIM_FILL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_elim_fill)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_elim_fill)")
    elif (name == "mioLocalBranchNumber"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_local_branch_number)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_local_branch_number)")
    elif (name == "warningLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_WARNING_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (warning_level)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (warning_level)")
    elif (name == "logBiFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi_freq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi_freq)")
    elif (name == "concurrentPriorityDualSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_dual_simplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_dual_simplex)")
    elif (name == "logPresolve"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_presolve)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_presolve)")
    elif (name == "intpntOffColTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_off_col_trh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_off_col_trh)")
    elif (name == "mioMode"):
      v = ( Parameters.__string_1to_1miomode_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_mode)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_MODE",v) )
    elif (name == "logSim"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim)")
    elif (name == "mtSpincount"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1000000000):
          ( M._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mt_spincount)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mt_spincount)")
    elif (name == "simScalingMethod"):
      v = ( Parameters.__string_1to_1scalingmethod_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_scaling_method)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",v) )
    elif (name == "logSimFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_freq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_freq)")
    elif (name == "presolveMaxNumReductions"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_max_num_reductions)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_max_num_reductions)")
    elif (name == "logFactor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FACTOR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_factor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_factor)")
    elif (name == "autoUpdateSolInfo"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (auto_update_sol_info)")
      ( M._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",v) )
    elif (name == "timingLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_TIMING_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (timing_level)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (timing_level)")
    elif (name == "logOrder"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_order)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_order)")
    elif (name == "mioCutLevelRoot"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_ROOT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_root)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_root)")
    elif (name == "biIgnoreNumError"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (bi_ignore_num_error)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",v) )
    elif (name == "mioNodeSelection"):
      v = ( Parameters.__string_1to_1mionodeseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_node_selection)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",v) )
    elif (name == "intpntMaxNumRefinementSteps"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_refinement_steps)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_refinement_steps)")
    elif (name == "logSimMinor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_minor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_minor)")
    elif (name == "simMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_iterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_iterations)")
    elif (name == "intpntMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_iterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_iterations)")
    elif (name == "cacheLicense"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (cache_license)")
      ( M._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",v) )
    elif (name == "logBi"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi)")
    elif (name == "intpntMaxNumCor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   ((- 1) <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_cor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_cor)")
    elif (name == "licenseDebug"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_debug)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",v) )
    elif (name == "licTrhExpiryWrn"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LIC_TRH_EXPIRY_WRN",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (lic_trh_expiry_wrn)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lic_trh_expiry_wrn)")
    elif (name == "presolveEliminatorMaxNumTries"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_eliminator_max_num_tries)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_eliminator_max_num_tries)")
    elif (name == "concurrentNumOptimizers"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_num_optimizers)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_num_optimizers)")
    elif (name == "simRefactorFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_refactor_freq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_refactor_freq)")
    elif (name == "simDualSelection"):
      v = ( Parameters.__string_1to_1simseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_selection)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",v) )
    elif (name == "simSolveForm"):
      v = ( Parameters.__string_1to_1solveform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_solve_form)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",v) )
    elif (name == "mioOptimizerMode"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1):
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_OPTIMIZER_MODE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_optimizer_mode)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_optimizer_mode)")
    elif (name == "logIntpnt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_intpnt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_intpnt)")
    elif (name == "logMio"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio)")
    elif (name == "simHotstart"):
      v = ( Parameters.__string_1to_1simhotstart_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_hotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",v) )
    elif (name == "logParam"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_PARAM",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_param)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_param)")
    elif (name == "simExploitDupvec"):
      v = ( Parameters.__string_1to_1simdupvec_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_exploit_dupvec)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",v) )
    elif (name == "mioBranchDir"):
      v = ( Parameters.__string_1to_1branchdir_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_branch_dir)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",v) )
    elif (name == "intpntFactorDebugLvl"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_debug_lvl)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_debug_lvl)")
    elif (name == "licensePauseTime"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1000000):
          ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (license_pause_time)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_pause_time)")
    elif (name == "mioPresolveAggregate"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_presolve_aggregate)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_AGGREGATE",v) )
    elif (name == "biMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (bi_max_iterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (bi_max_iterations)")
    elif (name == "simHotstartLu"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_hotstart_lu)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",v) )
    elif (name == "presolveLindepRelWorkTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_rel_work_trh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_rel_work_trh)")
    elif (name == "logFeasRepair"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FEAS_REPAIR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_feas_repair)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_feas_repair)")
    elif (name == "presolveLindepUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",v) )
    elif (name == "intpntHotstart"):
      v = ( Parameters.__string_1to_1intpnthotstart_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_hotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_HOTSTART",v) )
    elif (name == "mioContSol"):
      v = ( Parameters.__string_1to_1miocontsoltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cont_sol)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CONT_SOL",v) )
    elif (name == "intpntStartingPoint"):
      v = ( Parameters.__string_1to_1startpointtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_starting_point)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",v) )
    elif (name == "simMaxNumSetbacks"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_num_setbacks)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_num_setbacks)")
    elif (name == "concurrentPriorityPrimalSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_primal_simplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_primal_simplex)")
    elif (name == "logSimNetworkFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_NETWORK_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_network_freq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_network_freq)")
    elif (name == "intpntDiffStep"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_diff_step)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",v) )
    elif (name == "simScaling"):
      v = ( Parameters.__string_1to_1scalingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_scaling)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",v) )
    elif (name == "biIgnoreMaxIter"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (bi_ignore_max_iter)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",v) )
    elif (name == "presolveLindepAbsWorkTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_abs_work_trh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_abs_work_trh)")
    elif (name == "intpntSolveForm"):
      v = ( Parameters.__string_1to_1solveform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_solve_form)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",v) )
    elif (name == "simBasisFactorUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_basis_factor_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",v) )
    elif (name == "intpntRegularizationUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_regularization_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",v) )
    elif (name == "biCleanOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (bi_clean_optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",v) )
    elif (name == "mioPresolveProbing"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_presolve_probing)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_PROBING",v) )
    elif (name == "licenseAllowOveruse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_allow_overuse)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_ALLOW_OVERUSE",v) )
    elif (name == "infeasPreferPrimal"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (infeas_prefer_primal)")
      ( M._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",v) )
    elif (name == "logStorage"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_STORAGE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_storage)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_storage)")
    elif (name == "mioPresolveUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_presolve_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_USE",v) )
    elif (name == "intpntBasis"):
      v = ( Parameters.__string_1to_1basindtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_basis)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",v) )
    elif (name == "logCutSecondOpt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_cut_second_opt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_cut_second_opt)")
    elif (name == "mioMaxNumSolutions"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_solutions)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_solutions)")
    elif (name == "licenseWait"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_wait)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",v) )
    elif (name == "concurrentPriorityFreeSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_free_simplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_free_simplex)")
    elif (name == "logFile"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FILE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_file)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_file)")
    elif (name == "concurrentPriorityIntpnt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_INTPNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_intpnt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_intpnt)")
    elif (name == "simNonSingular"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_non_singular)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",v) )
    elif (name == "simDegen"):
      v = ( Parameters.__string_1to_1simdegen_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_degen)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",v) )
    elif (name == "presolveEliminatorUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_eliminator_use)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_USE",v) )
    elif (name == "allocAddQnz"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_ALLOC_ADD_QNZ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (alloc_add_qnz)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (alloc_add_qnz)")
    elif (name == "mioHotstart"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_hotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_HOTSTART",v) )
    elif (name == "logOptimizer"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_OPTIMIZER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_optimizer)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_optimizer)")
    elif (name == "mioMaxNumBranches"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_branches)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_branches)")
    elif (name == "simPrimalCrash"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_crash)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_crash)")
    elif (name == "mioConstructSol"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_construct_sol)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",v) )
    elif (name == "autoSortABeforeOpt"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (auto_sort_a_before_opt)")
      ( M._task_1put_1param_SI("MSK_IPAR_AUTO_SORT_A_BEFORE_OPT",v) )
    elif (name == "mioStrongBranch"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_STRONG_BRANCH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_strong_branch)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_strong_branch)")
    elif (name == "simDualPhaseoneMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_phaseone_method)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_phaseone_method)")
    elif (name == "simInteger"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_INTEGER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_integer)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_integer)")
    elif (name == "mioUseMultithreadedOptimizer"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_use_multithreaded_optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_USE_MULTITHREADED_OPTIMIZER",v) )
    elif (name == "simPrimalRestrictSelection"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_restrict_selection)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_restrict_selection)")
    elif (name == "optimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",v) )
    elif (name == "maxNumWarnings"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_MAX_NUM_WARNINGS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (max_num_warnings)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (max_num_warnings)")
    elif (name == "licenseSuppressExpireWrns"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_suppress_expire_wrns)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",v) )
    elif (name == "logExpand"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_expand)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_expand)")
    elif (name == "mioFeaspumpLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 3):
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_feaspump_level)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_feaspump_level)")
    elif (name == "logResponse"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_response)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_response)")
    elif (name == "log"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
    elif (name == "simSwitchOptimizer"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_switch_optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",v) )
    elif (name == "numThreads"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (num_threads)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (num_threads)")
    elif (name == "logCheckConvexity"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CHECK_CONVEXITY",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_check_convexity)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_check_convexity)")
    elif (name == "simDualCrash"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_crash)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_crash)")
    elif (name == "logHead"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_HEAD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log_head)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_head)")
    elif (name == "simReformulation"):
      v = ( Parameters.__string_1to_1simreform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_reformulation)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",v) )
    elif (name == "simSaveLu"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_save_lu)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",v) )
    elif (name == "intpntFactorMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_method)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_method)")
    elif (name == "mioMaxNumRelaxs"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_relaxs)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_relaxs)")
    elif (name == "solFilterKeepBasic"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (sol_filter_keep_basic)")
      ( M._task_1put_1param_SI("MSK_IPAR_SOL_FILTER_KEEP_BASIC",v) )
    elif (name == "mioHeuristicLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_level)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_level)")
    elif (name == "mioKeepBasis"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_keep_basis)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_KEEP_BASIS",v) )
    elif (name == "intpntScaling"):
      v = ( Parameters.__string_1to_1scalingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_scaling)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",v) )
    elif (name == "lowerObjCutFiniteTrh"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut_finite_trh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut_finite_trh)")
    elif (name == "mioMaxTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time)")
    elif (name == "basisTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_s)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_s)")
    elif (name == "presolveTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_s)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_s)")
    elif (name == "upperObjCut"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut)")
    elif (name == "intpntCoTolDfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_dfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_dfeas)")
    elif (name == "mioTolAbsGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_gap)")
    elif (name == "upperObjCutFiniteTrh"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut_finite_trh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut_finite_trh)")
    elif (name == "mioTolAbsRelaxInt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_relax_int)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_relax_int)")
    elif (name == "simplexAbsTolPiv"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-12 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simplex_abs_tol_piv)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplex_abs_tol_piv)")
    elif (name == "mioHeuristicTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_time)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_time)")
    elif (name == "presolveTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_x)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_x)")
    elif (name == "mioNearTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_rel_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_rel_gap)")
    elif (name == "presolveTolRelLindep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_rel_lindep)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_rel_lindep)")
    elif (name == "intpntTolDsafe"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-04 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dsafe)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dsafe)")
    elif (name == "mioTolFeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_feas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_feas)")
    elif (name == "intpntTolInfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_infeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_infeas)")
    elif (name == "optimizerMaxTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer_max_time)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer_max_time)")
    elif (name == "anaSolInfeasTol"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (ana_sol_infeas_tol)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (ana_sol_infeas_tol)")
    elif (name == "mioRelAddCutLimited"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 2.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_add_cut_limited)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_add_cut_limited)")
    elif (name == "intpntTolMuRed"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_mu_red)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_mu_red)")
    elif (name == "intpntCoTolMuRed"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_mu_red)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_mu_red)")
    elif (name == "intpntCoTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_rel_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_rel_gap)")
    elif (name == "lowerObjCut"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut)")
    elif (name == "mioDisableTermTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_disable_term_time)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_disable_term_time)")
    elif (name == "intpntTolRelStep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999990e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_step)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_step)")
    elif (name == "mioTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_x)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_x)")
    elif (name == "simLuTolRelPiv"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999990e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (sim_lu_tol_rel_piv)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_lu_tol_rel_piv)")
    elif (name == "intpntTolStepSize"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_step_size)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_step_size)")
    elif (name == "intpntTolPfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_pfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_pfeas)")
    elif (name == "basisRelTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basis_rel_tol_s)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_rel_tol_s)")
    elif (name == "presolveTolAbsLindep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_abs_lindep)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_abs_lindep)")
    elif (name == "intpntCoTolInfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_infeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_infeas)")
    elif (name == "mioRelGapConst"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-15 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_gap_const)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_gap_const)")
    elif (name == "presolveTolAij"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-15 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_aij)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_aij)")
    elif (name == "mioMaxTimeAprxOpt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time_aprx_opt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time_aprx_opt)")
    elif (name == "intpntTolPath"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999000e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_path)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_path)")
    elif (name == "basisTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_x)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_x)")
    elif (name == "intpntTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-14 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_gap)")
    elif (name == "intpntTolPsafe"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-04 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_psafe)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_psafe)")
    elif (name == "intpntCoTolNearRel"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_near_rel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_near_rel)")
    elif (name == "mioTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_gap)")
    elif (name == "intpntTolDfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dfeas)")
    elif (name == "mioNearTolAbsGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_abs_gap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_abs_gap)")
    elif (name == "mioTolRelRelaxInt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_relax_int)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_relax_int)")
    elif (name == "intpntCoTolPfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_pfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_pfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SI(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(3431:9-4389:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,int)")
  def _setParameter_Omosek_fusion_Model_2SI(M,name,value):
    if   False:
      pass
    elif (name == "simStabilityPriority"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_STABILITY_PRIORITY",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_stability_priority)")
    elif (name == "simPrimalPhaseoneMethod"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_phaseone_method)")
    elif (name == "presolveLevel"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_level)")
    elif (name == "logNonconvex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_NONCONVEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_nonconvex)")
    elif (name == "mioCutLevelTree"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_TREE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_tree)")
    elif (name == "logConcurrent"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CONCURRENT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_concurrent)")
    elif (name == "logInfeasAna"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_infeas_ana)")
    elif (name == "simDualRestrictSelection"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_restrict_selection)")
    elif (name == "logMioFreq"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio_freq)")
    elif (name == "presolveElimFill"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIM_FILL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_elim_fill)")
    elif (name == "mioLocalBranchNumber"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_local_branch_number)")
    elif (name == "warningLevel"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_WARNING_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (warning_level)")
    elif (name == "logBiFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi_freq)")
    elif (name == "concurrentPriorityDualSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_dual_simplex)")
    elif (name == "logPresolve"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_presolve)")
    elif (name == "intpntOffColTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_off_col_trh)")
    elif (name == "logSim"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim)")
    elif (name == "mtSpincount"):
      v = value

      if   (v <= 1000000000):
        ( M._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mt_spincount)")
    elif (name == "logSimFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_freq)")
    elif (name == "presolveMaxNumReductions"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_max_num_reductions)")
    elif (name == "logFactor"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FACTOR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_factor)")
    elif (name == "timingLevel"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_TIMING_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (timing_level)")
    elif (name == "logOrder"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_order)")
    elif (name == "mioCutLevelRoot"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_ROOT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_cut_level_root)")
    elif (name == "intpntMaxNumRefinementSteps"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_refinement_steps)")
    elif (name == "logSimMinor"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_minor)")
    elif (name == "simMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_iterations)")
    elif (name == "intpntMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_iterations)")
    elif (name == "logBi"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_bi)")
    elif (name == "intpntMaxNumCor"):
      v = value

      if   ((- 1) <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_max_num_cor)")
    elif (name == "licTrhExpiryWrn"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LIC_TRH_EXPIRY_WRN",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lic_trh_expiry_wrn)")
    elif (name == "presolveEliminatorMaxNumTries"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_eliminator_max_num_tries)")
    elif (name == "concurrentNumOptimizers"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_num_optimizers)")
    elif (name == "simRefactorFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_refactor_freq)")
    elif (name == "mioOptimizerMode"):
      v = value

      if   (v <= 1):
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_OPTIMIZER_MODE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_optimizer_mode)")
    elif (name == "logIntpnt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_intpnt)")
    elif (name == "logMio"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_mio)")
    elif (name == "logParam"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_PARAM",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_param)")
    elif (name == "intpntFactorDebugLvl"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_debug_lvl)")
    elif (name == "licensePauseTime"):
      v = value

      if   (v <= 1000000):
        ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (license_pause_time)")
    elif (name == "biMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (bi_max_iterations)")
    elif (name == "presolveLindepRelWorkTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_rel_work_trh)")
    elif (name == "logFeasRepair"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FEAS_REPAIR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_feas_repair)")
    elif (name == "simMaxNumSetbacks"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_max_num_setbacks)")
    elif (name == "concurrentPriorityPrimalSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_primal_simplex)")
    elif (name == "logSimNetworkFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_NETWORK_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_sim_network_freq)")
    elif (name == "presolveLindepAbsWorkTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_lindep_abs_work_trh)")
    elif (name == "logStorage"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_STORAGE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_storage)")
    elif (name == "logCutSecondOpt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_cut_second_opt)")
    elif (name == "mioMaxNumSolutions"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_solutions)")
    elif (name == "concurrentPriorityFreeSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_free_simplex)")
    elif (name == "logFile"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FILE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_file)")
    elif (name == "concurrentPriorityIntpnt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_INTPNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrent_priority_intpnt)")
    elif (name == "allocAddQnz"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_ALLOC_ADD_QNZ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (alloc_add_qnz)")
    elif (name == "logOptimizer"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_OPTIMIZER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_optimizer)")
    elif (name == "mioMaxNumBranches"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_branches)")
    elif (name == "simPrimalCrash"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_crash)")
    elif (name == "mioStrongBranch"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_STRONG_BRANCH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_strong_branch)")
    elif (name == "simDualPhaseoneMethod"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_phaseone_method)")
    elif (name == "simInteger"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_INTEGER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_integer)")
    elif (name == "simPrimalRestrictSelection"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_primal_restrict_selection)")
    elif (name == "maxNumWarnings"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_MAX_NUM_WARNINGS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (max_num_warnings)")
    elif (name == "logExpand"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_expand)")
    elif (name == "mioFeaspumpLevel"):
      v = value

      if   (v <= 3):
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_feaspump_level)")
    elif (name == "logResponse"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_response)")
    elif (name == "log"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
    elif (name == "numThreads"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (num_threads)")
    elif (name == "logCheckConvexity"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CHECK_CONVEXITY",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_check_convexity)")
    elif (name == "simDualCrash"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_dual_crash)")
    elif (name == "logHead"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_HEAD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log_head)")
    elif (name == "intpntFactorMethod"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_factor_method)")
    elif (name == "mioMaxNumRelaxs"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_num_relaxs)")
    elif (name == "mioHeuristicLevel"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_level)")
    elif (name == "lowerObjCutFiniteTrh"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut_finite_trh)")
    elif (name == "mioMaxTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time)")
    elif (name == "basisTolS"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_s)")
    elif (name == "presolveTolS"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_s)")
    elif (name == "upperObjCut"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut)")
    elif (name == "intpntCoTolDfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_dfeas)")
    elif (name == "mioTolAbsGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_gap)")
    elif (name == "upperObjCutFiniteTrh"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut_finite_trh)")
    elif (name == "mioTolAbsRelaxInt"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_relax_int)")
    elif (name == "simplexAbsTolPiv"):
      v = float(value)

      if   (1.000000e-12 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplex_abs_tol_piv)")
    elif (name == "mioHeuristicTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_time)")
    elif (name == "presolveTolX"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_x)")
    elif (name == "mioNearTolRelGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_rel_gap)")
    elif (name == "presolveTolRelLindep"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_rel_lindep)")
    elif (name == "intpntTolDsafe"):
      v = float(value)

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dsafe)")
    elif (name == "mioTolFeas"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_feas)")
    elif (name == "intpntTolInfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_infeas)")
    elif (name == "optimizerMaxTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer_max_time)")
    elif (name == "anaSolInfeasTol"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (ana_sol_infeas_tol)")
    elif (name == "mioRelAddCutLimited"):
      v = float(value)

      if   (v <= 2.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_add_cut_limited)")
    elif (name == "intpntTolMuRed"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_mu_red)")
    elif (name == "intpntCoTolMuRed"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_mu_red)")
    elif (name == "intpntCoTolRelGap"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_rel_gap)")
    elif (name == "lowerObjCut"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut)")
    elif (name == "mioDisableTermTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_disable_term_time)")
    elif (name == "intpntTolRelStep"):
      v = float(value)

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_step)")
    elif (name == "mioTolX"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_x)")
    elif (name == "simLuTolRelPiv"):
      v = float(value)

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_lu_tol_rel_piv)")
    elif (name == "intpntTolStepSize"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_step_size)")
    elif (name == "intpntTolPfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_pfeas)")
    elif (name == "basisRelTolS"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_rel_tol_s)")
    elif (name == "presolveTolAbsLindep"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_abs_lindep)")
    elif (name == "intpntCoTolInfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_infeas)")
    elif (name == "mioRelGapConst"):
      v = float(value)

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_gap_const)")
    elif (name == "presolveTolAij"):
      v = float(value)

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_aij)")
    elif (name == "mioMaxTimeAprxOpt"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time_aprx_opt)")
    elif (name == "intpntTolPath"):
      v = float(value)

      if   (v <= 9.999000e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_path)")
    elif (name == "basisTolX"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_x)")
    elif (name == "intpntTolRelGap"):
      v = float(value)

      if   (1.000000e-14 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_gap)")
    elif (name == "intpntTolPsafe"):
      v = float(value)

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_psafe)")
    elif (name == "intpntCoTolNearRel"):
      v = float(value)

      if   (1.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_near_rel)")
    elif (name == "mioTolRelGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_gap)")
    elif (name == "intpntTolDfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dfeas)")
    elif (name == "mioNearTolAbsGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_abs_gap)")
    elif (name == "mioTolRelRelaxInt"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_relax_int)")
    elif (name == "intpntCoTolPfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_pfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.0.0/monty-0.0.0/fusion/src/Parameters.mbi(4392:9-4766:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,float)")
  def _setParameter_Omosek_fusion_Model_2SF(M,name,value):
    if   False:
      pass
    elif (name == "lowerObjCutFiniteTrh"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut_finite_trh)")
    elif (name == "mioMaxTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time)")
    elif (name == "basisTolS"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_s)")
    elif (name == "presolveTolS"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_s)")
    elif (name == "upperObjCut"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut)")
    elif (name == "intpntCoTolDfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_dfeas)")
    elif (name == "mioTolAbsGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_gap)")
    elif (name == "upperObjCutFiniteTrh"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upper_obj_cut_finite_trh)")
    elif (name == "mioTolAbsRelaxInt"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_abs_relax_int)")
    elif (name == "simplexAbsTolPiv"):
      v = value

      if   (1.000000e-12 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplex_abs_tol_piv)")
    elif (name == "mioHeuristicTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_heuristic_time)")
    elif (name == "presolveTolX"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_x)")
    elif (name == "mioNearTolRelGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_rel_gap)")
    elif (name == "presolveTolRelLindep"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_rel_lindep)")
    elif (name == "intpntTolDsafe"):
      v = value

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dsafe)")
    elif (name == "mioTolFeas"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_feas)")
    elif (name == "intpntTolInfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_infeas)")
    elif (name == "optimizerMaxTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer_max_time)")
    elif (name == "anaSolInfeasTol"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (ana_sol_infeas_tol)")
    elif (name == "mioRelAddCutLimited"):
      v = value

      if   (v <= 2.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_add_cut_limited)")
    elif (name == "intpntTolMuRed"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_mu_red)")
    elif (name == "intpntCoTolMuRed"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_mu_red)")
    elif (name == "intpntCoTolRelGap"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_rel_gap)")
    elif (name == "lowerObjCut"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lower_obj_cut)")
    elif (name == "mioDisableTermTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_disable_term_time)")
    elif (name == "intpntTolRelStep"):
      v = value

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_step)")
    elif (name == "mioTolX"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_x)")
    elif (name == "simLuTolRelPiv"):
      v = value

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (sim_lu_tol_rel_piv)")
    elif (name == "intpntTolStepSize"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_step_size)")
    elif (name == "intpntTolPfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_pfeas)")
    elif (name == "basisRelTolS"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_rel_tol_s)")
    elif (name == "presolveTolAbsLindep"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_abs_lindep)")
    elif (name == "intpntCoTolInfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_infeas)")
    elif (name == "mioRelGapConst"):
      v = value

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_rel_gap_const)")
    elif (name == "presolveTolAij"):
      v = value

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolve_tol_aij)")
    elif (name == "mioMaxTimeAprxOpt"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_max_time_aprx_opt)")
    elif (name == "intpntTolPath"):
      v = value

      if   (v <= 9.999000e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_path)")
    elif (name == "basisTolX"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basis_tol_x)")
    elif (name == "intpntTolRelGap"):
      v = value

      if   (1.000000e-14 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_rel_gap)")
    elif (name == "intpntTolPsafe"):
      v = value

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_psafe)")
    elif (name == "intpntCoTolNearRel"):
      v = value

      if   (1.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_near_rel)")
    elif (name == "mioTolRelGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_gap)")
    elif (name == "intpntTolDfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_tol_dfeas)")
    elif (name == "mioNearTolAbsGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_near_tol_abs_gap)")
    elif (name == "mioTolRelRelaxInt"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mio_tol_rel_relax_int)")
    elif (name == "intpntCoTolPfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpnt_co_tol_pfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  @_cliptrace
  def setParameter(*args):
    if   Parameters._matchargs_setParameter_Omosek_fusion_Model_2SS(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SS(*args)
    elif Parameters._matchargs_setParameter_Omosek_fusion_Model_2SF(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SF(*args)
    elif Parameters._matchargs_setParameter_Omosek_fusion_Model_2SI(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SI(*args)
    else:
      argtypestr = "setParameter(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tsetParameter(mosek.fusion.Model,basestring,basestring)"),(3,"\tsetParameter(mosek.fusion.Model,basestring,float)"),(3,"\tsetParameter(mosek.fusion.Model,basestring,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(220:12-226:5)
class UnimplementedError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)

## origin: src/fusion/Set.mbi(12:12-197:5)
class Set:
  @staticmethod
  def _matchargs_constructor_IL(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,long)")
  def __constructor_IL(self,nd_,size_):
    self.nd = nd_
    self._nd_p = nd_
    self._size = size_
  def __init__(self,*args):
    #self.nd = None

    #self._protected_nd_p = None

    #self._protected_size = None

    self.__constructor_IL(*args)
  @staticmethod
  def _matchargs_compare_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Set.mbi(41:15-58:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compare(mosek.fusion.Set)")
  def _compare_Omosek_fusion_Set_2(self,other):
    if   ((self._size != other._size) or (( self._realnd_() ) != ( other._realnd_() ))):
      return False
    i0 = 0

    i1 = 0

    # src/fusion/Set.mbi(46:9-56:9)
    while ((i0 < self.nd) and (i1 < other.nd)):
      if   (( self._dim_I(i0) ) == 1):
        i0 += 1
      elif (( other._dim_I(i1) ) == 1):
        i1 += 1
      elif (( self._dim_I(i0) ) != ( other._dim_I(i1) )):
        return False
      else:
        i0 += 1
        i1 += 1
    return True
  @staticmethod
  def _matchargs_getSize_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(63:15-65:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getSize()")
  def _getSize_(self):
    return self._size
  @staticmethod
  def _matchargs_realnd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(70:15-81:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("realnd()")
  def _realnd_(self):
    if   (self.nd == 1):
      return 1
    else:
      r = 0

      # src/fusion/Set.mbi(75:11-79:15)
      i = 0

      while (i < self.nd):
        if   (( self._dim_I(i) ) > 1):
          r += 1
        i += 1
      if   (r == 0):
        r += 1
      return r
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Set.mbi(88:15-89:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    pass
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Set.mbi(96:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    pass
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Set.mbi(103:15-104:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    pass
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(111:15-112:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int32])")
  def _getname__3I(self,key):
    pass
  @staticmethod
  def _matchargs_idxtokey_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Set.mbi(120:15-129:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("idxtokey(long)")
  def _idxtokey_L(self,idx):
    key = ([ 0 for _autovar_488 in xrange(self._nd_p) ])

    # src/fusion/Set.mbi(123:9-127:9)
    i = 0

    while (i < self._nd_p):
      key[i] = int((idx / ( self._stride_I(i) )))
      idx = ( Utils.Tools._mod_LL (idx,( self._stride_I(i) )) )
      i += 1
    return key
  @staticmethod
  def _matchargs_linearidx__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(139:18-146:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx([int32])")
  def _linearidx__3I(self,key):
    res = long(key[0])

    # src/fusion/Set.mbi(141:9-144:9)
    i = 1

    while (i < int(len(key))):
      res = ((res * long(( self._dim_I(i) ))) + long(key[i]))
      i += 1
    return res
  @staticmethod
  def _matchargs_linearidx_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Set.mbi(149:18-153:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx(int,int)")
  def _linearidx_II(self,key0,key1):
    return long(((key0 * ( self._dim_I(1) )) + key1))
  @staticmethod
  def _matchargs_linearidx_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Set.mbi(156:18-161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx(int,int,int)")
  def _linearidx_III(self,key0,key1,key2):
    return long(((((key0 * ( self._dim_I(1) )) + key1) * ( self._dim_I(2) )) + key2))
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Set.mbi(170:15-172:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(182:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(189:15-196:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( sb._a_S("Set(dimensions={") )._a_I(( self._dim_I(0) )) )
    # src/fusion/Set.mbi(192:9-193:30)
    i = 1

    while (i < self.nd):
      ( ( sb._a_S(",") )._a_I(( self._dim_I(i) )) )
      i += 1
    ( sb._a_S("})") )
    return ( sb._toString_() )
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   Set._matchargs_dim_I(args):
      return Set._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   Set._matchargs_slice_II(args):
      return Set._slice_II(self,*args)
    elif Set._matchargs_slice__3I_3I(args):
      return Set._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   Set._matchargs_stride_I(args):
      return Set._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   Set._matchargs_getname__3I(args):
      return Set._getname__3I(self,*args)
    elif Set._matchargs_getname_L(args):
      return Set._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/NDSet.mbi(11:12-301:5)
class NDSet(Set):
  @staticmethod
  def _matchargs_constructor__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int32],[int32])")
  def __constructor__3I_3I(self,startx,stopx):
    mosek.fusion.Set._Set__constructor_IL(self,int(len(startx)),( NDSet.__sumdims__3I_3I (startx,stopx) ))
    if   (int(len(startx)) != int(len(stopx))):
      raise mosek.fusion.LengthError("Array lengths do not match.")
    # src/fusion/NDSet.mbi(98:9-103:16)
    i = 0

    while (i < self.nd):
      if   (stopx[i] < startx[i]):
        raise mosek.fusion.SliceError("Indexes define a range with negative length.")
      i += 1
    self.__start = ( Utils.Tools._arraycopy__3I (startx) )
    self.__stop = ( Utils.Tools._arraycopy__3I (stopx) )
    self.__strides = ([ 0l for _autovar_489 in xrange(self.nd) ])
    self.__strides[(self.nd - 1)] = 1l
    # src/fusion/NDSet.mbi(108:9-111:9)
    i = (self.nd - 1)

    while (i > 0):
      self.__strides[(i - 1)] = (self.__strides[i] * (self.__stop[i] - self.__start[i]))
      i -= 1
  @staticmethod
  def _matchargs_constructor__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int32])")
  def __constructor__3I(self,sizes):
    mosek.fusion.Set._Set__constructor_IL(self,int(len(sizes)),( NDSet.__sumdims__3I (sizes) ))
    self.__start = ( Utils.Tools._makevector_II (0,int(len(sizes))) )
    self.__stop = ([ 0 for _autovar_490 in xrange(self.nd) ])
    self.__strides = ([ 0l for _autovar_491 in xrange(self.nd) ])
    # src/fusion/NDSet.mbi(130:9-133:9)
    i = 0

    while (i < self.nd):
      self.__stop[i] = sizes[i]
      i += 1
    self.__strides[(self.nd - 1)] = 1l
    # src/fusion/NDSet.mbi(137:9-140:9)
    i = (self.nd - 1)

    while (i > 0):
      self.__strides[(i - 1)] = (self.__strides[i] * sizes[i])
      i -= 1
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int)")
  def __constructor_II(self,size0,size1):
    mosek.fusion.Set._Set__constructor_IL(self,2,long((size0 * size1)))
    self.__start = ( Utils.Tools._makevector_II (0,2) )
    self.__stop = ([ size0,size1])
    self.__strides = ([ long(size1),1l])
  @staticmethod
  def _matchargs_constructor_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,int)")
  def __constructor_III(self,size0,size1,size2):
    mosek.fusion.Set._Set__constructor_IL(self,3,long(((size0 * size1) * size2)))
    self.__start = ([ 0,0,0])
    self.__stop = ([ size0,size1,size2])
    self.__strides = ([ long((size1 * size2)),long(size2),1l])
  def __init__(self,*args):
    #self.__start = None

    #self.__stop = None

    #self.__strides = None

    if   self._matchargs_constructor__3I_3I(args):
      self.__constructor__3I_3I(*args)
    elif self._matchargs_constructor__3I(args):
      self.__constructor__3I(*args)
    elif self._matchargs_constructor_II(args):
      self.__constructor_II(*args)
    elif self._matchargs_constructor_III(args):
      self.__constructor_III(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(26:15-28:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return self.__strides[i]
  @staticmethod
  def _matchargs_sumdims__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(32:16-46:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sumdims([int32],[int32])")
  def __sumdims__3I_3I(startx,stopx):
    if   (int(len(startx)) != int(len(stopx))):
      raise mosek.fusion.SetDefinitionError("invalid range arrays")
    res = 1l

    # src/fusion/NDSet.mbi(38:9-44:9)
    i = 0

    while (i < int(len(startx))):
      if   (stopx[i] < startx[i]):
        raise mosek.fusion.SetDefinitionError("invalid range arrays")
      res = (res * long((stopx[i] - startx[i])))
      i += 1
    return res
  @staticmethod
  def _matchargs_sumdims__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(49:16-58:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sumdims([int32])")
  def __sumdims__3I(stopx):
    res = 1l

    # src/fusion/NDSet.mbi(51:9-56:9)
    i = 0

    while (i < int(len(stopx))):
      if   (stopx[i] <= 0):
        raise mosek.fusion.SetDefinitionError("invalid size definition")
      res = (res * long(stopx[i]))
      i += 1
    return res
  @staticmethod
  def _matchargs_lookup_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(61:16-75:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("lookup(int,int)")
  def __lookup_II(self,dim,idx):
    if   ((((dim < 0) or (dim >= self.nd)) or (idx < self.__start[dim])) or (idx > self.__stop[dim])):
      raise mosek.fusion.IndexError("index out of bounds")
    else:
      return (idx - self.__start[dim])
  @staticmethod
  def _matchargs_linear_1index_1in_1dim_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(183:18-196:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linear_index_in_dim(int,int)")
  def _linear_1index_1in_1dim_II(self,dim,key):
    if   ((dim < 0) or (dim >= int(len(self.__start)))):
      raise mosek.fusion.IndexError("dimension index out of bounds")
    if   ((key < self.__start[dim]) or (key >= self.__stop[dim])):
      raise mosek.fusion.IndexError("key out of bounds")
    else:
      return (key - self.__start[dim])
  @staticmethod
  def _matchargs_linear_1index_1in_1dim_I_3I(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(199:18-201:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linear_index_in_dim(int,[int32])")
  def _linear_1index_1in_1dim_I_3I(self,dim,key):
    raise mosek.fusion.IndexError("invalid key type")
  @staticmethod
  def _matchargs_selectidxs__3S(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(205:18-207:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("selectidxs([string])")
  def _selectidxs__3S(self,key):
    raise mosek.fusion.IndexError("invalid key type")
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(210:15-217:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.nd != 1):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    elif (((first < 0) or (last < first)) or (long(last) > self._size)):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    return mosek.fusion.IntSet((first + self.__start[0]),(last + self.__start[0]))
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(220:15-242:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first,last):
    if   ((self.nd != int(len(first))) or (self.nd != int(len(last)))):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    # src/fusion/NDSet.mbi(225:9-231:9)
    i = 0

    while (i < self.nd):
      if   (((first[i] < 0) or (last[i] < first[i])) or ((last[i] + self.__start[i]) > self.__stop[i])):
        raise mosek.fusion.SliceError("Slice is out of bounds.")
      i += 1
    start_ = ([ 0 for _autovar_492 in xrange(self.nd) ])

    stop_ = ([ 0 for _autovar_493 in xrange(self.nd) ])

    # src/fusion/NDSet.mbi(235:9-239:9)
    i = 0

    while (i < self.nd):
      start_[i] = (self.__start[i] + first[i])
      stop_[i] = (self.__start[i] + last[i])
      i += 1
    return mosek.fusion.NDSet(start_,stop_)
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(245:15-250:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    if   (i >= int(len(self.__stop))):
      return 1
    else:
      return (self.__stop[i] - self.__start[i])
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/NDSet.mbi(253:15-273:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    if   (self.nd == 1):
      ndidx = ([ 0l for _autovar_494 in xrange(self.nd) ])

      keyremainder = key

      # src/fusion/NDSet.mbi(259:11-263:11)
      i = 0

      while (i < self.nd):
        ndidx[i] = (keyremainder / self.__strides[i])
        keyremainder = (keyremainder - (ndidx[i] * self.__strides[i]))
        i += 1
      tmp = mosek.fusion.Utils.StringBuffer()

      ( tmp._a_L((key + self.__start[0])) )
      return ( tmp._toString_() )
    else:
      return ( self._getname__3I(( self._idxtokey_L(key) )) )
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(276:15-298:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int32])")
  def _getname__3I(self,key):
    if   (self.nd != int(len(key))):
      raise mosek.fusion.DimensionError("Key dimensions do not match set dimensions.")
    # src/fusion/NDSet.mbi(282:9-289:9)
    i = 0

    while (i < self.nd):
      if   ((key[i] < 0) or (key[i] >= ((self.__stop[i] - self.__start[i]) + 1))):
        raise mosek.fusion.IndexError("Key dimensions do not match set dimensions.")
      i += 1
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_I((key[0] + self.__start[0])) )
    # src/fusion/NDSet.mbi(293:9-296:9)
    i = 1

    while (i < self.nd):
      ( sb._a_S(",") )
      ( sb._a_I((key[i] + self.__start[i])) )
      i += 1
    return ( sb._toString_() )
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   NDSet._matchargs_dim_I(args):
      return NDSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   NDSet._matchargs_slice_II(args):
      return NDSet._slice_II(self,*args)
    elif NDSet._matchargs_slice__3I_3I(args):
      return NDSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   NDSet._matchargs_stride_I(args):
      return NDSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   NDSet._matchargs_getname__3I(args):
      return NDSet._getname__3I(self,*args)
    elif NDSet._matchargs_getname_L(args):
      return NDSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/PSet.mbi(11:12-67:5)
class PSet(NDSet):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Set,mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Set_2Omosek_fusion_Set_2(self,lhs,rhs):
    mosek.fusion.NDSet._NDSet__constructor__3I(self,( PSet.__buildsizes_Omosek_fusion_Set_2Omosek_fusion_Set_2 (lhs,rhs) ))
    self.__set1 = lhs
    self.__set2 = rhs
  def __init__(self,*args):
    #self.__set1 = None

    #self.__set2 = None

    self.__constructor_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_buildsizes_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/PSet.mbi(16:16-23:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("buildsizes(mosek.fusion.Set,mosek.fusion.Set)")
  def __buildsizes_Omosek_fusion_Set_2Omosek_fusion_Set_2(lhs,rhs):
    res = ([ 0 for _autovar_495 in xrange((lhs.nd + rhs.nd)) ])

    # src/fusion/PSet.mbi(18:9-19:30)
    i = 0

    while (i < lhs.nd):
      res[i] = ( lhs._dim_I(i) )
      i += 1
    # src/fusion/PSet.mbi(20:9-21:37)
    i = 0

    while (i < rhs.nd):
      res[(i + lhs.nd)] = ( rhs._dim_I(i) )
      i += 1
    return res
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/PSet.mbi(53:15-66:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int32])")
  def _getname__3I(self,key):
    if   (self.nd != int(len(key))):
      raise mosek.fusion.DimensionError("Key dimensions do not match set dimensions.")
    k1 = ([ 0 for _autovar_496 in xrange(self.__set1.nd) ])

    k2 = ([ 0 for _autovar_497 in xrange(self.__set2.nd) ])

    # src/fusion/PSet.mbi(59:9-57)
    i = 0

    while (i < self.__set1.nd):
      k1[i] = key[i]
      i += 1
    # src/fusion/PSet.mbi(60:9-65)
    i = 0

    while (i < self.__set2.nd):
      k2[i] = key[(i + self.__set1.nd)]
      i += 1
    n1 = ( self.__set1._getname__3I(k1) )

    n2 = ( self.__set2._getname__3I(k2) )

    return ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(n1) )._a_S(",") )._a_S(n2) )._toString_() )
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   NDSet._matchargs_dim_I(args):
      return NDSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   NDSet._matchargs_slice_II(args):
      return NDSet._slice_II(self,*args)
    elif NDSet._matchargs_slice__3I_3I(args):
      return NDSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   NDSet._matchargs_stride_I(args):
      return NDSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   PSet._matchargs_getname__3I(args):
      return PSet._getname__3I(self,*args)
    elif NDSet._matchargs_getname_L(args):
      return NDSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/BaseSet.mbi(9:12-26:5)
class BaseSet(Set):
  @staticmethod
  def _matchargs_constructor_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(long)")
  def __constructor_L(self,size_):
    mosek.fusion.Set._Set__constructor_IL(self,1,size_)
    pass
  def __init__(self,*args):
    self.__constructor_L(*args)
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/BaseSet.mbi(20:15-25:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    if   (i != 0):
      return 1
    else:
      return int(self._size)
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   Set._matchargs_slice__3I_3I(args):
      return Set._slice__3I_3I(self,*args)
    elif Set._matchargs_slice_II(args):
      return Set._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int32],[int32])"),(2,"\tslice(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   Set._matchargs_stride_I(args):
      return Set._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   Set._matchargs_getname__3I(args):
      return Set._getname__3I(self,*args)
    elif Set._matchargs_getname_L(args):
      return Set._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/StringSet.mbi(8:12-86:5)
class StringSet(BaseSet):
  @staticmethod
  def _matchargs_constructor__3S(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([string])")
  def __constructor__3S(self,ks):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long(int(len(ks))))
    self.__keys = ( Utils.Tools._arraycopy__3S (ks) )
  def __init__(self,*args):
    #self.__keys = None

    self.__constructor__3S(*args)
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(21:15-23:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return 1l
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/StringSet.mbi(25:15-35:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( sb._a_S("{'") )._a_S(self.__keys[0]) )._a_S("'") )
    # src/fusion/StringSet.mbi(29:9-32:9)
    i = 1

    while (i < int(len(self.__keys))):
      ( ( ( sb._a_S(",'") )._a_S(self.__keys[i]) )._a_S("'") )
      i += 1
    ( sb._a_S("}") )
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(38:15-40:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first_,last_):
    return ( self._slice_1_II(first_,last_) )
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(43:15-45:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,first_,last_):
    return ( self._slice_1__3I_3I(first_,last_) )
  @staticmethod
  def _matchargs_slice_1_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(48:18-57:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(int,int)")
  def _slice_1_II(self,first,last):
    if   (((first < 0) or (first > last)) or (last > int(len(self.__keys)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    res = ([ None for _autovar_498 in xrange((last - first)) ])

    # src/fusion/StringSet.mbi(55:9-68)
    i = 0

    while (i < (last - first)):
      res[i] = self.__keys[(i + first)]
      i += 1
    return mosek.fusion.StringSet(res)
  @staticmethod
  def _matchargs_slice_1__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(59:18-71:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_([int32],[int32])")
  def _slice_1__3I_3I(self,first,last):
    if   (((((int(len(first)) != 1) or (int(len(last)) != 1)) or (first[0] < 0)) or (first[0] > last[0])) or (last[0] >= int(len(self.__keys)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    res = ([ None for _autovar_499 in xrange(((last[0] - first[0]) + 1)) ])

    return mosek.fusion.StringSet(res)
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/StringSet.mbi(74:15-76:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    return self.__keys[key]
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(79:15-85:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int32])")
  def _getname__3I(self,key):
    if   (int(len(key)) != 1):
      raise mosek.fusion.IndexError("Invalid key specification")
    return self.__keys[key[0]]
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   StringSet._matchargs_slice__3I_3I(args):
      return StringSet._slice__3I_3I(self,*args)
    elif StringSet._matchargs_slice_II(args):
      return StringSet._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int32],[int32])"),(2,"\tslice(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   StringSet._matchargs_stride_I(args):
      return StringSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   StringSet._matchargs_toString_(args):
      return StringSet._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   StringSet._matchargs_getname__3I(args):
      return StringSet._getname__3I(self,*args)
    elif StringSet._matchargs_getname_L(args):
      return StringSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/IntSet.mbi(10:12-88:5)
class IntSet(BaseSet):
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int)")
  def __constructor_II(self,first_,last_):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long((last_ - first_)))
    self.__first = first_
    self.__last = last_
  @staticmethod
  def _matchargs_constructor_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int)")
  def __constructor_I(self,length):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long(length))
    self.__first = 0
    self.__last = length
  def __init__(self,*args):
    #self.__first = None

    #self.__last = None

    if   self._matchargs_constructor_II(args):
      self.__constructor_II(*args)
    elif self._matchargs_constructor_I(args):
      self.__constructor_I(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(38:15-40:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return 1l
  @staticmethod
  def _matchargs_getidx_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(43:15-49:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getidx(int)")
  def _getidx_I(self,key):
    if   ((key < self.__first) or (key > self.__last)):
      raise mosek.fusion.IndexError("Index out of bounds")
    return (key - self.__first)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(52:15-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    if   (((firstidx < 0) or (firstidx > lastidx)) or (lastidx > (self.__last - self.__first))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    return mosek.fusion.IntSet((self.__first + firstidx),(self.__first + lastidx))
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntSet.mbi(65:15-74:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int32],[int32])")
  def _slice__3I_3I(self,firstidx,lastidx):
    if   ((int(len(firstidx)) != 1) or (int(len(lastidx)) != 1)):
      raise mosek.fusion.SliceError("Invalid slice specification")
    return ( self._slice_II(firstidx[0],lastidx[0]) )
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/IntSet.mbi(77:15-79:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    return ( Utils.Tools._stringvalue_L (key) )
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntSet.mbi(82:15-87:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int32])")
  def _getname__3I(self,key):
    if   (int(len(key)) != 1):
      raise mosek.fusion.IndexError("Invalid key specification")
    return ( Utils.Tools._stringvalue_I (key[0]) )
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def slice(self,*args):
    if   IntSet._matchargs_slice_II(args):
      return IntSet._slice_II(self,*args)
    elif IntSet._matchargs_slice__3I_3I(args):
      return IntSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def stride(self,*args):
    if   IntSet._matchargs_stride_I(args):
      return IntSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getname(self,*args):
    if   IntSet._matchargs_getname__3I(args):
      return IntSet._getname__3I(self,*args)
    elif IntSet._matchargs_getname_L(args):
      return IntSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int32])"),(1,"\tgetname(long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getidx(self,*args):
    if   IntSet._matchargs_getidx_I(args):
      return IntSet._getidx_I(self,*args)
    else:
      argtypestr = "getidx(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetidx(int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/CommonUtil.mbi(599:12-650:5)
class IndexCounter:
  @staticmethod
  def _matchargs_constructor_L_3I_3L(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(long,[int32],[int64])")
  def __constructor_L_3I_3L(self,start,dims_,strides_):
    self.__n = int(len(dims_))
    self.__ii = ([ 0 for _autovar_500 in xrange(self.__n) ])
    self.__st = ([ 0l for _autovar_501 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(614:22-55)
    for i in xrange(0,self.__n):
      self.__st[i] = start
    self.__strides = strides_
    self.__dims = dims_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Set)")
  def __constructor_Omosek_fusion_Set_2(self,shape):
    self.__n = shape.nd
    self.__ii = ([ 0 for _autovar_502 in xrange(self.__n) ])
    self.__st = ([ 0l for _autovar_503 in xrange(self.__n) ])
    self.__strides = ([ 0l for _autovar_504 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(627:27-74)
    for i in xrange(0,self.__n):
      self.__strides[i] = ( shape._stride_I(i) )
    self.__dims = ([ 0 for _autovar_505 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(628:27-71)
    for i in xrange(0,self.__n):
      self.__dims[i] = ( shape._dim_I(i) )
  def __init__(self,*args):
    #self.__n = None

    #self.__ii = None

    #self.__st = None

    #self.__strides = None

    #self.__dims = None

    if   self._matchargs_constructor_L_3I_3L(args):
      self.__constructor_L_3I_3L(*args)
    elif self._matchargs_constructor_Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Set_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_inc_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(633:15-644:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inc()")
  def _inc_(self):
    self.__ii[0] += 1
    self.__st[0] = (self.__st[0] + self.__strides[(self.__n - 1)])

    # src/fusion/CommonUtil.mbi(636:9-641:9)
    i = 0
    while ((i < (self.__n - 1)) and (self.__ii[i] == self.__dims[((self.__n - i) - 1)])):
      self.__ii[i] = 0
      self.__ii[(i + 1)] += 1
      self.__st[(i + 1)] = (self.__st[(i + 1)] + self.__strides[((self.__n - i) - 2)])
      i += 1
    # src/fusion/CommonUtil.mbi(643:9-41)
    for j in xrange(0,i):
      self.__st[j] = self.__st[i]
  @staticmethod
  def _matchargs_get_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(647:15-646:49)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get()")
  def _get_(self):
    return self.__st[0]
  @staticmethod
  def _matchargs_getIndex_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(648:15-647:54)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getIndex()")
  def _getIndex_(self):
    return self.__ii
  @staticmethod
  def _matchargs_atEnd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(650:15-649:66)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("atEnd()")
  def _atEnd_(self):
    return (self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)])
  @_cliptrace
  def getIndex(self,*args):
    if   IndexCounter._matchargs_getIndex_(args):
      return IndexCounter._getIndex_(self,*args)
    else:
      argtypestr = "getIndex(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetIndex()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def get(self,*args):
    if   IndexCounter._matchargs_get_(args):
      return IndexCounter._get_(self,*args)
    else:
      argtypestr = "get(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def atEnd(self,*args):
    if   IndexCounter._matchargs_atEnd_(args):
      return IndexCounter._atEnd_(self,*args)
    else:
      argtypestr = "atEnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tatEnd()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def inc(self,*args):
    if   IndexCounter._matchargs_inc_(args):
      return IndexCounter._inc_(self,*args)
    else:
      argtypestr = "inc(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinc()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Sort.mbi(7:12-334:5)
class Sort:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_compareArg__3I_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(9:15-20:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compareArg([int32],[int32],long,long)")
  def _compareArg__3I_3ILL(val1,val2,lhsidx,rhsidx):
    if   (val1[lhsidx] < val1[rhsidx]):
      return (- 1)
    elif (val1[lhsidx] > val1[rhsidx]):
      return 1
    elif (val2[lhsidx] < val2[rhsidx]):
      return (- 1)
    elif (val2[lhsidx] > val2[rhsidx]):
      return 1
    else:
      return 0
  @staticmethod
  def _matchargs_argmerge__3LLLLL_3LL_3I_3I(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[6],long): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(96:16-129:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argmerge([int64],long,long,long,long,[int64],long,[int32],[int32])")
  def __argmerge__3LLLLL_3LL_3I_3I(perm_src,src_base1,num1,src_base2,num2,perm_tgt,tgt_base,val1,val2):
    it = tgt_base

    is1 = 0l

    is2 = 0l

    # src/fusion/Sort.mbi(108:9-119:9)
    while ((is1 < num1) and (is2 < num2)):
      if   (( Sort._compareArg__3I_3ILL (val1,val2,perm_src[(is1 + src_base1)],perm_src[(is2 + src_base2)]) ) <= 0):
        perm_tgt[it] = perm_src[(is1 + src_base1)]
        is1 += 1
      else:
        perm_tgt[it] = perm_src[(is2 + src_base2)]
        is2 += 1
      it += 1
    # src/fusion/Sort.mbi(121:9-124:9)
    while (is1 < num1):
      perm_tgt[it] = perm_src[(is1 + src_base1)]
      is1 += 1
      it += 1
    # src/fusion/Sort.mbi(125:9-128:9)
    while (is2 < num2):
      perm_tgt[it] = perm_src[(is2 + src_base2)]
      is2 += 1
      it += 1
  @staticmethod
  def _matchargs_argmerge__3LLLLL_3LL_3I(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[6],long): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(132:16-164:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argmerge([int64],long,long,long,long,[int64],long,[int32])")
  def __argmerge__3LLLLL_3LL_3I(perm_src,src_base1,num1,src_base2,num2,perm_tgt,tgt_base,val):
    it = tgt_base

    is1 = 0l

    is2 = 0l

    # src/fusion/Sort.mbi(143:9-154:9)
    while ((is1 < num1) and (is2 < num2)):
      if   (val[perm_src[(src_base1 + is1)]] <= val[perm_src[(src_base2 + is2)]]):
        perm_tgt[it] = perm_src[(is1 + src_base1)]
        is1 += 1
      else:
        perm_tgt[it] = perm_src[(is2 + src_base2)]
        is2 += 1
      it += 1
    # src/fusion/Sort.mbi(156:9-159:9)
    while (is1 < num1):
      perm_tgt[it] = perm_src[(is1 + src_base1)]
      is1 += 1
      it += 1
    # src/fusion/Sort.mbi(160:9-163:9)
    while (is2 < num2):
      perm_tgt[it] = perm_src[(is2 + src_base2)]
      is2 += 1
      it += 1
  @staticmethod
  def _matchargs_argsort_1merge__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/Sort.mbi(167:15-237:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort_merge([int64],[int32],[int32],long,long)")
  def _argsort_1merge__3L_3I_3ILL(perm,val1,val2,first,last):
    rangelen = (last - first)

    perm0 = perm

    base0 = first

    perm1 = ([ 0l for _autovar_506 in xrange((last - first)) ])

    base1 = 0l

    alt = True

    ilen = 1l

    # src/fusion/Sort.mbi(178:9-231:9)
    while (ilen < rangelen):
      if   alt:
        i = 0l

        # src/fusion/Sort.mbi(183:13-190:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),ilen,perm1,(base1 + i),val1,val2) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),((rangelen - i) - ilen),perm1,(base1 + i),val1,val2) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm0,(base0 + i),perm1,(base1 + i),(rangelen - i)) )
      else:
        i = 0l

        # src/fusion/Sort.mbi(207:13-214:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),ilen,perm0,(base0 + i),val1,val2) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),((rangelen - i) - ilen),perm0,(base0 + i),val1,val2) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm1,(base1 + i),perm0,(base0 + i),(rangelen - i)) )
      alt = (not alt)
      ilen = (ilen * 2)
    if   (not alt):
      ( Utils.Tools._arraycopy__3LL_3LLL (perm1,0l,perm0,first,rangelen) )
  @staticmethod
  def _matchargs_argsort_1merge__3L_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(242:15-311:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort_merge([int64],[int32],long,long)")
  def _argsort_1merge__3L_3ILL(perm,val,first,last):
    rangelen = (last - first)

    perm0 = perm

    base0 = first

    perm1 = ([ 0l for _autovar_507 in xrange((last - first)) ])

    base1 = 0l

    alt = True

    ilen = 1l

    # src/fusion/Sort.mbi(252:9-305:9)
    while (ilen < rangelen):
      if   alt:
        i = 0l

        # src/fusion/Sort.mbi(257:13-264:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),ilen,perm1,(base1 + i),val) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),((rangelen - i) - ilen),perm1,(base1 + i),val) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm0,(base0 + i),perm1,(base1 + i),(rangelen - i)) )
      else:
        i = 0l

        # src/fusion/Sort.mbi(281:13-288:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),ilen,perm0,(base0 + i),val) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),((rangelen - i) - ilen),perm0,(base0 + i),val) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm1,(base1 + i),perm0,(base0 + i),(rangelen - i)) )
      alt = (not alt)
      ilen = (ilen * 2)
    if   (not alt):
      ( Utils.Tools._arraycopy__3LL_3LLL (perm1,0l,perm0,first,rangelen) )
  @staticmethod
  def _matchargs_argsort__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/Sort.mbi(314:15-316:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([int64],[int32],[int32],long,long)")
  def _argsort__3L_3I_3ILL(perm,val1,val2,first,last):
    ( Sort._argsort_1merge__3L_3I_3ILL (perm,val1,val2,first,last) )
  @staticmethod
  def _matchargs_argsort__3L_3I_3I(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(319:15-321:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([int64],[int32],[int32])")
  def _argsort__3L_3I_3I(perm,val1,val2):
    ( Sort._argsort_1merge__3L_3I_3ILL (perm,val1,val2,0l,long(len(perm))) )
  @staticmethod
  def _matchargs_argsort__3L_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(325:15-327:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([int64],[int32],long,long)")
  def _argsort__3L_3ILL(perm,val,first,last):
    ( Sort._argsort_1merge__3L_3ILL (perm,val,first,last) )
  @staticmethod
  def _matchargs_argsort__3L_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(330:15-332:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([int64],[int32])")
  def _argsort__3L_3I(perm,val):
    ( Sort._argsort_1merge__3L_3ILL (perm,val,0l,long(len(perm))) )
  @staticmethod
  @_cliptrace
  def argsort_merge(*args):
    if   Sort._matchargs_argsort_1merge__3L_3ILL(args):
      return Sort._argsort_1merge__3L_3ILL(*args)
    elif Sort._matchargs_argsort_1merge__3L_3I_3ILL(args):
      return Sort._argsort_1merge__3L_3I_3ILL(*args)
    else:
      argtypestr = "argsort_merge(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\targsort_merge([int64],[int32],long,long)"),(5,"\targsort_merge([int64],[int32],[int32],long,long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def compareArg(*args):
    if   Sort._matchargs_compareArg__3I_3ILL(args):
      return Sort._compareArg__3I_3ILL(*args)
    else:
      argtypestr = "compareArg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tcompareArg([int32],[int32],long,long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def argsort(*args):
    if   Sort._matchargs_argsort__3L_3ILL(args):
      return Sort._argsort__3L_3ILL(*args)
    elif Sort._matchargs_argsort__3L_3I(args):
      return Sort._argsort__3L_3I(*args)
    elif Sort._matchargs_argsort__3L_3I_3ILL(args):
      return Sort._argsort__3L_3I_3ILL(*args)
    elif Sort._matchargs_argsort__3L_3I_3I(args):
      return Sort._argsort__3L_3I_3I(*args)
    else:
      argtypestr = "argsort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\targsort([int64],[int32],long,long)"),(2,"\targsort([int64],[int32])"),(5,"\targsort([int64],[int32],[int32],long,long)"),(3,"\targsort([int64],[int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/CommonUtil.mbi(7:12-595:5)
class CommonTools:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_qsortCmp_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(11:16-17:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortCmp(int,int,int,int)")
  def __qsortCmp_IIII(v1_0,v1_1,v2_0,v2_1):
    if   (v1_0 < v2_0):
      return (- 1)
    if   (v1_0 > v2_0):
      return 1
    if   (v1_1 < v2_1):
      return (- 1)
    if   (v1_1 > v2_1):
      return 1
    return 0
  @staticmethod
  def _matchargs_qsortCmp_LLLL(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(20:16-26:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortCmp(long,long,long,long)")
  def __qsortCmp_LLLL(v1_0,v1_1,v2_0,v2_1):
    if   (v1_0 < v2_0):
      return (- 1)
    if   (v1_0 > v2_0):
      return 1
    if   (v1_1 < v2_1):
      return (- 1)
    if   (v1_1 > v2_1):
      return 1
    return 0
  @staticmethod
  def _matchargs_qsortSwap__3LLL(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(29:16-34:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortSwap([int64],long,long)")
  def __qsortSwap__3LLL(idx,i,j):

    tmp = idx[i]
    idx[i] = idx[j]
    idx[j] = tmp
  @staticmethod
  def _matchargs_qsortPartition__3L_3I_3ILLL(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    if not isinstance(args[5],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(37:16-79:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortPartition([int64],[int32],[int32],long,long,long)")
  def __qsortPartition__3L_3I_3ILLL(idx,vals1,vals2,first,last,pivotIndex):
    pivotVal1 = vals1[idx[pivotIndex]]

    storeIndex = first

    if   (vals2 != None):
      pivotVal2 = vals2[idx[pivotIndex]]

      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(53:11-60:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(54:11-60:11)
        if   (( CommonTools.__qsortCmp_IIII (vals1[idx[i]],vals2[idx[i]],pivotVal1,pivotVal2) ) < 0):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(54:11-60:11)
    else:
      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(65:11-72:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(66:11-72:11)
        if   (vals1[idx[i]] < pivotVal1):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(66:11-72:11)
    ( CommonTools.__qsortSwap__3LLL (idx,storeIndex,(last - 1l)) )
    return storeIndex
  @staticmethod
  def _matchargs_qsortPartition__3L_3L_3LLLL(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    if not isinstance(args[5],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(83:16-125:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortPartition([int64],[int64],[int64],long,long,long)")
  def __qsortPartition__3L_3L_3LLLL(idx,vals1,vals2,first,last,pivotIndex):
    pivotVal1 = vals1[idx[pivotIndex]]

    storeIndex = first

    if   (vals2 != None):
      pivotVal2 = vals2[idx[pivotIndex]]

      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(99:11-106:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(100:11-106:11)
        if   (( CommonTools.__qsortCmp_LLLL (vals1[idx[i]],vals2[idx[i]],pivotVal1,pivotVal2) ) < 0):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(100:11-106:11)
    else:
      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(111:11-118:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(112:11-118:11)
        if   (vals1[idx[i]] < pivotVal1):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(112:11-118:11)
    ( CommonTools.__qsortSwap__3LLL (idx,storeIndex,(last - 1l)) )
    return storeIndex
  @staticmethod
  def _matchargs_argQsortNR__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(130:18-164:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsortNR([int64],[int32],[int32],long,long)")
  def _argQsortNR__3L_3I_3ILL(idx,vals1,vals2,first,last):
    stack = ([ 0l for _autovar_508 in xrange((2 * int(len(idx)))) ])

    stackBase = 0

    if   (int(len(idx)) > 0):
      stack[stackBase] = first
      stackBase += 1
      stack[stackBase] = last
      stackBase += 1
    # src/fusion/CommonUtil.mbi(141:9-163:9)
    while (stackBase > 0):
      stackBase = (stackBase - 1)
      f = stack[stackBase]

      stackBase = (stackBase - 1)
      l = stack[stackBase]

      if   (l > f):
        pivotIndex = (f + ((l - f) / 2))

        pivotNewIndex = ( CommonTools.__qsortPartition__3L_3I_3ILLL (idx,vals1,vals2,f,l,pivotIndex) )

        stack[stackBase] = f
        stackBase += 1
        stack[stackBase] = (pivotNewIndex - 1)
        stackBase += 1
        stack[stackBase] = (pivotNewIndex + 1)
        stackBase += 1
        stack[stackBase] = l
        stackBase += 1
  @staticmethod
  def _matchargs_argQsort_1prv__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(169:16-177:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort_prv([int64],[int32],[int32],long,long)")
  def __argQsort_1prv__3L_3I_3ILL(idx,vals1,vals2,first,last):
    if   (first < last):
      pivotIndex = (first + ((last - first) / 2))

      pivotNewIndex = ( CommonTools.__qsortPartition__3L_3I_3ILLL (idx,vals1,vals2,first,last,pivotIndex) )

      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,first,pivotNewIndex) )
      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,(pivotNewIndex + 1),last) )
  @staticmethod
  def _matchargs_argQsort_1prv__3L_3L_3LLL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(181:16-189:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort_prv([int64],[int64],[int64],long,long)")
  def __argQsort_1prv__3L_3L_3LLL(idx,vals1,vals2,first,last):
    if   (first < last):
      pivotIndex = (first + ((last - first) / 2))

      pivotNewIndex = ( CommonTools.__qsortPartition__3L_3L_3LLLL (idx,vals1,vals2,first,last,pivotIndex) )

      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,first,pivotNewIndex) )
      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,(pivotNewIndex + 1),last) )
  @staticmethod
  def _matchargs_argQsort__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(193:15-213:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort([int64],[int32],[int32],long,long)")
  def _argQsort__3L_3I_3ILL(idx,vals1,vals2,first,last):
    sorted = True

    if   ((first + 1) < last):
      if   (vals2 != None):
        # src/fusion/CommonUtil.mbi(199:11-204:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (( CommonTools.__qsortCmp_IIII (vals1[idx[i]],vals2[idx[i]],vals1[idx[(i - 1)]],vals2[idx[(i - 1)]]) ) > 0):
            sorted = False
          i += 1
      else:
        # src/fusion/CommonUtil.mbi(206:11-210:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (vals1[idx[i]] > vals1[idx[(i - 1)]]):
            sorted = False
          i += 1
    if   (not sorted):
      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,first,last) )
  @staticmethod
  def _matchargs_argQsort__3L_3L_3LLL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(216:15-236:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort([int64],[int64],[int64],long,long)")
  def _argQsort__3L_3L_3LLL(idx,vals1,vals2,first,last):
    sorted = True

    if   ((first + 1) < last):
      if   (vals2 != None):
        # src/fusion/CommonUtil.mbi(222:11-227:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (( CommonTools.__qsortCmp_LLLL (vals1[idx[i]],vals2[idx[i]],vals1[idx[(i - 1)]],vals2[idx[(i - 1)]]) ) > 0):
            sorted = False
          i += 1
      else:
        # src/fusion/CommonUtil.mbi(229:11-233:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (vals1[idx[i]] > vals1[idx[(i - 1)]]):
            sorted = False
          i += 1
    if   (not sorted):
      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,first,last) )
  @staticmethod
  def _matchargs_mergeInto__3I_3I_3IIII(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(258:16-284:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mergeInto([int32],[int32],[int32],int,int,int)")
  def __mergeInto__3I_3I_3IIII(src,tgt,vals,si0,si1,si2):
    if   (si2 > int(len(src))):
      si2 = int(len(src))
    if   (si1 > si2):
      si1 = si2
    if   (si1 == si2):
      ( Utils.Tools._arraycopy__3II_3III (src,si0,tgt,si0,(si1 - si0)) )
    else:
      i0 = si0

      i1 = si1


      # src/fusion/CommonUtil.mbi(276:11-280:11)
      i = si0
      while ((i0 < si1) and (i1 < si2)):
        if   (vals[src[i0]] < vals[src[i1]]):
          tgt[i] = src[i0]
          i0 += 1
        else:
          tgt[i] = src[i1]
          i1 += 1
        i += 1
      # src/fusion/CommonUtil.mbi(281:11-59)
      while (i0 < si1):
        tgt[i] = src[i0]
        i0 += 1
        i += 1
      # src/fusion/CommonUtil.mbi(282:11-59)
      while (i1 < si2):
        tgt[i] = src[i1]
        i1 += 1
        i += 1
  @staticmethod
  def _matchargs_argMSort__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(298:15-322:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argMSort([int32],[int32])")
  def _argMSort__3I_3I(idx,vals):
    temp = ([ 0 for _autovar_509 in xrange(int(len(idx))) ])

    alt = False

    # src/fusion/CommonUtil.mbi(302:9-317:9)
    intvlen = 1

    while (intvlen < int(len(idx))):
      alt = (not alt)
      # src/fusion/CommonUtil.mbi(305:11-316:11)
      i = 0

      while (i < int(len(idx))):
        if   alt:
          ( CommonTools.__mergeInto__3I_3I_3IIII (idx,temp,vals,i,(i + intvlen),(i + (2 * intvlen))) )
        else:
          ( CommonTools.__mergeInto__3I_3I_3IIII (temp,idx,vals,i,(i + intvlen),(i + (2 * intvlen))) )
        i = (i + (intvlen * 2))
      intvlen = (intvlen * 2)
    if   alt:
      ( Utils.Tools._arraycopy__3II_3III (temp,0,idx,0,int(len(idx))) )
  @staticmethod
  def _matchargs_tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(353:15-458:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("tripletSort([int32],[int32],[double],[[int32]],[[int32]],[[double]],long,int,int)")
  def _tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    cols = ([ 0 for _autovar_510 in xrange(nelm) ])

    cptrb = ([ 0l for _autovar_511 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(376:9-75)
    for i in xrange(0l,nelm):
      # { @ src/fusion/CommonUtil.mbi(376:32-75)
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      # } @ src/fusion/CommonUtil.mbi(376:32-75)
    # src/fusion/CommonUtil.mbi(377:9-69)
    for i in xrange(1,dimj):
      # { @ src/fusion/CommonUtil.mbi(377:31-69)
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      # } @ src/fusion/CommonUtil.mbi(377:31-69)
    # src/fusion/CommonUtil.mbi(378:9-383:9)
    for i in xrange(0,int(nelm)):
      # { @ src/fusion/CommonUtil.mbi(379:9-383:9)
      cidx = subj[i]

      cols[cptrb[(cidx + 1)]] = i
      cptrb[(cidx + 1)] = (cptrb[(cidx + 1)] + 1)
      # } @ src/fusion/CommonUtil.mbi(379:9-383:9)
    rptrb = ([ 0l for _autovar_512 in xrange((dimi + 2)) ])

    rows = ([ 0 for _autovar_513 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(389:9-82)
    i = 0

    while (i < nelm):
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(390:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(391:9-399:9)
    j = 0

    while (j < dimj):
      # src/fusion/CommonUtil.mbi(393:11-398:11)
      i = cptrb[j]

      while (i < cptrb[(j + 1)]):
        ridx = subi[cols[i]]

        rows[rptrb[(ridx + 1)]] = cols[i]
        rptrb[(ridx + 1)] = (rptrb[(ridx + 1)] + 1)
        i += 1
      j += 1
    nunique = 1

    # { @ src/fusion/CommonUtil.mbi(405:9-421:9)
    si = subi[rows[0]]

    sj = subj[rows[0]]

    # src/fusion/CommonUtil.mbi(409:11-420:11)
    i = 1

    while (i < nelm):
      idx = rows[i]

      if   ((si != subi[idx]) or (sj != subj[idx])):
        si = subi[idx]
        sj = subj[idx]
        nunique += 1
      i += 1
    # } @ src/fusion/CommonUtil.mbi(405:9-421:9)
    tsubi = ([ 0 for _autovar_514 in xrange(nunique) ])

    tsubj = ([ 0 for _autovar_515 in xrange(nunique) ])

    tval = ([ 0.0 for _autovar_516 in xrange(nunique) ])

    # { @ src/fusion/CommonUtil.mbi(428:9-433:9)
    idx = rows[0]

    tsubi[0] = subi[idx]
    tsubj[0] = subj[idx]
    tval[0] = val[idx]
    # } @ src/fusion/CommonUtil.mbi(428:9-433:9)
    di = 1

    # src/fusion/CommonUtil.mbi(436:9-453:9)
    i = 1

    while (i < nelm):
      idx = rows[i]

      if   ((tsubi[(di - 1)] == subi[idx]) and (tsubj[(di - 1)] == subj[idx])):
        tval[(di - 1)] = (tval[(di - 1)] + val[idx])
      else:
        tsubi[di] = subi[idx]
        tsubj[di] = subj[idx]
        tval[di] = val[idx]
        di += 1
      i += 1
    tsubi_[0] = tsubi
    tsubj_[0] = tsubj
    tval_[0] = tval
  @staticmethod
  def _matchargs_transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(491:15-535:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("transposeTriplets([int32],[int32],[double],[[int32]],[[int32]],[[double]],long,int,int)")
  def _transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    rptrb = ([ 0l for _autovar_517 in xrange((dimi + 2)) ])

    cptrb = ([ 0l for _autovar_518 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(505:9-509:9)
    i = 0l

    while (i < nelm):
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(511:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(512:9-78)
    i = 1

    while (i < dimj):
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      i += 1
    tsubi = ([ 0 for _autovar_519 in xrange(nelm) ])

    tsubj = ([ 0 for _autovar_520 in xrange(nelm) ])

    tval = ([ 0.0 for _autovar_521 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(518:9-530:9)
    i = 0

    while (i < dimi):
      # src/fusion/CommonUtil.mbi(520:11-529:11)
      k = rptrb[i]

      while (k < rptrb[(i + 1)]):
        j = subj[k]

        cidx = cptrb[j]

        tsubi[cidx] = i
        tsubj[cidx] = j
        tval[cidx] = val[k]
        cptrb[j] = (cidx + 1)
        k += 1
      i += 1
    tsubi_[0] = tsubj
    tsubj_[0] = tsubi
    tval_[0] = tval
  @staticmethod
  def _matchargs_transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_long(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_long(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(539:15-583:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("transposeTriplets([int32],[int32],[double],[[int64]],[[int64]],[[double]],long,int,int)")
  def _transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    rptrb = ([ 0l for _autovar_522 in xrange((dimi + 2)) ])

    cptrb = ([ 0l for _autovar_523 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(553:9-557:9)
    i = 0l

    while (i < nelm):
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(559:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(560:9-78)
    i = 1

    while (i < dimj):
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      i += 1
    tsubi = ([ 0l for _autovar_524 in xrange(nelm) ])

    tsubj = ([ 0l for _autovar_525 in xrange(nelm) ])

    tval = ([ 0.0 for _autovar_526 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(566:9-578:9)
    i = 0

    while (i < dimi):
      # src/fusion/CommonUtil.mbi(568:11-577:11)
      k = rptrb[i]

      while (k < rptrb[(i + 1)]):
        j = subj[k]

        cidx = cptrb[j]

        tsubi[cidx] = long(i)
        tsubj[cidx] = long(j)
        tval[cidx] = val[k]
        cptrb[j] = (cidx + 1)
        k += 1
      i += 1
    tsubi_[0] = tsubj
    tsubj_[0] = tsubi
    tval_[0] = tval
  @staticmethod
  def _matchargs_ndIncr__3I_3I_3I(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(586:15-594:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("ndIncr([int32],[int32],[int32])")
  def _ndIncr__3I_3I_3I(ndidx,first,last):
    i = (int(len(ndidx)) - 1)

    ndidx[i] += 1
    # src/fusion/CommonUtil.mbi(589:9-593:9)
    while ((i > 0) and (ndidx[i] >= last[i])):
      ndidx[i] = first[i]
      ndidx[(i - 1)] += 1
  @staticmethod
  @_cliptrace
  def argMSort(*args):
    if   CommonTools._matchargs_argMSort__3I_3I(args):
      return CommonTools._argMSort__3I_3I(*args)
    else:
      argtypestr = "argMSort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\targMSort([int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def tripletSort(*args):
    if   CommonTools._matchargs_tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
      return CommonTools._tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(*args)
    else:
      argtypestr = "tripletSort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(9,"\ttripletSort([int32],[int32],[double],[[int32]],[[int32]],[[double]],long,int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def argQsort(*args):
    if   CommonTools._matchargs_argQsort__3L_3I_3ILL(args):
      return CommonTools._argQsort__3L_3I_3ILL(*args)
    elif CommonTools._matchargs_argQsort__3L_3L_3LLL(args):
      return CommonTools._argQsort__3L_3L_3LLL(*args)
    else:
      argtypestr = "argQsort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(5,"\targQsort([int64],[int32],[int32],long,long)"),(5,"\targQsort([int64],[int64],[int64],long,long)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def ndIncr(*args):
    if   CommonTools._matchargs_ndIncr__3I_3I_3I(args):
      return CommonTools._ndIncr__3I_3I_3I(*args)
    else:
      argtypestr = "ndIncr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tndIncr([int32],[int32],[int32])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def transposeTriplets(*args):
    if   CommonTools._matchargs_transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
      return CommonTools._transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(*args)
    elif CommonTools._matchargs_transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(args):
      return CommonTools._transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(*args)
    else:
      argtypestr = "transposeTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(9,"\ttransposeTriplets([int32],[int32],[double],[[int32]],[[int32]],[[double]],long,int,int)"),(9,"\ttransposeTriplets([int32],[int32],[double],[[int64]],[[int64]],[[double]],long,int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(210:12-216:5)
class FatalError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)

## origin: src/fusion/Model.mbi(2186:12-2505:5)
class SolutionStruct:
  @staticmethod
  def _matchargs_constructor_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,int,int)")
  def __constructor_IIII(self,numvar,numcon,numcone,numbarvar):
    self.pobj = 0.0
    self.dobj = 0.0
    self.pstatus = SolutionStatus.Unknown
    self.dstatus = SolutionStatus.Unknown
    self.sol_numvar = numvar
    self.sol_numcon = numcon
    self.sol_numcone = numcone
    self.sol_numbarvar = numbarvar
    self.slx = None
    self.sux = None
    self.xx = None
    self.slc = None
    self.suc = None
    self.y = None
    self.xc = None
    self.snx = None
    self.barx = None
    self.bars = None
    if   (numvar > 0):
      self.slx = ([ 0.0 for _autovar_527 in xrange(numvar) ])
      self.sux = ([ 0.0 for _autovar_528 in xrange(numvar) ])
      self.xx = ([ 0.0 for _autovar_529 in xrange(numvar) ])
    if   (numbarvar > 0):
      self.barx = ([ 0.0 for _autovar_530 in xrange(numbarvar) ])
      self.bars = ([ 0.0 for _autovar_531 in xrange(numbarvar) ])
    if   (numcon > 0):
      self.slc = ([ 0.0 for _autovar_532 in xrange(numcon) ])
      self.suc = ([ 0.0 for _autovar_533 in xrange(numcon) ])
      self.y = ([ 0.0 for _autovar_534 in xrange(numcon) ])
      self.xc = ([ 0.0 for _autovar_535 in xrange(numcon) ])
    if   (numcone > 0):
      self.snx = ([ 0.0 for _autovar_536 in xrange(numvar) ])
  def __init__(self,*args):
    #self.sol_numcon = None

    #self.sol_numvar = None

    #self.sol_numcone = None

    #self.sol_numbarvar = None

    #self.pstatus = None

    #self.dstatus = None

    #self.pobj = None

    #self.dobj = None

    #self.xc = None

    #self.xx = None

    #self.slc = None

    #self.suc = None

    #self.y = None

    #self.barx = None

    #self.bars = None

    #self.slx = None

    #self.sux = None

    #self.snx = None

    self.__constructor_IIII(*args)
  @staticmethod
  def _matchargs_isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionStatus): return False
    if not isinstance(args[1],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2212:16-2242:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isAcceptable(mosek.fusion.SolutionStatus,mosek.fusion.AccSolutionStatus)")
  def __isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self,stat,accstat):
    if   (accstat == AccSolutionStatus.Anything):
      return True
    elif (accstat == AccSolutionStatus.Optimal):
      return (stat == SolutionStatus.Optimal)
    elif (accstat == AccSolutionStatus.NearOptimal):
      return ((stat == SolutionStatus.Optimal) or (stat == SolutionStatus.NearOptimal))
    elif (accstat == AccSolutionStatus.Feasible):
      return (((stat == SolutionStatus.Optimal) or (stat == SolutionStatus.NearOptimal)) or (stat == SolutionStatus.Feasible))
    elif (accstat == AccSolutionStatus.Certificate):
      return (stat == SolutionStatus.Certificate)
    return False
  @staticmethod
  def _matchargs_isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2245:15-2247:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isPrimalAcceptable(mosek.fusion.AccSolutionStatus)")
  def _isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self,acceptable_sol):
    return ( self.__isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self.pstatus,acceptable_sol) )
  @staticmethod
  def _matchargs_isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2250:15-2252:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isDualAcceptable(mosek.fusion.AccSolutionStatus)")
  def _isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self,acceptable_sol):
    return ( self.__isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self.dstatus,acceptable_sol) )
  @staticmethod
  def _matchargs_resize_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  # origin: src/fusion/Model.mbi(2255:15-2451:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("resize(int,int,int,int)")
  def _resize_IIII(self,numvar,numcon,numcone,numbarvar):
    if   (numbarvar < 0):
      pass
    elif (numbarvar <= self.sol_numbarvar):
      self.sol_numbarvar = numbarvar
    elif (numvar <= int(len(self.barx))):
      # src/fusion/Model.mbi(2270:13-2274:13)
      for i in xrange(self.sol_numvar,numvar):
        # { @ src/fusion/Model.mbi(2271:13-2274:13)
        self.barx[i] = None
        self.bars[i] = None
        # } @ src/fusion/Model.mbi(2271:13-2274:13)
    else:

      if   ((self.sol_numbarvar * 2) > (numbarvar + 100)):
        newsize = (self.sol_numbarvar * 2)
      else:
        newsize = (numbarvar + 100)
      newbarx = ([ 0.0 for _autovar_537 in xrange(newsize) ])

      # src/fusion/Model.mbi(2284:15-62)
      for i in xrange(0,int(len(self.barx))):
        newbarx[i] = self.barx[i]
      self.barx = newbarx
      newbars = ([ 0.0 for _autovar_538 in xrange(newsize) ])

      # src/fusion/Model.mbi(2288:15-62)
      for i in xrange(0,int(len(self.bars))):
        newbars[i] = self.bars[i]
      self.bars = newbars
      self.sol_numbarvar = numbarvar
    if   (numvar < 0):
      pass
    elif (numvar <= self.sol_numvar):
      self.sol_numvar = numvar
    elif (numvar <= int(len(self.xx))):
      # src/fusion/Model.mbi(2307:15-2312:15)
      i = self.sol_numvar

      while (i < numvar):
        self.slx[i] = 0.0
        self.sux[i] = 0.0
        self.xx[i] = 0.0
        i += 1
      self.sol_numvar = numvar
    else:

      if   ((self.sol_numvar * 2) > (numvar + 100)):
        newsize = (self.sol_numvar * 2)
      else:
        newsize = (numvar + 100)
      newslx = ([ 0.0 for _autovar_539 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.slx,0,newslx,0,int(len(self.slx))) )
      self.slx = newslx
      newsux = ([ 0.0 for _autovar_540 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.sux,0,newsux,0,int(len(self.sux))) )
      self.sux = newsux
      newxx = ([ 0.0 for _autovar_541 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.xx,0,newxx,0,int(len(self.xx))) )
      self.xx = newxx
      # src/fusion/Model.mbi(2337:15-2343:15)
      i = self.sol_numvar

      while (i < numvar):
        self.slx[i] = 0.0
        self.sux[i] = 0.0
        self.xx[i] = 0.0
        i += 1
      self.sol_numvar = numvar
    if   (numcon < 0):
      pass
    elif (numcon <= self.sol_numcon):
      self.sol_numcon = numcon
    elif (numcon <= int(len(self.xx))):
      # src/fusion/Model.mbi(2360:15-2367:15)
      i = self.sol_numcon

      while (i < numcon):
        self.slc[i] = 0.0
        self.suc[i] = 0.0
        self.xc[i] = 0.0
        self.y[i] = 0.0
        i += 1
      self.sol_numcon = numcon
    else:

      if   ((self.sol_numcon * 2) > (numcon + 100)):
        newsize = (self.sol_numcon * 2)
      else:
        newsize = (numcon + 100)
      newslc = ([ 0.0 for _autovar_542 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.slc,0,newslc,0,int(len(self.slc))) )
      self.slc = newslc
      newsuc = ([ 0.0 for _autovar_543 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.suc,0,newsuc,0,int(len(self.suc))) )
      self.suc = newsuc
      newxc = ([ 0.0 for _autovar_544 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.xc,0,newxc,0,int(len(self.xc))) )
      self.xc = newxc
      newy = ([ 0.0 for _autovar_545 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.y,0,newy,0,int(len(self.y))) )
      self.y = newy
      # src/fusion/Model.mbi(2396:15-2403:15)
      i = self.sol_numcon

      while (i < numcon):
        self.slc[i] = 0.0
        self.suc[i] = 0.0
        self.xc[i] = 0.0
        self.y[i] = 0.0
        i += 1
      self.sol_numcon = numcon
    if   (numcone < 0):
      pass
    elif (numcone <= self.sol_numcone):
      self.sol_numcone = numcone
    elif (numcone <= int(len(self.xx))):
      # src/fusion/Model.mbi(2421:13-2425:13)
      i = self.sol_numcone

      while (i < numcone):
        self.snx[i] = 0.0
        i += 1
      self.sol_numcone = numcone
    else:

      if   ((self.sol_numcone * 2) > (numcone + 100)):
        newsize = (self.sol_numcone * 2)
      else:
        newsize = (numcone + 100)
      newsnx = ([ 0.0 for _autovar_546 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.snx,0,newsnx,0,int(len(self.snx))) )
      self.snx = newsnx
      # src/fusion/Model.mbi(2443:15-2447:15)
      i = self.sol_numcone

      while (i < numcone):
        self.snx[i] = 0.0
        i += 1
      self.sol_numcone = numcone
  @_cliptrace
  def isPrimalAcceptable(self,*args):
    if   SolutionStruct._matchargs_isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
      return SolutionStruct._isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self,*args)
    else:
      argtypestr = "isPrimalAcceptable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tisPrimalAcceptable(mosek.fusion.AccSolutionStatus)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def isDualAcceptable(self,*args):
    if   SolutionStruct._matchargs_isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
      return SolutionStruct._isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self,*args)
    else:
      argtypestr = "isDualAcceptable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tisDualAcceptable(mosek.fusion.AccSolutionStatus)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def resize(self,*args):
    if   SolutionStruct._matchargs_resize_IIII(args):
      return SolutionStruct._resize_IIII(self,*args)
    else:
      argtypestr = "resize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tresize(int,int,int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(7:12-9:5)
class FusionException(Utils.FusionException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.Utils.FusionException.__init__(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   Utils.FusionException._matchargs_toString_(args):
      return Utils.FusionException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(171:12-182:5)
class SolutionError(FusionException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionException._FusionException__constructor_S(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__()")
  def __constructor_(self):
    mosek.fusion.FusionException._FusionException__constructor_S(self,"Solution is invalid or undefined")
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @_cliptrace
  def toString(self,*args):
    if   Utils.FusionException._matchargs_toString_(args):
      return Utils.FusionException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/Errors.mbi(197:12-207:5)
class UnexpectedError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Utils_FusionException_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Utils.FusionException): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Utils.FusionException)")
  def __constructor_Omosek_fusion_Utils_FusionException_2(self,e):
    Exception.__init__(self,( e._toString_() ))
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_Omosek_fusion_Utils_FusionException_2(args):
      self.__constructor_Omosek_fusion_Utils_FusionException_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")

## origin: src/fusion/Model.mbi(127:12-2171:5)
class Model(BaseModel):
  @staticmethod
  def _matchargs_constructor_SS(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring,basestring)")
  def __constructor_SS(self,name,licfile):
    mosek.fusion.BaseModel.__init__(self,name,licfile)
    self.__acceptable_sol = AccSolutionStatus.NearOptimal
    self.__solutionptr = SolutionType.Default
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring)")
  def __constructor_S(self,name):
    mosek.fusion.BaseModel.__init__(self,name,None)
    self.__acceptable_sol = AccSolutionStatus.NearOptimal
    self.__solutionptr = SolutionType.Default
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__()")
  def __constructor_(self):
    mosek.fusion.BaseModel.__init__(self,None,None)
    self.__acceptable_sol = AccSolutionStatus.Optimal
    self.__solutionptr = SolutionType.Default
  def __init__(self,*args):
    #self.__acceptable_sol = None

    #self.__solutionptr = None

    if   self._matchargs_constructor_SS(args):
      self.__constructor_SS(*args)
    elif self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(177:15-652:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,name,shp,expr,dom):
    res = None

    size = int(( expr._size_() ))


    if   ((name != None) and ( self._hasConstraint_S(name) )):
      raise mosek.fusion.NameError("Duplicate constraint name")
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    e = ( expr._eval_() )

    varidxs = None

    ptrb = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(218:9-262:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_547 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_548 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_549 in xrange(num) ])
    # src/fusion/Model.mbi(224:11-225:82)
    for i in xrange(0,num):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],long(i),tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
    numscalarvar = 0
    # src/fusion/Model.mbi(228:11-231:22)
    for i in xrange(0,num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_550 in xrange(numscalarvar) ])
    if   (numbarvar == 0):
      varidxs = tmpvaridxs
      ptrb = e.ptrb
      cof = e.cof
    else:
      vari = 0

      varidxs = ([ 0 for _autovar_551 in xrange(numscalarvar) ])
      cof = ([ 0.0 for _autovar_552 in xrange(numscalarvar) ])
      ptrb = ([ 0l for _autovar_553 in xrange(int(len(e.ptrb))) ])
      # src/fusion/Model.mbi(247:13-259:13)
      for i in xrange(0,(int(len(e.ptrb)) - 1)):
        # { @ src/fusion/Model.mbi(248:13-259:13)
        ptrb[i] = long(vari)
        # src/fusion/Model.mbi(250:15-258:15)
        for k in xrange(e.ptrb[i],e.ptrb[(i + 1)]):
          # { @ src/fusion/Model.mbi(251:15-258:15)
          if   (tmpvaridxs[k] >= 0):
            varidxs[vari] = tmpvaridxs[k]
            cof[vari] = e.cof[k]
            vari += 1
          # } @ src/fusion/Model.mbi(251:15-258:15)
        # } @ src/fusion/Model.mbi(248:13-259:13)
      ptrb[(int(len(ptrb)) - 1)] = long(vari)
    # } @ src/fusion/Model.mbi(218:9-262:9)
    lptrb = ( Utils.Tools._arraycopy__3L (ptrb) )

    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      numcon = size

      first = ( self._task_1append_1con_I(numcon) )

      last = (first + numcon)

      if   (name != None):
        sb = mosek.fusion.Utils.StringBuffer()

        # src/fusion/Model.mbi(283:13-287:13)
        for i in xrange(0,numcon):
          # { @ src/fusion/Model.mbi(284:13-287:13)
          ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
          ( self._task_1con_1name_IS((i + first),( sb._toString_() )) )
          # } @ src/fusion/Model.mbi(284:13-287:13)
      if   (numscalarvar > 0):
        ( self._task_1putarowslice_II_3L_3I_3F(first,last,ptrb,varidxs,cof) )
      barsubi = None

      barsubj = None

      barmatidx = None

      numuniquebaraij = 0

      if   (numbarvar > 0):
        barsubi_ = ([ 0 for _autovar_554 in xrange((int(len(e.ptrb)) - 1)) ])

        barsubj_ = ([ 0 for _autovar_555 in xrange((int(len(e.ptrb)) - 1)) ])

        barmatidx_ = ([ 0 for _autovar_556 in xrange((int(len(e.ptrb)) - 1)) ])

        # src/fusion/Model.mbi(313:13-427:13)
        for i in xrange(0,(int(len(e.ptrb)) - 1)):
          # { @ src/fusion/Model.mbi(314:13-427:13)
          numbarinz = 0l

          # src/fusion/Model.mbi(320:15-324:19)
          for k in xrange(e.ptrb[i],e.ptrb[(i + 1)]):
            if   (tmpvaridxs[k] < 0):
              numbarinz += 1
          if   (numbarinz == 0):
            barsubi_[i] = ([ 0 for _autovar_557 in xrange(0) ])
            barsubj_[i] = ([ 0 for _autovar_558 in xrange(0) ])
            barmatidx_[i] = ([ 0 for _autovar_559 in xrange(0) ])
          else:
            bariperm = ([ 0l for _autovar_560 in xrange(numbarinz) ])

            # { @ src/fusion/Model.mbi(333:17-341:17)
            barvari = 0

            # src/fusion/Model.mbi(335:19-342:20)
            for k in xrange(e.ptrb[i],e.ptrb[(i + 1)]):
              if   (tmpvaridxs[k] < 0):
                bariperm[barvari] = long(k)
                barvari += 1
            # } @ src/fusion/Model.mbi(333:17-341:17)
            ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,long(numbarinz)) )
            numUniqueBarvarCon_i = 1

            # src/fusion/Model.mbi(347:17-352:27)
            for p in xrange(1l,numbarinz):
              if   (tmpvaridxs[bariperm[p]] != tmpvaridxs[bariperm[(p - 1)]]):
                numUniqueBarvarCon_i += 1
            barsubi_[i] = ([ 0 for _autovar_561 in xrange(numUniqueBarvarCon_i) ])
            barsubj_[i] = ([ 0 for _autovar_562 in xrange(numUniqueBarvarCon_i) ])
            barmatidx_[i] = ([ 0 for _autovar_563 in xrange(numUniqueBarvarCon_i) ])
            # { @ src/fusion/Model.mbi(355:17-425:17)
            conivarnum = 0

            barvari = 0

            # src/fusion/Model.mbi(358:19-424:19)
            while (barvari < numbarinz):
              barptrb = barvari

              barvari += 1
              # src/fusion/Model.mbi(362:21-127)
              while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
                barvari += 1
              numbarvarijnz = (barvari - barptrb)

              ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
              numuniquenz = 1

              # src/fusion/Model.mbi(372:21-379:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(373:21-379:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  numuniquenz += 1
                # } @ src/fusion/Model.mbi(373:21-379:21)
              l = 0

              barvarijsubi = ([ 0 for _autovar_564 in xrange(numuniquenz) ])

              barvarijsubj = ([ 0 for _autovar_565 in xrange(numuniquenz) ])

              barvarijcof = ([ 0.0 for _autovar_566 in xrange(numuniquenz) ])

              barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
              barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
              if   (barvarijsubi[0] == barvarijsubj[0]):
                barvarijcof[0] = e.cof[bariperm[barptrb]]
              else:
                barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
              # src/fusion/Model.mbi(396:21-411:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(397:21-411:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  l += 1
                  barvarijsubi[l] = tmpbarvarsubi[idx]
                  barvarijsubj[l] = tmpbarvarsubj[idx]
                if   (barvarijsubi[l] == barvarijsubj[l]):
                  barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
                else:
                  barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
                # } @ src/fusion/Model.mbi(397:21-411:21)
              baraj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

              baraijdim = ( self._task_1barvardim_I(baraj) )

              baraijidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(baraijdim,barvarijsubi,barvarijsubj,barvarijcof) )

              ( self._task_1putbaraij_III((i + first),baraj,baraijidx) )
              barsubi_[i][conivarnum] = (i + first)
              barsubj_[i][conivarnum] = baraj
              barmatidx_[i][conivarnum] = baraijidx
              conivarnum += 1
              numuniquebaraij += 1
            # } @ src/fusion/Model.mbi(355:17-425:17)
          # } @ src/fusion/Model.mbi(314:13-427:13)
        barsubi = ([ 0 for _autovar_567 in xrange(numuniquebaraij) ])
        barsubj = ([ 0 for _autovar_568 in xrange(numuniquebaraij) ])
        barmatidx = ([ 0 for _autovar_569 in xrange(numuniquebaraij) ])
        # { @ src/fusion/Model.mbi(434:13-448:13)
        k = 0

        # src/fusion/Model.mbi(436:15-449:16)
        for i in xrange(0,(int(len(e.ptrb)) - 1)):
          if   (barsubi_[i] != None):
            num = int(len(barsubi_[i]))

            ( Utils.Tools._arraycopy__3II_3III (barsubi_[i],0,barsubi,k,num) )
            ( Utils.Tools._arraycopy__3II_3III (barsubj_[i],0,barsubj,k,num) )
            # src/fusion/Model.mbi(443:19-444:65)
            for l in xrange(0,int(len(barmatidx_[i]))):
              barmatidx[(k + l)] = ([ barmatidx_[i][l]])
            k = (k + num)
        # } @ src/fusion/Model.mbi(434:13-448:13)
      nativeindexes = ( Utils.Tools._range_II (first,last) )

      rhs = ([ 0.0 for _autovar_570 in xrange(int(len(nativeindexes))) ])

      # src/fusion/Model.mbi(456:11-459:11)
      i = 0

      while (i < int(len(rhs))):
        rhs[i] = ( dom._get_1rhs_1item_I(i) )
        i += 1
      if   ((e.bfix != None) and (rhs != None)):
        # src/fusion/Model.mbi(463:13-466:13)
        i = 0

        while (i < int(len(rhs))):
          rhs[i] = (rhs[i] - e.bfix[i])
          i += 1
      key = dom._key

      if   ((((key == RelationKey.IsFree) or (key == RelationKey.LessThan)) or (key == RelationKey.GreaterThan)) or (key == RelationKey.EqualsTo)):
        if   (key == RelationKey.IsFree):
          ( self._task_1con_1putboundslice_1fr_II(first,last) )
        elif (key == RelationKey.LessThan):
          ( self._task_1con_1putboundslice_1up_II_3F(first,last,rhs) )
        elif (key == RelationKey.GreaterThan):
          ( self._task_1con_1putboundslice_1lo_II_3F(first,last,rhs) )
        else:
          ( self._task_1con_1putboundslice_1fx_II_3F(first,last,rhs) )
        res = mosek.fusion.LinearConstraint(self,name,dom,shape,nativeindexes,lptrb,varidxs,cof,e.bfix,barsubi,barsubj,barmatidx)
      elif ((key == RelationKey.InQCone) or (key == RelationKey.InRotatedQCone)):


        if   (shape.nd == 2):
          numcone = ( shape._dim_I(0) )
          conesize = ( shape._dim_I(1) )
        else:
          numcone = 1
          conesize = int(shape._size)
        numslack = (conesize * numcone)

        b = ([ 0.0 for _autovar_571 in xrange(numslack) ])

        if   (e.bfix != None):
          # src/fusion/Model.mbi(507:15-63)
          for i in xrange(0,numslack):
            # { @ src/fusion/Model.mbi(507:41-63)
            b[i] = (- e.bfix[i])
            # } @ src/fusion/Model.mbi(507:41-63)
        ( self._task_1con_1putboundslice_1fx_II_3F(first,last,b) )
        firstslack = ( self._task_1append_1var_I(numslack) )

        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(516:15-520:15)
          for i in xrange(0,numslack):
            # { @ src/fusion/Model.mbi(517:15-520:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("].coneslack") )
            ( self._task_1var_1name_IS((i + firstslack),( sb._toString_() )) )
            # } @ src/fusion/Model.mbi(517:15-520:15)
        lastslack = (firstslack + numslack)

        ( self._task_1putaijlist__3I_3I_3FL(( Utils.Tools._range_II (first,last) ),( Utils.Tools._range_II (firstslack,lastslack) ),( Utils.Tools._makevector_FI ((- 1.0),numslack) ),long(numslack)) )
        ( self._task_1var_1putboundslice_1fr_II(firstslack,lastslack) )

        if   (dom._key == RelationKey.InQCone):
          firstcone = ( self._task_1append_1quadcone_III(conesize,firstslack,numcone) )
        else:
          firstcone = ( self._task_1append_1rquadcone_III(conesize,firstslack,numcone) )
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(541:15-545:15)
          for i in xrange(0,numcone):
            # { @ src/fusion/Model.mbi(542:15-545:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
            ( self._task_1cone_1name_IS((firstcone + i),( sb._toString_() )) )
            # } @ src/fusion/Model.mbi(542:15-545:15)
        res = mosek.fusion.ConicConstraint(self,name,shape,( Utils.Tools._range_II (first,last) ),firstslack,lastslack,conesize,firstcone,numcone,lptrb,varidxs,e.cof,e.bfix,barsubi,barsubj,barmatidx)
      elif (key == RelationKey.InPSDCone):
        if   (shape._size == 1):
          res = mosek.fusion.LinearConstraint(self,name,( Domain._greaterThan_F (0.0) ),shape,nativeindexes,lptrb,varidxs,cof,e.bfix,barsubi,barsubj,barmatidx)
        else:


          if   (shape.nd == 2):
            conedim = ( shape._dim_I(0) )
            numcone = 1
            if   (conedim != ( shape._dim_I(1) )):
              raise mosek.fusion.DimensionError("Non-square shape for semidefinite constraint")
          elif (shape.nd == 3):
            conedim = ( shape._dim_I(0) )
            numcone = ( shape._dim_I(1) )
            if   (conedim != ( shape._dim_I(2) )):
              raise mosek.fusion.DimensionError("Non-square shape for semidefinite constraint")
          else:
            raise mosek.fusion.DimensionError("Invalid shape for semidefinite constraint")
          numslack = ((conedim * conedim) * numcone)

          b = ([ 0.0 for _autovar_572 in xrange(numslack) ])

          if   (e.bfix != None):
            # src/fusion/Model.mbi(586:17-587:37)
            for i in xrange(0,numslack):
              b[i] = (- e.bfix[i])
          ( self._task_1con_1putboundslice_1fx_II_3F(first,last,b) )
          coneidx = ( self._task_1append_1barvar_II(conedim,numcone) )

          varid = ( self._numVariables_() )

          if   (name != None):
            sb = mosek.fusion.Utils.StringBuffer()

            # src/fusion/Model.mbi(596:17-597:106)
            i = 0

            while (i < numcone):
              ( self._task_1barvar_1name_IS((coneidx + i),( ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("].coneslack") )._toString_() )) )
              i += 1
          symmatsubi = ([ 0 for _autovar_573 in xrange(1) ])

          symmatsubj = ([ 0 for _autovar_574 in xrange(1) ])

          symmatcof = ([ 0.0 for _autovar_575 in xrange(1) ])

          # src/fusion/Model.mbi(604:15-630:15)
          for i in xrange(0,conedim):
            # { @ src/fusion/Model.mbi(605:15-630:15)
            symmatsubi[0] = i
            # src/fusion/Model.mbi(607:17-629:17)
            for j in xrange(0,conedim):
              # { @ src/fusion/Model.mbi(608:17-629:17)
              symmatsubj[0] = j
              if   (i == j):
                symmatcof[0] = (- 1.0)
              else:
                symmatcof[0] = (- 0.5)
              barmidx = 0

              if   (i >= j):
                barmidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(conedim,symmatsubi,symmatsubj,symmatcof) )
              else:
                barmidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(conedim,symmatsubj,symmatsubi,symmatcof) )
              # src/fusion/Model.mbi(623:19-628:19)
              for k in xrange(0,numcone):
                # { @ src/fusion/Model.mbi(624:19-628:19)
                ci = ((((k * conedim) * conedim) + (i * conedim)) + j)

                ( self._task_1putbaraij_III((first + ci),(coneidx + k),barmidx) )
                # } @ src/fusion/Model.mbi(624:19-628:19)
              # } @ src/fusion/Model.mbi(608:17-629:17)
            # } @ src/fusion/Model.mbi(605:15-630:15)
          res = mosek.fusion.PSDConstraint(self,name,shape,( Utils.Tools._range_II (first,last) ),conedim,coneidx,numcone,lptrb,varidxs,cof,e.bfix,barsubi,barsubj,barmatidx)
      else:
        raise mosek.fusion.UnexpectedError("Invalid relation type detected")
      ( self._addConstraint_SOmosek_fusion_Constraint_2(name,res) )
      return res
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(671:15-946:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,name,shp,expr,dom):
    res = None

    size = int(( expr._size_() ))


    if   ( self._hasConstraint_S(name) ):
      raise mosek.fusion.NameError("Duplicate constraint name")
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    e = ( expr._eval_() )

    varidxs = None

    ptrb = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(718:9-764:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_576 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_577 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_578 in xrange(num) ])
    # src/fusion/Model.mbi(724:11-725:82)
    i = 0

    while (i < num):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],long(i),tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
      i += 1
    numscalarvar = 0
    # src/fusion/Model.mbi(728:11-731:22)
    i = 0

    while (i < num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
      i += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_579 in xrange(numscalarvar) ])
    if   (numbarvar == 0):
      varidxs = tmpvaridxs
      ptrb = e.ptrb
      cof = e.cof
    else:
      vari = 0

      varidxs = ([ 0 for _autovar_580 in xrange(numscalarvar) ])
      cof = ([ 0.0 for _autovar_581 in xrange(numscalarvar) ])
      ptrb = ([ 0l for _autovar_582 in xrange(int(len(e.ptrb))) ])
      # src/fusion/Model.mbi(749:13-761:13)
      i = 0

      while (i < (int(len(e.ptrb)) - 1)):
        ptrb[i] = long(vari)
        # src/fusion/Model.mbi(752:15-760:15)
        k = e.ptrb[i]

        while (k < e.ptrb[(i + 1)]):
          if   (tmpvaridxs[k] >= 0):
            varidxs[vari] = tmpvaridxs[k]
            cof[vari] = e.cof[k]
            vari += 1
          k += 1
        i += 1
      ptrb[(int(len(ptrb)) - 1)] = long(vari)
    # } @ src/fusion/Model.mbi(718:9-764:9)
    lptrb = ([ 0l for _autovar_583 in xrange(int(len(ptrb))) ])

    # src/fusion/Model.mbi(767:9-768:36)
    i = 0

    while (i < int(len(ptrb))):
      lptrb[i] = long(ptrb[i])
      i += 1
    initial_numvar = ( self._task_1numvar_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      numcon = size

      first = ( self._task_1append_1con_I(numcon) )

      last = (first + numcon)

      if   (name != None):
        sb = mosek.fusion.Utils.StringBuffer()

        # src/fusion/Model.mbi(787:13-791:13)
        i = 0

        while (i < numcon):
          ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
          ( self._task_1con_1name_IS((i + first),( sb._toString_() )) )
          i += 1
      if   (numscalarvar > 0):
        ( self._task_1putarowslice_II_3L_3I_3F(first,last,ptrb,varidxs,cof) )
      barsubi = None

      barsubj = None

      barmatidx = None

      numuniquebaraij = 0

      if   (numbarvar > 0):
        barsubi_ = ([ 0 for _autovar_584 in xrange((int(len(e.ptrb)) - 1)) ])

        barsubj_ = ([ 0 for _autovar_585 in xrange((int(len(e.ptrb)) - 1)) ])

        barmatidx_ = ([ 0 for _autovar_586 in xrange((int(len(e.ptrb)) - 1)) ])

        # src/fusion/Model.mbi(815:13-899:13)
        i = 0

        while (i < (int(len(e.ptrb)) - 1)):
          numbarinz = 0l

          # src/fusion/Model.mbi(818:15-821:19)
          k = e.ptrb[i]

          while (k < e.ptrb[(i + 1)]):
            if   (tmpvaridxs[k] < 0):
              numbarinz += 1
            k += 1
          if   (numbarinz > 0):
            bariperm = ([ 0l for _autovar_587 in xrange(numbarinz) ])

            # { @ src/fusion/Model.mbi(824:17-832:17)
            barvari = 0

            # src/fusion/Model.mbi(826:19-833:20)
            k = e.ptrb[i]

            while (k < e.ptrb[(i + 1)]):
              if   (tmpvaridxs[k] < 0):
                bariperm[barvari] = long(k)
                barvari += 1
              k += 1
            # } @ src/fusion/Model.mbi(824:17-832:17)
            ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,numbarinz) )
            # { @ src/fusion/Model.mbi(836:17-897:17)
            barvari = 0

            # src/fusion/Model.mbi(838:19-896:19)
            while (barvari < numbarinz):
              barptrb = barvari

              barvari += 1
              # src/fusion/Model.mbi(842:21-127)
              while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
                barvari += 1
              numbarvarijnz = (barvari - barptrb)

              ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
              numuniquenz = 1

              # src/fusion/Model.mbi(851:21-858:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(852:21-858:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  numuniquenz += 1
                # } @ src/fusion/Model.mbi(852:21-858:21)
              l = 0

              barvarijsubi = ([ 0 for _autovar_588 in xrange(numuniquenz) ])

              barvarijsubj = ([ 0 for _autovar_589 in xrange(numuniquenz) ])

              barvarijcof = ([ 0.0 for _autovar_590 in xrange(numuniquenz) ])

              barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
              barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
              if   (barvarijsubi[0] == barvarijsubj[0]):
                barvarijcof[0] = e.cof[bariperm[barptrb]]
              else:
                barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
              # src/fusion/Model.mbi(873:21-888:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(874:21-888:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  l += 1
                  barvarijsubi[l] = tmpbarvarsubi[idx]
                  barvarijsubj[l] = tmpbarvarsubj[idx]
                if   (barvarijsubi[l] == barvarijsubj[l]):
                  barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
                else:
                  barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
                # } @ src/fusion/Model.mbi(874:21-888:21)
              baraj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

              baraijdim = ( self._task_1barvardim_I(baraj) )

              baraijidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(baraijdim,barvarijsubi,barvarijsubj,barvarijcof) )

              ( self._task_1putbaraij_III((i + first),baraj,baraijidx) )
            # } @ src/fusion/Model.mbi(836:17-897:17)
          i += 1
      bl = ([ 0.0 for _autovar_591 in xrange((int(len(e.ptrb)) - 1)) ])

      bu = ([ 0.0 for _autovar_592 in xrange((int(len(e.ptrb)) - 1)) ])

      if   (e.bfix != None):
        l = (int(len(e.ptrb)) - 1)

        # src/fusion/Model.mbi(913:15-917:15)
        i = 0

        while (i < l):
          bl[i] = (( dom._get_1lb_1item_L(long(i)) ) - e.bfix[i])
          bu[i] = (( dom._get_1ub_1item_L(long(i)) ) - e.bfix[i])
          i += 1
      else:
        l = (int(len(e.ptrb)) - 1)

        # src/fusion/Model.mbi(922:13-926:13)
        i = 0

        while (i < l):
          bl[i] = ( dom._get_1lb_1item_L(long(i)) )
          bu[i] = ( dom._get_1ub_1item_L(long(i)) )
          i += 1
      nativeindexes = ( Utils.Tools._range_II (first,last) )

      ( self._task_1con_1putboundslice_1ra_II_3F_3F(first,last,bl,bu) )
      res = mosek.fusion.RangedConstraint(self,name,shape,dom,nativeindexes,lptrb,varidxs,cof,e.bfix)
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addConstraint_SOmosek_fusion_Constraint_2(name,res) )
    return res
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(954:15-960:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,name,shape,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(968:15-974:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,name,shape,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(982:15-987:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(self,name,expr,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,expr._shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(995:15-1000:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(self,name,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,v.shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1008:15-1013:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,name,expr,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,expr._shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1021:15-1026:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,name,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,v.shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1035:15-1040:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,shape,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1048:15-1053:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,shape,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1061:15-1065:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,expr,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,expr._shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1073:15-1077:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,v.shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1085:15-1089:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,expr,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,expr._shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1097:15-1101:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,v,dom):
    return ( self._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,v.shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    if not isinstance(args[4],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1106:16-1295:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain,bool)")
  def __variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(self,name,shp,dom,idom,sparse):
    res = None


    if   ( self._hasVariable_S(name) ):
      raise mosek.fusion.NameError("Duplicate variable name")
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      nativeindexes = None

      key = dom._key

      if   ((((key == RelationKey.IsFree) or (key == RelationKey.LessThan)) or (key == RelationKey.GreaterThan)) or (key == RelationKey.EqualsTo)):
        numvar = int(shape._size)

        if   (not sparse):
          first = ( self._task_1append_1var_I(numvar) )

          if   (key == RelationKey.IsFree):
            ( self._task_1var_1putboundslice_1fr_II(first,(first + numvar)) )
          else:
            bnds = ([ 0.0 for _autovar_593 in xrange(numvar) ])

            # src/fusion/Model.mbi(1155:17-1156:55)
            for i in xrange(0,numvar):
              bnds[i] = ( dom._get_1rhs_1item_L(long(i)) )
            if   (key == RelationKey.LessThan):
              ( self._task_1var_1putboundslice_1up_II_3F(first,(first + numvar),bnds) )
            elif (key == RelationKey.GreaterThan):
              ( self._task_1var_1putboundslice_1lo_II_3F(first,(first + numvar),bnds) )
            elif (key == RelationKey.EqualsTo):
              ( self._task_1var_1putboundslice_1fx_II_3F(first,(first + numvar),bnds) )
          nativeindexes = ([ 0 for _autovar_594 in xrange(numvar) ])
          # src/fusion/Model.mbi(1166:15-65)
          for i in xrange(0,numvar):
            nativeindexes[i] = (first + i)
          if   (name != None):
            sb = mosek.fusion.Utils.StringBuffer()

            cnt = mosek.fusion.IndexCounter(shape)

            # src/fusion/Model.mbi(1172:17-1179:17)
            for i in xrange(0,int(shape._size)):
              # { @ src/fusion/Model.mbi(1173:17-1179:17)
              ( ( ( sb._clear_() )._a_S(name) )._a__3I(( cnt._getIndex_() )) )
              ( self._task_1var_1name_IS((i + first),( sb._toString_() )) )
              ( sb._toString_() )
              ( cnt._inc_() )
              # } @ src/fusion/Model.mbi(1173:17-1179:17)
        if   (idom == None):
          res = mosek.fusion.LinearVariable(self,name,dom,shape,nativeindexes,( self._numVariables_() ))
        else:
          res = mosek.fusion.IntegerLinearVariable(self,name,dom,shape,nativeindexes,( self._numVariables_() ))
      elif ((key == RelationKey.InQCone) or (key == RelationKey.InRotatedQCone)):


        if   (shape.nd == 2):
          numcone = ( shape._dim_I(0) )
          conesize = ( shape._dim_I(1) )
        else:
          numcone = 1
          conesize = int(shape._size)
        size = int(shape._size)

        first = ( self._task_1append_1var_I(size) )

        last = (first + size)

        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(1210:15-1214:15)
          i = 0

          while (i < size):
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
            ( self._task_1var_1name_IS((i + first),( sb._toString_() )) )
            i += 1
        nativeindexes = ( Utils.Tools._range_II (first,last) )
        ( self._task_1var_1putboundslice_1fr_II(first,last) )
        if   (idom != None):
          ( self._task_1var_1putintlist__3I(( Utils.Tools._range_II (first,last) )) )

        if   (dom._key == RelationKey.InQCone):
          firstcone = ( self._task_1append_1quadcone_III(conesize,first,numcone) )
        else:
          firstcone = ( self._task_1append_1rquadcone_III(conesize,first,numcone) )
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(1237:15-1241:15)
          i = 0

          while (i < numcone):
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
            ( self._task_1cone_1name_IS((firstcone + i),( sb._toString_() )) )
            i += 1
        if   (idom == None):
          res = mosek.fusion.ConicVariable(self,name,shape,nativeindexes,conesize,firstcone,numcone,( self._numVariables_() ))
        else:
          res = mosek.fusion.IntegerConicVariable(self,name,shape,nativeindexes,conesize,firstcone,numcone,( self._numVariables_() ))
      elif (key == RelationKey.InPSDCone):
        if   (shape._size == 1):
          res = ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,shape,( Domain._greaterThan_F (0.0) ),idom) )
        else:


          if   (shape.nd == 2):
            m = ( shape._dim_I(0) )
            n = 1
            if   (m != ( shape._dim_I(1) )):
              raise mosek.fusion.DimensionError("Non-square shape for semidefinite variable")
          elif (shape.nd == 3):
            n = ( shape._dim_I(0) )
            m = ( shape._dim_I(1) )
            if   (m != ( shape._dim_I(2) )):
              raise mosek.fusion.DimensionError("Non-square shape for semidefinite variable")
          else:
            raise mosek.fusion.DimensionError("Invalid shape for semidefinite variable")
          coneidx = ( self._task_1append_1barvar_II(m,n) )

          varid = ( self._numVariables_() )

          if   (name != None):
            ( self._task_1barvar_1name_IS(coneidx,name) )
          res = mosek.fusion.PSDVariable(self,name,m,coneidx,n,varid)
      else:
        raise mosek.fusion.UnexpectedError("Invalid relation type detected")
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addVariable_SOmosek_fusion_Variable_2(name,res) )
    return res
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1303:15-1309:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1312:15-1318:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,True) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1327:15-1375:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    res = None


    if   ( self._hasVariable_S(name) ):
      raise mosek.fusion.NameError("Duplicate constraint name")
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      if   (idom == None):
        res = mosek.fusion.RangedVariable(self,name,shape,dom,None,( self._numVariables_() ))
      else:
        res = mosek.fusion.IntegerRangedVariable(self,name,shape,dom,None,( self._numVariables_() ))
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addVariable_SOmosek_fusion_Variable_2(name,res) )
    return res
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1382:15-1430:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    res = None


    if   ( self._hasVariable_S(name) ):
      raise mosek.fusion.NameError("Duplicate constraint name")
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      if   (idom == None):
        res = mosek.fusion.RangedVariable(self,name,shape,dom,None,( self._numVariables_() ))
      else:
        res = mosek.fusion.IntegerRangedVariable(self,name,shape,dom,None,( self._numVariables_() ))
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addVariable_SOmosek_fusion_Variable_2(name,res) )
    return res
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1439:15-1443:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,name,shp,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,shp,dom,None) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1451:15-1453:48)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,name,shp,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(name,shp,dom,None) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1462:15-1467:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.Domain)")
  def _variable_SIOmosek_fusion_Domain_2(self,name,size,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(size),dom,None) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1475:15-1479:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.Domain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,shape,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,shape,dom,None) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1487:15-1494:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Domain)")
  def _variable_SOmosek_fusion_Domain_2(self,name,dom):
    if   (dom._shape != None):
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,dom._shape,dom,None) )
    else:
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(1),dom,None) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1505:15-1510:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.RangeDomain)")
  def _variable_SIOmosek_fusion_RangeDomain_2(self,name,size,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(size),dom,None) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1517:15-1521:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.Domain)")
  def _variable_IOmosek_fusion_Domain_2(self,size,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(size),dom,None) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Domain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1529:15-1535:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Domain)")
  def _variable_Omosek_fusion_Domain_2(self,dom):
    if   (dom._shape != None):
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,dom._shape,dom,None) )
    else:
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(1),dom,None) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1543:15-1547:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.RangeDomain)")
  def _variable_IOmosek_fusion_RangeDomain_2(self,size,dom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(size),dom,None) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_RangeDomain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1550:15-1556:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.RangeDomain)")
  def _variable_Omosek_fusion_RangeDomain_2(self,dom):
    if   (dom._shape != None):
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(None,dom._shape,dom,None) )
    else:
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(1),dom,None) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1559:15-1566:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.RangeDomain)")
  def _variable_SOmosek_fusion_RangeDomain_2(self,name,dom):
    if   (dom._shape != None):
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(name,dom._shape,dom,None) )
    else:
      return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(1),dom,None) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1569:15-1572:48)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,shp,dom,idom) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1575:15-1574:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(size),dom,idom) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1587:15-1586:137)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(size),dom,idom) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1602:15-1601:126)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(None,shp,dom,idom) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1617:15-1616:155)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(name,mosek.fusion.IntSet(size),dom,idom) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1632:15-1631:142)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(None,mosek.fusion.IntSet(size),dom,idom) )
  @staticmethod
  def _matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Model.mbi(1640:15-1840:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")
  def _objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,name,sense,expr):
    ( self._task_1putobjectivename_S(name) )
    if   (( expr._size_() ) != 1l):
      raise mosek.fusion.LengthError("Objective expression must be of size 1.")
    if   ((sense != ObjectiveSense.Minimize) and (sense != ObjectiveSense.Maximize)):
      raise mosek.fusion.LengthError("Objective sense required.")
    e = ( expr._eval_() )

    varidxs = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(1666:9-1703:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_595 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_596 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_597 in xrange(num) ])
    # src/fusion/Model.mbi(1672:11-1673:82)
    i = 0

    while (i < num):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],long(i),tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
      i += 1
    numscalarvar = 0
    # src/fusion/Model.mbi(1676:11-1679:22)
    i = 0

    while (i < num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
      i += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_598 in xrange(numscalarvar) ])
    if   (numbarvar == 0):
      varidxs = tmpvaridxs
      cof = e.cof
    else:
      vari = 0

      cof = ([ 0.0 for _autovar_599 in xrange(numscalarvar) ])
      varidxs = ([ 0 for _autovar_600 in xrange(numscalarvar) ])
      # src/fusion/Model.mbi(1693:13-1701:13)
      k = e.ptrb[0]

      while (k < e.ptrb[1]):
        if   (tmpvaridxs[k] >= 0):
          varidxs[vari] = tmpvaridxs[k]
          cof[vari] = e.cof[k]
          vari += 1
        k += 1
    # } @ src/fusion/Model.mbi(1666:9-1703:9)
    bfix = 0.0

    if   (e.bfix != None):
      bfix = e.bfix[0]
    ( self._task_1putobjective_B_3I_3FF((sense == ObjectiveSense.Maximize),varidxs,cof,bfix) )
    if   (numbarvar > 0):
      numbarinz = 0l

      # src/fusion/Model.mbi(1722:11-1725:15)
      k = e.ptrb[0]

      while (k < e.ptrb[1]):
        if   (tmpvaridxs[k] < 0):
          numbarinz += 1
        k += 1
      if   (numbarinz > 0):
        bariperm = ([ 0l for _autovar_601 in xrange(numbarinz) ])

        # { @ src/fusion/Model.mbi(1727:13-1735:13)
        barvari = 0

        # src/fusion/Model.mbi(1729:15-1736:16)
        k = e.ptrb[0]

        while (k < e.ptrb[1]):
          if   (tmpvaridxs[k] < 0):
            bariperm[barvari] = long(k)
            barvari += 1
          k += 1
        # } @ src/fusion/Model.mbi(1727:13-1735:13)
        ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,numbarinz) )
        # { @ src/fusion/Model.mbi(1739:13-1801:14)
        barvari = 0

        # src/fusion/Model.mbi(1741:15-1800:16)
        while (barvari < numbarinz):
          barptrb = barvari

          barvari += 1
          # src/fusion/Model.mbi(1745:17-123)
          while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
            barvari += 1
          numbarvarijnz = (barvari - barptrb)

          ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
          numuniquenz = 1

          # src/fusion/Model.mbi(1754:17-1761:17)
          for k in xrange((barptrb + 1),barvari):
            # { @ src/fusion/Model.mbi(1755:17-1761:17)
            idx = bariperm[k]

            pidx = bariperm[(k - 1)]

            if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
              numuniquenz += 1
            # } @ src/fusion/Model.mbi(1755:17-1761:17)
          l = 0

          barvarijsubi = ([ 0 for _autovar_602 in xrange(numuniquenz) ])

          barvarijsubj = ([ 0 for _autovar_603 in xrange(numuniquenz) ])

          barvarijcof = ([ 0.0 for _autovar_604 in xrange(numuniquenz) ])

          barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
          barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
          if   (barvarijsubi[0] == barvarijsubj[0]):
            barvarijcof[0] = e.cof[bariperm[barptrb]]
          else:
            barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
          # src/fusion/Model.mbi(1778:17-1793:17)
          for k in xrange((barptrb + 1),barvari):
            # { @ src/fusion/Model.mbi(1779:17-1793:17)
            idx = bariperm[k]

            pidx = bariperm[(k - 1)]

            if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
              l += 1
              barvarijsubi[l] = tmpbarvarsubi[idx]
              barvarijsubj[l] = tmpbarvarsubj[idx]
            if   (barvarijsubi[l] == barvarijsubj[l]):
              barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
            else:
              barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
            # } @ src/fusion/Model.mbi(1779:17-1793:17)
          barcj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

          barcjdim = ( self._task_1barvardim_I(barcj) )

          barcjidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(barcjdim,barvarijsubi,barvarijsubj,barvarijcof) )

          ( self._task_1putbarcj_II(barcj,barcjidx) )
        # } @ src/fusion/Model.mbi(1739:13-1801:14)
  @staticmethod
  def _matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.ObjectiveSense): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Model.mbi(1847:15-1851:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")
  def _objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,sense,expr):
    ( self._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,sense,expr) )
  @staticmethod
  def _matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Model.mbi(1859:15-1864:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)")
  def _objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,name,sense,v):
    ( self._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(name,sense,( v._asExpr_() )) )
  @staticmethod
  def _matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.ObjectiveSense): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Model.mbi(1871:15-1875:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)")
  def _objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,sense,v):
    ( self._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,sense,( v._asExpr_() )) )
  @staticmethod
  def _matchargs_getSolutionStatus_Omosek_fusion_SolutionType_2B(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    if not isinstance(args[1],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1880:18-1897:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolutionStatus(mosek.fusion.SolutionType,bool)")
  def _getSolutionStatus_Omosek_fusion_SolutionType_2B(self,which,primal):
    try:
      sol = ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,primal) )

      if   primal:
        return sol.pstatus
      else:
        return sol.dstatus
    except mosek.fusion.SolutionError, e:
      return SolutionStatus.Undefined
  @staticmethod
  def _matchargs_acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(1910:15-1912:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)")
  def _acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(self,what):
    self.__acceptable_sol = what
  @staticmethod
  def _matchargs_acceptedSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(1916:15-1918:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("acceptedSolutionStatus()")
  def _acceptedSolutionStatus_(self):
    return self.__acceptable_sol
  @staticmethod
  def _matchargs_getSolution_1xx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1921:18-1924:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_xx(mosek.fusion.SolutionType)")
  def _getSolution_1xx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,True) ).xx
  @staticmethod
  def _matchargs_getSolution_1slx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1927:18-1930:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_slx(mosek.fusion.SolutionType)")
  def _getSolution_1slx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).slx
  @staticmethod
  def _matchargs_getSolution_1sux_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1933:18-1936:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_sux(mosek.fusion.SolutionType)")
  def _getSolution_1sux_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).sux
  @staticmethod
  def _matchargs_getSolution_1slc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1939:18-1942:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_slc(mosek.fusion.SolutionType)")
  def _getSolution_1slc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).slc
  @staticmethod
  def _matchargs_getSolution_1suc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1945:18-1948:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_suc(mosek.fusion.SolutionType)")
  def _getSolution_1suc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).suc
  @staticmethod
  def _matchargs_getSolution_1snx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1951:18-1954:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_snx(mosek.fusion.SolutionType)")
  def _getSolution_1snx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).snx
  @staticmethod
  def _matchargs_getSolution_1xc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1957:18-1960:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_xc(mosek.fusion.SolutionType)")
  def _getSolution_1xc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,True) ).xc
  @staticmethod
  def _matchargs_getSolution_1y_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1963:18-1966:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_y(mosek.fusion.SolutionType)")
  def _getSolution_1y_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).y
  @staticmethod
  def _matchargs_getSolution_1barx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1969:18-1972:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_barx(mosek.fusion.SolutionType)")
  def _getSolution_1barx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).barx
  @staticmethod
  def _matchargs_getSolution_1bars_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(1975:18-1978:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_bars(mosek.fusion.SolutionType)")
  def _getSolution_1bars_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).bars
  @staticmethod
  def _matchargs_get_1sol_1cache_Omosek_fusion_SolutionType_2B(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    if not isinstance(args[1],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1982:18-2012:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_sol_cache(mosek.fusion.SolutionType,bool)")
  def _get_1sol_1cache_Omosek_fusion_SolutionType_2B(self,which,primal):
    res = None

    if   (which == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (which == SolutionType.Interior):
      res = self._sol_itr
    elif (which == SolutionType.Basic):
      res = self._sol_bas
    elif (which == SolutionType.Integer):
      res = self._sol_itg
    if   (res == None):
      raise mosek.fusion.SolutionError("Solution not available")
    else:
      if   ((primal and ( res._isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self.__acceptable_sol) )) or ((not primal) and ( res._isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self.__acceptable_sol) ))):
        return res
      else:
        raise mosek.fusion.SolutionError("Unacceptable solution status")
  @staticmethod
  def _matchargs_primalObjValue_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2016:15-2018:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("primalObjValue()")
  def _primalObjValue_(self):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(SolutionType.Default,True) ).pobj
  @staticmethod
  def _matchargs_dualObjValue_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2023:15-2025:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dualObjValue()")
  def _dualObjValue_(self):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(SolutionType.Default,False) ).dobj
  @staticmethod
  def _matchargs_getPrimalSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2030:15-2046:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getPrimalSolutionStatus()")
  def _getPrimalSolutionStatus_(self):
    res = None

    if   (self.__solutionptr == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Basic):
      res = self._sol_bas
    elif (self.__solutionptr == SolutionType.Integer):
      res = self._sol_itg
    else:
      res = self._sol_itr
    if   (res == None):
      return SolutionStatus.Undefined
    elif (not self._synched):
      return SolutionStatus.Unknown
    else:
      return res.pstatus
  @staticmethod
  def _matchargs_getDualSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2050:15-2075:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getDualSolutionStatus()")
  def _getDualSolutionStatus_(self):
    res = None

    if   (self.__solutionptr == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Interior):
      res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Basic):
      res = self._sol_bas
    elif (self.__solutionptr == SolutionType.Integer):
      res = self._sol_itg
    if   (res == None):
      return SolutionStatus.Undefined
    elif (not self._synched):
      return SolutionStatus.Unknown
    else:
      return res.dstatus
  @staticmethod
  def _matchargs_solve_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2114:15-2117:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("solve()")
  def _solve_(self):
    ( self._task_1solve_() )
  @staticmethod
  def _matchargs_setSolverParam_SS(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2131:15-2130:128)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,basestring)")
  def _setSolverParam_SS(self,name,strval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SS (self,name,strval) )
  @staticmethod
  def _matchargs_setSolverParam_SI(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Model.mbi(2143:15-2142:128)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,int)")
  def _setSolverParam_SI(self,name,intval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SI (self,name,intval) )
  @staticmethod
  def _matchargs_setSolverParam_SF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Model.mbi(2155:15-2154:132)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,float)")
  def _setSolverParam_SF(self,name,floatval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SF (self,name,floatval) )
  @staticmethod
  def _matchargs_setLogHandler_OStreamWriter_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],file): return False
    return True
  # origin: src/fusion/Model.mbi(2163:15-2162:82)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setLogHandler(file)")
  def _setLogHandler_OStreamWriter_2(self,h):
    ( self._task_1setLogHandler_OStreamWriter_2(h) )
  @staticmethod
  def _matchargs_writeTask_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2171:15-2170:78)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("writeTask(basestring)")
  def _writeTask_S(self,filename):
    ( self._task_1write_S(filename) )
  @_cliptrace
  def acceptedSolutionStatus(self,*args):
    if   Model._matchargs_acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(args):
      return Model._acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(self,*args)
    elif Model._matchargs_acceptedSolutionStatus_(args):
      return Model._acceptedSolutionStatus_(self,*args)
    else:
      argtypestr = "acceptedSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tacceptedSolutionStatus(mosek.fusion.AccSolutionStatus)"),(0,"\tacceptedSolutionStatus()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getPrimalSolutionStatus(self,*args):
    if   Model._matchargs_getPrimalSolutionStatus_(args):
      return Model._getPrimalSolutionStatus_(self,*args)
    else:
      argtypestr = "getPrimalSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetPrimalSolutionStatus()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getConstraint(self,*args):
    if   BaseModel._matchargs_getConstraint_S(args):
      return BaseModel._getConstraint_S(self,*args)
    else:
      argtypestr = "getConstraint(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetConstraint(basestring)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def constraint(self,*args):
    if   Model._matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    else:
      argtypestr = "constraint(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tconstraint(mosek.fusion.Variable,mosek.fusion.Domain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(2,"\tconstraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(3,"\tconstraint(basestring,mosek.fusion.Variable,mosek.fusion.Domain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)"),(2,"\tconstraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(2,"\tconstraint(mosek.fusion.Expression,mosek.fusion.Domain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)"),(3,"\tconstraint(basestring,mosek.fusion.Expression,mosek.fusion.Domain)"),(3,"\tconstraint(basestring,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(3,"\tconstraint(basestring,mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getVariable(self,*args):
    if   BaseModel._matchargs_getVariable_S(args):
      return BaseModel._getVariable_S(self,*args)
    else:
      argtypestr = "getVariable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetVariable(basestring)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def setSolverParam(self,*args):
    if   Model._matchargs_setSolverParam_SS(args):
      return Model._setSolverParam_SS(self,*args)
    elif Model._matchargs_setSolverParam_SF(args):
      return Model._setSolverParam_SF(self,*args)
    elif Model._matchargs_setSolverParam_SI(args):
      return Model._setSolverParam_SI(self,*args)
    else:
      argtypestr = "setSolverParam(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tsetSolverParam(basestring,basestring)"),(2,"\tsetSolverParam(basestring,float)"),(2,"\tsetSolverParam(basestring,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def variable(self,*args):
    if   Model._matchargs_variable_IOmosek_fusion_RangeDomain_2(args):
      return Model._variable_IOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_Domain_2(args):
      return Model._variable_SIOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_RangeDomain_2(args):
      return Model._variable_SOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_Domain_2(args):
      return Model._variable_IOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Domain_2(args):
      return Model._variable_Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Domain_2(args):
      return Model._variable_SOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_RangeDomain_2(args):
      return Model._variable_Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_RangeDomain_2(args):
      return Model._variable_SIOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    else:
      argtypestr = "variable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tvariable(int,mosek.fusion.RangeDomain)"),(4,"\tvariable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(basestring,int,mosek.fusion.Domain)"),(3,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.Domain)"),(2,"\tvariable(basestring,mosek.fusion.RangeDomain)"),(3,"\tvariable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(2,"\tvariable(int,mosek.fusion.Domain)"),(1,"\tvariable(mosek.fusion.Domain)"),(2,"\tvariable(basestring,mosek.fusion.Domain)"),(1,"\tvariable(mosek.fusion.RangeDomain)"),(3,"\tvariable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tvariable(mosek.fusion.Set,mosek.fusion.Domain)"),(3,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)"),(3,"\tvariable(basestring,int,mosek.fusion.RangeDomain)"),(4,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(4,"\tvariable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def setLogHandler(self,*args):
    if   Model._matchargs_setLogHandler_OStreamWriter_2(args):
      return Model._setLogHandler_OStreamWriter_2(self,*args)
    else:
      argtypestr = "setLogHandler(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsetLogHandler(file)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def solve(self,*args):
    if   Model._matchargs_solve_(args):
      return Model._solve_(self,*args)
    else:
      argtypestr = "solve(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsolve()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def sparseVariable(self,*args):
    if   Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    else:
      argtypestr = "sparseVariable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def primalObjValue(self,*args):
    if   Model._matchargs_primalObjValue_(args):
      return Model._primalObjValue_(self,*args)
    else:
      argtypestr = "primalObjValue(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tprimalObjValue()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def objective(self,*args):
    if   Model._matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
      return Model._objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,*args)
    elif Model._matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
      return Model._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,*args)
    elif Model._matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
      return Model._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,*args)
    elif Model._matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
      return Model._objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,*args)
    else:
      argtypestr = "objective(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tobjective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)"),(3,"\tobjective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)"),(3,"\tobjective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)"),(2,"\tobjective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def getDualSolutionStatus(self,*args):
    if   Model._matchargs_getDualSolutionStatus_(args):
      return Model._getDualSolutionStatus_(self,*args)
    else:
      argtypestr = "getDualSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetDualSolutionStatus()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def writeTask(self,*args):
    if   Model._matchargs_writeTask_S(args):
      return Model._writeTask_S(self,*args)
    else:
      argtypestr = "writeTask(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\twriteTask(basestring)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def dualObjValue(self,*args):
    if   Model._matchargs_dualObjValue_(args):
      return Model._dualObjValue_(self,*args)
    else:
      argtypestr = "dualObjValue(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdualObjValue()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/domain.mbi(35:12-548:5)
class Domain:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2I(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,int)")
  def __constructor_Omosek_fusion_RelationKey_2I(self,key_,size_):
    self._key = key_
    if   (size_ == 0):
      self._shape = None
    elif (key_ == RelationKey.InPSDCone):
      self._shape = mosek.fusion.NDSet(size_,size_)
    else:
      self._shape = mosek.fusion.IntSet(size_)
    self.__idxmap = None
    self.__bnd = None
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2II(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,int,int)")
  def __constructor_Omosek_fusion_RelationKey_2II(self,key_,m,n):
    self._key = key_
    if   (key_ == RelationKey.InPSDCone):
      self._shape = mosek.fusion.NDSet(n,m,m)
    else:
      self._shape = mosek.fusion.NDSet(m,n)
    self.__idxmap = None
    self.__bnd = None
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2_3FB(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,[double],bool)")
  def __constructor_Omosek_fusion_RelationKey_2_3FB(self,key_,bnd_,scalable):
    self.__idxmap = None
    self._key = key_
    if   (bnd_ != None):
      if   (int(len(bnd_)) > 1):
        self._shape = mosek.fusion.IntSet(int(len(bnd_)))
      else:
        self._shape = None
    else:
      self._shape = None
    self.__bnd = bnd_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,mosek.fusion.Matrix)")
  def __constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(self,key_,bnd_):
    self._key = key_
    self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
    self.__idxmap = None
    _autovar_605 = bnd_
    if   isinstance(_autovar_605,mosek.fusion.DenseMatrix):
      m = _autovar_605
      self.__bnd = m._data
    elif isinstance(_autovar_605,mosek.fusion.SparseMatrix):
      m = _autovar_605
      self.__bnd = m._val
      self.__idxmap = mosek.fusion.Utils.IntMap()
      # src/fusion/domain.mbi(150:11-153:11)
      i = 0

      while (i < int(len(self.__bnd))):
        ( self.__idxmap._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
        i += 1
    else:
      m = _autovar_605
      raise mosek.fusion.UnimplementedError("Unknown matrix type.")
  def __init__(self,*args):
    #self._protected_shape = None

    #self.__idxmap = None

    #self.__bnd = None

    #self._protected_key = None

    if   self._matchargs_constructor_Omosek_fusion_RelationKey_2I(args):
      self.__constructor_Omosek_fusion_RelationKey_2I(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2II(args):
      self.__constructor_Omosek_fusion_RelationKey_2II(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2_3FB(args):
      self.__constructor_Omosek_fusion_RelationKey_2_3FB(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(args):
      self.__constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_get_1rhs_1item_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(163:18-166:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_rhs_item(int)")
  def _get_1rhs_1item_I(self,index):
    return ( self._get_1rhs_1item_L(long(index)) )
  @staticmethod
  def _matchargs_get_1rhs_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(169:18-198:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_rhs_item(long)")
  def _get_1rhs_1item_L(self,index):
    if   (self.__idxmap != None):
      if   ( self.__idxmap._hasItem_L(index) ):
        return self.__bnd[( self.__idxmap._getItem_L(index) )]
      else:
        return 0.0
    else:
      if   ((self._shape == None) and (self.__bnd != None)):
        return self.__bnd[0]
      elif (self.__bnd != None):
        return self.__bnd[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_match_1shape_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/domain.mbi(201:18-211:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("match_shape(mosek.fusion.Set)")
  def _match_1shape_Omosek_fusion_Set_2(self,shp):
    if   (self._shape == None):
      return True
    else:
      return ( self._shape._compare_Omosek_fusion_Set_2(shp) )
  @staticmethod
  def _matchargs_unbounded_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(218:15-220:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("unbounded()")
  def _unbounded_():
    return mosek.fusion.Domain(RelationKey.IsFree,None,True)
  @staticmethod
  def _matchargs_equalsTo_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(229:15-231:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo(float)")
  def _equalsTo_F(b):
    return mosek.fusion.Domain(RelationKey.EqualsTo,([ b]),True)
  @staticmethod
  def _matchargs_equalsTo__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(238:15-240:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo([double])")
  def _equalsTo__3F(bnd):
    return mosek.fusion.Domain(RelationKey.EqualsTo,bnd,False)
  @staticmethod
  def _matchargs_equalsTo_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(247:15-249:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo(mosek.fusion.Matrix)")
  def _equalsTo_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.EqualsTo,bnd)
  @staticmethod
  def _matchargs_lessThan_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(257:15-259:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan(float)")
  def _lessThan_F(b):
    return mosek.fusion.Domain(RelationKey.LessThan,([ b]),True)
  @staticmethod
  def _matchargs_lessThan__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(266:15-268:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan([double])")
  def _lessThan__3F(bnd):
    return mosek.fusion.Domain(RelationKey.LessThan,bnd,False)
  @staticmethod
  def _matchargs_lessThan_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(274:15-276:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan(mosek.fusion.Matrix)")
  def _lessThan_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.LessThan,bnd)
  @staticmethod
  def _matchargs_greaterThan_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(284:15-286:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan(float)")
  def _greaterThan_F(b):
    return mosek.fusion.Domain(RelationKey.GreaterThan,([ b]),True)
  @staticmethod
  def _matchargs_greaterThan__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(293:15-295:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan([double])")
  def _greaterThan__3F(bnd):
    return mosek.fusion.Domain(RelationKey.GreaterThan,bnd,False)
  @staticmethod
  def _matchargs_greaterThan_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(302:15-304:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan(mosek.fusion.Matrix)")
  def _greaterThan_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.GreaterThan,bnd)
  @staticmethod
  def _matchargs_inPSDCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(317:15-319:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inPSDCone()")
  def _inPSDCone_():
    return mosek.fusion.Domain(RelationKey.InPSDCone,0)
  @staticmethod
  def _matchargs_inPSDCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(330:15-332:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inPSDCone(int)")
  def _inPSDCone_I(n):
    return mosek.fusion.Domain(RelationKey.InPSDCone,n)
  @staticmethod
  def _matchargs_inPSDCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(343:15-345:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inPSDCone(int,int)")
  def _inPSDCone_II(m,n):
    return mosek.fusion.Domain(RelationKey.InPSDCone,m,n)
  @staticmethod
  def _matchargs_inQCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(351:15-353:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inQCone()")
  def _inQCone_():
    return mosek.fusion.Domain(RelationKey.InQCone,0)
  @staticmethod
  def _matchargs_inQCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(358:15-360:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inQCone(int)")
  def _inQCone_I(size):
    return mosek.fusion.Domain(RelationKey.InQCone,size)
  @staticmethod
  def _matchargs_inQCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(373:15-375:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inQCone(int,int)")
  def _inQCone_II(m,n):
    return mosek.fusion.Domain(RelationKey.InQCone,m,n)
  @staticmethod
  def _matchargs_inRotatedQCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(381:15-383:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inRotatedQCone()")
  def _inRotatedQCone_():
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,0)
  @staticmethod
  def _matchargs_inRotatedQCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(388:15-390:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inRotatedQCone(int)")
  def _inRotatedQCone_I(size):
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,size)
  @staticmethod
  def _matchargs_inRotatedQCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(401:15-403:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRotatedQCone(int,int)")
  def _inRotatedQCone_II(m,n):
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,m,n)
  @staticmethod
  def _matchargs_inRange_FF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(412:15-418:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,float)")
  def _inRange_FF(lb,ub):
    if   (lb > ub):
      raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._makevector_FI (lb,1) ),( Utils.Tools._makevector_FI (ub,1) ),True)
  @staticmethod
  def _matchargs_inRange_F_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(429:15-436:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,[double])")
  def _inRange_F_3F(lb,ub):
    # src/fusion/domain.mbi(430:9-434:17)
    for i in xrange(0,int(len(ub))):
      if   (lb > ub[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._makevector_FI (lb,int(len(ub))) ),( Utils.Tools._arraycopy__3F (ub) ),False)
  @staticmethod
  def _matchargs_inRange__3FF(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(447:15-456:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange([double],float)")
  def _inRange__3FF(lb,ub):
    # src/fusion/domain.mbi(448:9-452:9)
    for i in xrange(0,int(len(lb))):
      # { @ src/fusion/domain.mbi(449:9-452:9)
      if   (lb[i] > ub):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(449:9-452:9)
    return mosek.fusion.RangeDomain(( Utils.Tools._arraycopy__3F (lb) ),( Utils.Tools._makevector_FI (ub,int(len(lb))) ),False)
  @staticmethod
  def _matchargs_inRange__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(466:15-478:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange([double],[double])")
  def _inRange__3F_3F(lb,ub):
    if   (int(len(lb)) != int(len(ub))):
      raise mosek.fusion.LengthError("Mismatching lengths of upper and lower bounds.")
    # src/fusion/domain.mbi(471:9-476:17)
    for i in xrange(0,int(len(ub))):
      if   (lb[i] > ub[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._arraycopy__3F (lb) ),( Utils.Tools._arraycopy__3F (ub) ),False)
  @staticmethod
  def _matchargs_inRange_FOmosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(489:15-501:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,mosek.fusion.Matrix)")
  def _inRange_FOmosek_fusion_Matrix_2(lb,ub):
    subi = ([ 0 for _autovar_606 in xrange(( ub._numNonzeros_() )) ])

    subj = ([ 0 for _autovar_607 in xrange(( ub._numNonzeros_() )) ])

    val = ([ 0.0 for _autovar_608 in xrange(( ub._numNonzeros_() )) ])

    ( ub._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
    # src/fusion/domain.mbi(495:9-499:9)
    for i in xrange(0,int(len(val))):
      # { @ src/fusion/domain.mbi(496:9-499:9)
      if   (lb >= val[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(496:9-499:9)
    return mosek.fusion.RangeDomain(lb,None,0.0,ub)
  @staticmethod
  def _matchargs_inRange_Omosek_fusion_Matrix_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(511:15-523:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(mosek.fusion.Matrix,float)")
  def _inRange_Omosek_fusion_Matrix_2F(lb,ub):
    subi = ([ 0 for _autovar_609 in xrange(( lb._numNonzeros_() )) ])

    subj = ([ 0 for _autovar_610 in xrange(( lb._numNonzeros_() )) ])

    val = ([ 0.0 for _autovar_611 in xrange(( lb._numNonzeros_() )) ])

    ( lb._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
    # src/fusion/domain.mbi(517:9-521:9)
    for i in xrange(0,int(len(val))):
      # { @ src/fusion/domain.mbi(518:9-521:9)
      if   (val[i] > ub):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(518:9-521:9)
    return mosek.fusion.RangeDomain(0.0,lb,ub,None)
  @staticmethod
  def _matchargs_inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(533:15-540:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)")
  def _inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(lb,ub):
    if   ((lb._dimi != ub._dimi) or (lb._dimj != ub._dimj)):
      raise mosek.fusion.LengthError("Mismatching dimensions of upper and lower bounds.")
    return mosek.fusion.RangeDomain(0.0,lb,0.0,ub)
  @staticmethod
  def _matchargs_isInteger_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(545:15-547:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("isInteger()")
  def _isInteger_():
    return mosek.fusion.IntegerDomain()
  @staticmethod
  @_cliptrace
  def inQCone(*args):
    if   Domain._matchargs_inQCone_II(args):
      return Domain._inQCone_II(*args)
    elif Domain._matchargs_inQCone_I(args):
      return Domain._inQCone_I(*args)
    elif Domain._matchargs_inQCone_(args):
      return Domain._inQCone_(*args)
    else:
      argtypestr = "inQCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tinQCone(int,int)"),(1,"\tinQCone(int)"),(0,"\tinQCone()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def lessThan(*args):
    if   Domain._matchargs_lessThan_F(args):
      return Domain._lessThan_F(*args)
    elif Domain._matchargs_lessThan__3F(args):
      return Domain._lessThan__3F(*args)
    elif Domain._matchargs_lessThan_Omosek_fusion_Matrix_2(args):
      return Domain._lessThan_Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "lessThan(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlessThan(float)"),(1,"\tlessThan([double])"),(1,"\tlessThan(mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def greaterThan(*args):
    if   Domain._matchargs_greaterThan__3F(args):
      return Domain._greaterThan__3F(*args)
    elif Domain._matchargs_greaterThan_F(args):
      return Domain._greaterThan_F(*args)
    elif Domain._matchargs_greaterThan_Omosek_fusion_Matrix_2(args):
      return Domain._greaterThan_Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "greaterThan(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgreaterThan([double])"),(1,"\tgreaterThan(float)"),(1,"\tgreaterThan(mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def equalsTo(*args):
    if   Domain._matchargs_equalsTo_Omosek_fusion_Matrix_2(args):
      return Domain._equalsTo_Omosek_fusion_Matrix_2(*args)
    elif Domain._matchargs_equalsTo__3F(args):
      return Domain._equalsTo__3F(*args)
    elif Domain._matchargs_equalsTo_F(args):
      return Domain._equalsTo_F(*args)
    else:
      argtypestr = "equalsTo(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tequalsTo(mosek.fusion.Matrix)"),(1,"\tequalsTo([double])"),(1,"\tequalsTo(float)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def unbounded(*args):
    if   Domain._matchargs_unbounded_(args):
      return Domain._unbounded_(*args)
    else:
      argtypestr = "unbounded(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tunbounded()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def inPSDCone(*args):
    if   Domain._matchargs_inPSDCone_II(args):
      return Domain._inPSDCone_II(*args)
    elif Domain._matchargs_inPSDCone_I(args):
      return Domain._inPSDCone_I(*args)
    elif Domain._matchargs_inPSDCone_(args):
      return Domain._inPSDCone_(*args)
    else:
      argtypestr = "inPSDCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tinPSDCone(int,int)"),(1,"\tinPSDCone(int)"),(0,"\tinPSDCone()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def inRange(*args):
    if   Domain._matchargs_inRange_FF(args):
      return Domain._inRange_FF(*args)
    elif Domain._matchargs_inRange__3FF(args):
      return Domain._inRange__3FF(*args)
    elif Domain._matchargs_inRange_F_3F(args):
      return Domain._inRange_F_3F(*args)
    elif Domain._matchargs_inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(args):
      return Domain._inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(*args)
    elif Domain._matchargs_inRange_Omosek_fusion_Matrix_2F(args):
      return Domain._inRange_Omosek_fusion_Matrix_2F(*args)
    elif Domain._matchargs_inRange__3F_3F(args):
      return Domain._inRange__3F_3F(*args)
    elif Domain._matchargs_inRange_FOmosek_fusion_Matrix_2(args):
      return Domain._inRange_FOmosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "inRange(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tinRange(float,float)"),(2,"\tinRange([double],float)"),(2,"\tinRange(float,[double])"),(2,"\tinRange(mosek.fusion.Matrix,mosek.fusion.Matrix)"),(2,"\tinRange(mosek.fusion.Matrix,float)"),(2,"\tinRange([double],[double])"),(2,"\tinRange(float,mosek.fusion.Matrix)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def inRotatedQCone(*args):
    if   Domain._matchargs_inRotatedQCone_I(args):
      return Domain._inRotatedQCone_I(*args)
    elif Domain._matchargs_inRotatedQCone_(args):
      return Domain._inRotatedQCone_(*args)
    elif Domain._matchargs_inRotatedQCone_II(args):
      return Domain._inRotatedQCone_II(*args)
    else:
      argtypestr = "inRotatedQCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinRotatedQCone(int)"),(0,"\tinRotatedQCone()"),(2,"\tinRotatedQCone(int,int)")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @staticmethod
  @_cliptrace
  def isInteger(*args):
    if   Domain._matchargs_isInteger_(args):
      return Domain._isInteger_(*args)
    else:
      argtypestr = "isInteger(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisInteger()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/ConstraintCache.mbi(20:12-355:5)
class ConstraintCache:
  @staticmethod
  def _matchargs_constructor__3L_3F_3I_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int64],[double],[int32],[double])")
  def __constructor__3L_3F_3I_3F(self,ptrb_,cof_,subj_,bfix_):
    self.nrows = (int(len(ptrb_)) - 1)
    self.nnz = ptrb_[(int(len(ptrb_)) - 1)]
    self.subj = ([ 0 for _autovar_612 in xrange(self.nnz) ])
    self.subi = ([ 0 for _autovar_613 in xrange(self.nnz) ])
    self.cof = ([ 0.0 for _autovar_614 in xrange(self.nnz) ])
    if   (bfix_ != None):
      self.bfix = bfix_
    else:
      self.bfix = ([ 0.0 for _autovar_615 in xrange(self.nrows) ])
    ( Utils.Tools._arraycopy__3IL_3ILL (subj_,0l,self.subj,0l,self.nnz) )
    ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,self.cof,0l,self.nnz) )
    # src/fusion/ConstraintCache.mbi(69:9-71:24)
    for i in xrange(0,self.nrows):
      # src/fusion/ConstraintCache.mbi(70:11-71:24)
      for j in xrange(ptrb_[i],ptrb_[(i + 1)]):
        self.subi[j] = i
    self.buffer_cof = None
    self.buffer_subj = None
    self.buffer_subi = None
    self.nunordered = 0l
  def __init__(self,*args):
    #self.nrows = None

    #self.nnz = None

    #self.subj = None

    #self.subi = None

    #self.cof = None

    #self.bfix = None

    #self.buffer_cof = None

    #self.buffer_subj = None

    #self.buffer_subi = None

    #self.nunordered = None

    self.__constructor__3L_3F_3I_3F(*args)
  @staticmethod
  def _matchargs_numUnsorted_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(83:15-85:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numUnsorted()")
  def _numUnsorted_(self):
    return self.nunordered
  @staticmethod
  def _matchargs_flush__3L_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(102:15-269:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("flush([int64],[int32],[double],[double])")
  def _flush__3L_3I_3F_3F(self,resptrb,ressubj,rescof,resbfix):
    perm = None

    if   (self.bfix != None):
      # src/fusion/ConstraintCache.mbi(111:11-112:33)
      for i in xrange(0,self.nrows):
        resbfix[i] = self.bfix[i]
    if   (self.nunordered == 0l):
      return 0l
    is_ordered = False

    # { @ src/fusion/ConstraintCache.mbi(121:9-126:9)
    i = 1

    # src/fusion/ConstraintCache.mbi(123:11-114)
    while ((i < self.nunordered) and ((self.subi[(i - 1)] < self.subi[i]) or ((self.subi[(i - 1)] == self.subi[i]) and (self.subj[(i - 1)] <= self.subj[i])))):
      i += 1
    if   (i == self.nunordered):
      is_ordered = True
    # } @ src/fusion/ConstraintCache.mbi(121:9-126:9)
    if   (not is_ordered):
      perm = ([ 0l for _autovar_616 in xrange(self.nunordered) ])
      # src/fusion/ConstraintCache.mbi(130:35-75)
      for i in xrange(0l,self.nunordered):
        perm[i] = i
      ( CommonTools._argQsort__3L_3I_3ILL (perm,self.subi,self.subj,0l,self.nunordered) )
    nordered = int(len(self.subi))

    r_subi = ([ 0 for _autovar_617 in xrange((self.nunordered + nordered)) ])

    r_subj = ([ 0 for _autovar_618 in xrange((self.nunordered + nordered)) ])

    r_cof = ([ 0.0 for _autovar_619 in xrange((self.nunordered + nordered)) ])

    if   is_ordered:
      i0 = 0

      i1 = 0

      e0 = nordered

      e1 = self.nunordered

      j = 0

      row = 0l

      # src/fusion/ConstraintCache.mbi(148:11-199:11)
      while ((i0 < e0) and (i1 < e1)):
        if   ((self.subi[i0] < self.buffer_subi[i1]) or ((self.subi[i0] == self.buffer_subi[i1]) and (self.subj[i0] < self.buffer_subj[i1]))):
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          i0 += 1
          j += 1
        elif ((self.subi[i0] > self.buffer_subi[i1]) or ((self.subi[i0] == self.buffer_subi[i1]) and (self.subj[i0] > self.buffer_subj[i1]))):
          r_subi[j] = self.buffer_subi[i1]
          r_subj[j] = self.buffer_subj[i1]
          r_cof[j] = self.buffer_cof[i1]
          # src/fusion/ConstraintCache.mbi(163:15-79)
          while (row < r_subi[j]):
            resptrb[(row + 1)] = resptrb[row]
            row += 1
          p = resptrb[(row + 1)]

          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          resptrb[(row + 1)] += 1
          i1 += 1
          j += 1
        else:
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          # src/fusion/ConstraintCache.mbi(179:15-186:15)
          while ((self.subi[i0] == self.buffer_subi[i1]) and (self.subj[i0] == self.buffer_subj[i1])):
            r_subi[j] = (r_subi[j] + self.buffer_subi[i1])
            r_subj[j] = (r_subj[j] + self.buffer_subj[i1])
            r_cof[j] = (r_cof[j] + self.buffer_cof[i1])
            i1 += 1
          # src/fusion/ConstraintCache.mbi(188:15-79)
          while (row < r_subi[j]):
            row += 1
            resptrb[(row + 1)] = resptrb[row]
          p = resptrb[(row + 1)]

          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          resptrb[(row + 1)] += 1
          i0 += 1
          j += 1
        # src/fusion/ConstraintCache.mbi(198:13-73)
        while (row < self.nrows):
          row += 1
          resptrb[(row + 1)] = resptrb[row]
    else:
      i0 = 0

      i1 = 0

      e0 = nordered

      e1 = self.nunordered

      j = 0

      row = 0l

      # src/fusion/ConstraintCache.mbi(209:11-260:11)
      while ((i0 < e0) and (i1 < e1)):
        if   ((self.subi[i0] < self.buffer_subi[perm[i1]]) or ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] < self.buffer_subj[perm[i1]]))):
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          i0 += 1
          j += 1
        elif ((self.subi[i0] > self.buffer_subi[perm[i1]]) or ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] > self.buffer_subj[perm[i1]]))):
          r_subi[j] = self.buffer_subi[perm[i1]]
          r_subj[j] = self.buffer_subj[perm[i1]]
          r_cof[j] = self.buffer_cof[perm[i1]]
          # src/fusion/ConstraintCache.mbi(224:15-79)
          while (row < r_subi[j]):
            resptrb[(row + 1)] = resptrb[row]
            row += 1
          p = resptrb[(row + 1)]

          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          resptrb[(row + 1)] += 1
          i1 += 1
          j += 1
        else:
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          # src/fusion/ConstraintCache.mbi(240:15-247:15)
          while ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] == self.buffer_subj[perm[i1]])):
            r_subi[j] = (r_subi[j] + self.buffer_subi[perm[i1]])
            r_subj[j] = (r_subj[j] + self.buffer_subj[perm[i1]])
            r_cof[j] = (r_cof[j] + self.buffer_cof[perm[i1]])
            i1 += 1
          # src/fusion/ConstraintCache.mbi(249:15-79)
          while (row < r_subi[j]):
            row += 1
            resptrb[(row + 1)] = resptrb[row]
          p = resptrb[(row + 1)]

          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          resptrb[(row + 1)] += 1
          i0 += 1
          j += 1
        # src/fusion/ConstraintCache.mbi(259:13-73)
        while (row < self.nrows):
          row += 1
          resptrb[(row + 1)] = resptrb[row]
    self.subi = r_subi
    self.subj = r_subj
    self.cof = r_cof
    self.nunordered = 0l
    return resptrb[self.nrows]
  @staticmethod
  def _matchargs_add__3L_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(282:15-292:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([int64],[int32],[double],[double])")
  def _add__3L_3I_3F_3F(self,ptrb_,subj_,cof_,bfix_):
    if   ((int(len(ptrb_)) != (self.nrows + 1)) or ((bfix_ != None) and (int(len(bfix_)) != self.nrows))):
      raise mosek.fusion.LengthError("Mismatching expression lengths")
    ( self._unchecked_1add_1l__3L_3I_3F_3F(ptrb_,subj_,cof_,bfix_) )
  @staticmethod
  def _matchargs_unchecked_1add_1l__3L_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(307:18-346:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("unchecked_add_l([int64],[int32],[double],[double])")
  def _unchecked_1add_1l__3L_3I_3F_3F(self,ptrb_,subj_,cof_,bfix_):
    newnum = (self.nunordered + ptrb_[self.nrows])

    addnum = ptrb_[self.nrows]

    if   ((self.buffer_cof == None) or (int(len(self.buffer_cof)) > newnum)):
      tmp_subi = ([ 0 for _autovar_620 in xrange(newnum) ])

      tmp_subj = ([ 0 for _autovar_621 in xrange(newnum) ])

      tmp_cof = ([ 0.0 for _autovar_622 in xrange(newnum) ])

      if   (self.buffer_cof != None):
        ( Utils.Tools._arraycopy__3IL_3ILL (self.buffer_subi,0l,tmp_subi,0l,self.nunordered) )
        ( Utils.Tools._arraycopy__3IL_3ILL (self.buffer_subj,0l,tmp_subj,0l,self.nunordered) )
        ( Utils.Tools._arraycopy__3FL_3FLL (self.buffer_cof,0l,tmp_cof,0l,self.nunordered) )
        # src/fusion/ConstraintCache.mbi(327:13-329:43)
        for i in xrange(0,self.nrows):
          # src/fusion/ConstraintCache.mbi(328:15-329:43)
          for j in xrange(ptrb_[i],ptrb_[(i + 1)]):
            tmp_subi[(self.nunordered + j)] = i
        ( Utils.Tools._arraycopy__3IL_3ILL (subj_,0l,tmp_subj,self.nunordered,addnum) )
        ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,tmp_cof,self.nunordered,addnum) )
      self.buffer_subi = tmp_subi
      self.buffer_subj = tmp_subj
      self.buffer_cof = tmp_cof
    if   (bfix_ != None):
      # src/fusion/ConstraintCache.mbi(341:11-342:41)
      for i in xrange(0,self.nrows):
        self.bfix[i] = (self.bfix[i] + bfix_[i])
    self.nunordered = newnum
    self.nnz = (self.nnz + addnum)
  @staticmethod
  def _matchargs_unchecked_1add_1fx__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(349:18-353:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("unchecked_add_fx([double])")
  def _unchecked_1add_1fx__3F(self,bfix_):
    # src/fusion/ConstraintCache.mbi(351:9-352:39)
    for i in xrange(0,self.nrows):
      self.bfix[i] = (self.bfix[i] + bfix_[i])
  @_cliptrace
  def add(self,*args):
    if   ConstraintCache._matchargs_add__3L_3I_3F_3F(args):
      return ConstraintCache._add__3L_3I_3F_3F(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tadd([int64],[int32],[double],[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def numUnsorted(self,*args):
    if   ConstraintCache._matchargs_numUnsorted_(args):
      return ConstraintCache._numUnsorted_(self,*args)
    else:
      argtypestr = "numUnsorted(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumUnsorted()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def flush(self,*args):
    if   ConstraintCache._matchargs_flush__3L_3I_3F_3F(args):
      return ConstraintCache._flush__3L_3I_3F_3F(self,*args)
    else:
      argtypestr = "flush(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tflush([int64],[int32],[double],[double])")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/FlatExpr.mbi(14:12-155:5)
class FlatExpr:
  @staticmethod
  def _matchargs_constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Variable): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([double],[int64],[int64],mosek.fusion.Variable,[double],mosek.fusion.Set,[int64])")
  def __constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    if   ((bfix_ != None) and (int(len(bfix_)) != (int(len(ptrb_)) - 1))):
      raise mosek.fusion.SparseFormatError("Mismatching lengths of bfix and ptrb")
    if   (((cof_ == None) or (subj_ == None)) or (int(len(subj_)) != int(len(cof_)))):
      raise mosek.fusion.SparseFormatError("Mismatching lengths of x and cof")
    if   (shape_ != None):
      if   (inst_ != None):
        if   (int(len(inst_)) != (int(len(ptrb_)) - 1)):
          raise mosek.fusion.SparseFormatError("Mismatching lengths of inst and ptrb")
      elif (shape_._size != (long(len(ptrb_)) - 1)):
        raise mosek.fusion.SparseFormatError("Mismatching shape and ptrb")
    self.bfix = bfix_
    self.ptrb = ptrb_
    self.subj = subj_
    self.x = x_
    self.cof = cof_
    self.nnz = self.ptrb[(int(len(self.ptrb)) - 1)]
    self.shape = shape_
    self.inst = inst_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_FlatExpr_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.FlatExpr): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.FlatExpr)")
  def __constructor_Omosek_fusion_FlatExpr_2(self,e):
    if   (e.bfix != None):
      self.bfix = ( Utils.Tools._arraycopy__3F (e.bfix) )
    else:
      self.bfix = None
    self.ptrb = ( Utils.Tools._arraycopy__3L (e.ptrb) )
    self.subj = ( Utils.Tools._arraycopy__3L (e.subj) )
    self.x = e.x
    self.cof = ( Utils.Tools._arraycopy__3F (e.cof) )
    self.nnz = e.nnz
    self.shape = e.shape
    self.inst = e.inst
  def __init__(self,*args):
    #self.bfix = None

    #self.ptrb = None

    #self.subj = None

    #self.x = None

    #self.cof = None

    #self.nnz = None

    #self.shape = None

    #self.inst = None

    if   self._matchargs_constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(args):
      self.__constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(*args)
    elif self._matchargs_constructor_Omosek_fusion_FlatExpr_2(args):
      self.__constructor_Omosek_fusion_FlatExpr_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/FlatExpr.mbi(132:15-134:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return (int(len(self.ptrb)) - 1)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/FlatExpr.mbi(138:15-154:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( sb._a_S("FlatExpr:") )._lf_() )._a_S("+-----------------") )._lf_() )._a_S("| ptrb[") )._a_I(int(len(self.ptrb))) )._a_S("] = ") )._a__3L(self.ptrb) )._lf_() )._a_S("| subj[") )._a_I(int(len(self.subj))) )._a_S("] = ") )._a__3L(self.subj) )._lf_() )._a_S("| cof [") )._a_I(int(len(self.cof))) )._a_S("] = ") )._a__3F(self.cof) )._lf_() )._a_S("| bfix[") )
    if   (self.bfix != None):
      ( sb._a_I(int(len(self.bfix))) )
    ( ( ( ( sb._a_S("] = ") )._a__3F(self.bfix) )._lf_() )._a_S("| inst[") )
    if   (self.inst != None):
      ( sb._a_I(int(len(self.inst))) )
    ( ( ( ( sb._a_S("] = ") )._a__3L(self.inst) )._lf_() )._a_S("+-----------------") )
    return ( sb._toString_() )
  @_cliptrace
  def toString(self,*args):
    if   FlatExpr._matchargs_toString_(args):
      return FlatExpr._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
  @_cliptrace
  def size(self,*args):
    if   FlatExpr._matchargs_size_(args):
      return FlatExpr._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))

## origin: src/fusion/domain.mbi(773:12-775:5)
class IntegerDomain:
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__()")
  def __constructor_(self):
    pass
  def __init__(self,*args):
    self.__constructor_(*args)

## origin: src/fusion/domain.mbi(562:12-763:5)
class RangeDomain:
  @staticmethod
  def _matchargs_constructor__3F_3FB(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([double],[double],bool)")
  def __constructor__3F_3FB(self,lb_,ub_,scalable):
    if   scalable:
      self._shape = None
    else:
      self._shape = mosek.fusion.IntSet(int(len(lb_)))
    self.__idxmap_lb = None
    self.__idxmap_ub = None
    self.__ub = ub_
    self.__lb = lb_
  @staticmethod
  def _matchargs_constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    if not isinstance(args[2],float): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(float,mosek.fusion.Matrix,float,mosek.fusion.Matrix)")
  def __constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(self,lb_scalar,lb_matrix,ub_scalar,ub_matrix):
    self._shape = None
    if   (lb_matrix != None):
      bnd_ = lb_matrix

      self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
      _autovar_623 = bnd_
      if   isinstance(_autovar_623,mosek.fusion.DenseMatrix):
        m = _autovar_623
        self.__lb = m._data
        self.__idxmap_lb = None
      elif isinstance(_autovar_623,mosek.fusion.SparseMatrix):
        m = _autovar_623
        self.__lb = m._val
        self.__idxmap_lb = mosek.fusion.Utils.IntMap()
        # src/fusion/domain.mbi(629:13-632:13)
        i = 0

        while (i < int(len(self.__lb))):
          ( self.__idxmap_lb._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
          i += 1
      else:
        m = _autovar_623
        raise mosek.fusion.UnimplementedError("Unknown matrix type.")
    else:
      self.__lb = ( Utils.Tools._makevector_FI (lb_scalar,1) )
      self.__idxmap_lb = None
    if   (ub_matrix != None):
      bnd_ = ub_matrix

      if   (self._shape == None):
        self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
      _autovar_624 = bnd_
      if   isinstance(_autovar_624,mosek.fusion.DenseMatrix):
        m = _autovar_624
        self.__ub = m._data
        self.__idxmap_ub = None
      elif isinstance(_autovar_624,mosek.fusion.SparseMatrix):
        m = _autovar_624
        self.__ub = m._val
        self.__idxmap_ub = mosek.fusion.Utils.IntMap()
        # src/fusion/domain.mbi(662:13-665:13)
        i = 0

        while (i < int(len(self.__ub))):
          ( self.__idxmap_ub._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
          i += 1
      else:
        m = _autovar_624
        raise mosek.fusion.UnimplementedError("Unknown matrix type.")
    else:
      self.__ub = ( Utils.Tools._makevector_FI (ub_scalar,1) )
      self.__idxmap_ub = None
  def __init__(self,*args):
    #self._protected_shape = None

    #self.__idxmap_lb = None

    #self.__idxmap_ub = None

    #self.__lb = None

    #self.__ub = None

    if   self._matchargs_constructor__3F_3FB(args):
      self.__constructor__3F_3FB(*args)
    elif self._matchargs_constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(args):
      self.__constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_get_1lb_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(680:18-708:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_lb_item(long)")
  def _get_1lb_1item_L(self,index):
    if   (self.__idxmap_lb != None):
      if   ( self.__idxmap_lb._hasItem_L(index) ):
        return self.__lb[( self.__idxmap_lb._getItem_L(index) )]
      else:
        return 0.0
    else:
      if   (int(len(self.__lb)) == 1):
        return self.__lb[0]
      elif (self.__lb != None):
        return self.__lb[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_get_1ub_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(711:18-739:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_ub_item(long)")
  def _get_1ub_1item_L(self,index):
    if   (self.__idxmap_ub != None):
      if   ( self.__idxmap_ub._hasItem_L(index) ):
        return self.__ub[( self.__idxmap_ub._getItem_L(index) )]
      else:
        return 0.0
    else:
      if   (int(len(self.__ub)) == 1):
        return self.__ub[0]
      elif (self.__ub != None):
        return self.__ub[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_match_1shape_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/domain.mbi(742:18-762:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("match_shape(mosek.fusion.Set)")
  def _match_1shape_Omosek_fusion_Set_2(self,shp):
    if   (self._shape == None):
      return True
    elif (self._shape.nd == shp.nd):
      # src/fusion/domain.mbi(749:11-755:11)
      i = 0

      while (i < self._shape.nd):
        if   (( shp._dim_I(i) ) != ( self._shape._dim_I(i) )):
          return False
        i += 1
      return True
    else:
      return False

import mosek.fusion.Utils
import mosek.fusion

